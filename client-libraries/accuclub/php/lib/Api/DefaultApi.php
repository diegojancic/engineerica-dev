<?php
/**
 * DefaultApi
 * PHP version 5
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * AccuCampus OpenAPI 3 Documentation
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 4.3.1
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * DefaultApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class DefaultApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $host_index (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $host_index = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $host_index;
    }

    /**
     * Set the host index
     *
     * @param  int Host index (required)
     */
    public function setHostIndex($host_index)
    {
        $this->hostIndex = $host_index;
    }

    /**
     * Get the host index
     *
     * @return Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation actionloglist
     *
     * View a list of users action logs
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $user The id of the user whose action logs have to be returned. (optional)
     * @param  \DateTime $startdate The start date of the period to filter the logs. (optional)
     * @param  \DateTime $enddate The end date of the period to filter the logs. (optional)
     * @param  string $resource The resource to filter the action logs. (optional)
     * @param  string $actionfilter The action to filter the action logs. (optional)
     * @param  string $argument The id of the entity that was the argument of the executed action. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function actionloglist($token, $from, $count, $user = null, $startdate = null, $enddate = null, $resource = null, $actionfilter = null, $argument = null)
    {
        $this->actionloglistWithHttpInfo($token, $from, $count, $user, $startdate, $enddate, $resource, $actionfilter, $argument);
    }

    /**
     * Operation actionloglistWithHttpInfo
     *
     * View a list of users action logs
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $user The id of the user whose action logs have to be returned. (optional)
     * @param  \DateTime $startdate The start date of the period to filter the logs. (optional)
     * @param  \DateTime $enddate The end date of the period to filter the logs. (optional)
     * @param  string $resource The resource to filter the action logs. (optional)
     * @param  string $actionfilter The action to filter the action logs. (optional)
     * @param  string $argument The id of the entity that was the argument of the executed action. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionloglistWithHttpInfo($token, $from, $count, $user = null, $startdate = null, $enddate = null, $resource = null, $actionfilter = null, $argument = null)
    {
        $request = $this->actionloglistRequest($token, $from, $count, $user, $startdate, $enddate, $resource, $actionfilter, $argument);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation actionloglistAsync
     *
     * View a list of users action logs
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $user The id of the user whose action logs have to be returned. (optional)
     * @param  \DateTime $startdate The start date of the period to filter the logs. (optional)
     * @param  \DateTime $enddate The end date of the period to filter the logs. (optional)
     * @param  string $resource The resource to filter the action logs. (optional)
     * @param  string $actionfilter The action to filter the action logs. (optional)
     * @param  string $argument The id of the entity that was the argument of the executed action. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionloglistAsync($token, $from, $count, $user = null, $startdate = null, $enddate = null, $resource = null, $actionfilter = null, $argument = null)
    {
        return $this->actionloglistAsyncWithHttpInfo($token, $from, $count, $user, $startdate, $enddate, $resource, $actionfilter, $argument)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionloglistAsyncWithHttpInfo
     *
     * View a list of users action logs
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $user The id of the user whose action logs have to be returned. (optional)
     * @param  \DateTime $startdate The start date of the period to filter the logs. (optional)
     * @param  \DateTime $enddate The end date of the period to filter the logs. (optional)
     * @param  string $resource The resource to filter the action logs. (optional)
     * @param  string $actionfilter The action to filter the action logs. (optional)
     * @param  string $argument The id of the entity that was the argument of the executed action. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionloglistAsyncWithHttpInfo($token, $from, $count, $user = null, $startdate = null, $enddate = null, $resource = null, $actionfilter = null, $argument = null)
    {
        $returnType = '';
        $request = $this->actionloglistRequest($token, $from, $count, $user, $startdate, $enddate, $resource, $actionfilter, $argument);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionloglist'
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $user The id of the user whose action logs have to be returned. (optional)
     * @param  \DateTime $startdate The start date of the period to filter the logs. (optional)
     * @param  \DateTime $enddate The end date of the period to filter the logs. (optional)
     * @param  string $resource The resource to filter the action logs. (optional)
     * @param  string $actionfilter The action to filter the action logs. (optional)
     * @param  string $argument The id of the entity that was the argument of the executed action. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function actionloglistRequest($token, $from, $count, $user = null, $startdate = null, $enddate = null, $resource = null, $actionfilter = null, $argument = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling actionloglist'
            );
        }
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling actionloglist'
            );
        }
        // verify the required parameter 'count' is set
        if ($count === null || (is_array($count) && count($count) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $count when calling actionloglist'
            );
        }

        $resourcePath = '/actionloglist';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($user !== null) {
            if('form' === 'form' && is_array($user)) {
                foreach($user as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['user'] = $user;
            }
        }
        // query params
        if ($startdate !== null) {
            if('form' === 'form' && is_array($startdate)) {
                foreach($startdate as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['startdate'] = $startdate;
            }
        }
        // query params
        if ($enddate !== null) {
            if('form' === 'form' && is_array($enddate)) {
                foreach($enddate as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['enddate'] = $enddate;
            }
        }
        // query params
        if ($resource !== null) {
            if('form' === 'form' && is_array($resource)) {
                foreach($resource as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['resource'] = $resource;
            }
        }
        // query params
        if ($actionfilter !== null) {
            if('form' === 'form' && is_array($actionfilter)) {
                foreach($actionfilter as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['actionfilter'] = $actionfilter;
            }
        }
        // query params
        if ($argument !== null) {
            if('form' === 'form' && is_array($argument)) {
                foreach($argument as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['argument'] = $argument;
            }
        }
        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }
        // query params
        if ($count !== null) {
            if('form' === 'form' && is_array($count)) {
                foreach($count as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['count'] = $count;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation advroleaddmissing
     *
     * Adds the missing permissions to a role. Requires access to advrole.save
     *
     * @param  string $token The authentication token. (required)
     * @param  string $roles CSV list of the role ids to check (required)
     * @param  string $permissions CSV list of the permissions to check (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function advroleaddmissing($token, $roles, $permissions)
    {
        $this->advroleaddmissingWithHttpInfo($token, $roles, $permissions);
    }

    /**
     * Operation advroleaddmissingWithHttpInfo
     *
     * Adds the missing permissions to a role. Requires access to advrole.save
     *
     * @param  string $token The authentication token. (required)
     * @param  string $roles CSV list of the role ids to check (required)
     * @param  string $permissions CSV list of the permissions to check (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function advroleaddmissingWithHttpInfo($token, $roles, $permissions)
    {
        $request = $this->advroleaddmissingRequest($token, $roles, $permissions);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation advroleaddmissingAsync
     *
     * Adds the missing permissions to a role. Requires access to advrole.save
     *
     * @param  string $token The authentication token. (required)
     * @param  string $roles CSV list of the role ids to check (required)
     * @param  string $permissions CSV list of the permissions to check (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function advroleaddmissingAsync($token, $roles, $permissions)
    {
        return $this->advroleaddmissingAsyncWithHttpInfo($token, $roles, $permissions)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation advroleaddmissingAsyncWithHttpInfo
     *
     * Adds the missing permissions to a role. Requires access to advrole.save
     *
     * @param  string $token The authentication token. (required)
     * @param  string $roles CSV list of the role ids to check (required)
     * @param  string $permissions CSV list of the permissions to check (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function advroleaddmissingAsyncWithHttpInfo($token, $roles, $permissions)
    {
        $returnType = '';
        $request = $this->advroleaddmissingRequest($token, $roles, $permissions);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'advroleaddmissing'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $roles CSV list of the role ids to check (required)
     * @param  string $permissions CSV list of the permissions to check (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function advroleaddmissingRequest($token, $roles, $permissions)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling advroleaddmissing'
            );
        }
        // verify the required parameter 'roles' is set
        if ($roles === null || (is_array($roles) && count($roles) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $roles when calling advroleaddmissing'
            );
        }
        // verify the required parameter 'permissions' is set
        if ($permissions === null || (is_array($permissions) && count($permissions) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $permissions when calling advroleaddmissing'
            );
        }

        $resourcePath = '/advroleaddmissing';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($roles !== null) {
            if('form' === 'form' && is_array($roles)) {
                foreach($roles as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['roles'] = $roles;
            }
        }
        // query params
        if ($permissions !== null) {
            if('form' === 'form' && is_array($permissions)) {
                foreach($permissions as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['permissions'] = $permissions;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation advrolecheckperm
     *
     * Checks the permissions are assigned for the given roles
     *
     * @param  string $token The authentication token. (required)
     * @param  string $roles CSV list of the role ids to check (required)
     * @param  string $permissions CSV list of the permissions to check (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function advrolecheckperm($token, $roles, $permissions)
    {
        $this->advrolecheckpermWithHttpInfo($token, $roles, $permissions);
    }

    /**
     * Operation advrolecheckpermWithHttpInfo
     *
     * Checks the permissions are assigned for the given roles
     *
     * @param  string $token The authentication token. (required)
     * @param  string $roles CSV list of the role ids to check (required)
     * @param  string $permissions CSV list of the permissions to check (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function advrolecheckpermWithHttpInfo($token, $roles, $permissions)
    {
        $request = $this->advrolecheckpermRequest($token, $roles, $permissions);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation advrolecheckpermAsync
     *
     * Checks the permissions are assigned for the given roles
     *
     * @param  string $token The authentication token. (required)
     * @param  string $roles CSV list of the role ids to check (required)
     * @param  string $permissions CSV list of the permissions to check (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function advrolecheckpermAsync($token, $roles, $permissions)
    {
        return $this->advrolecheckpermAsyncWithHttpInfo($token, $roles, $permissions)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation advrolecheckpermAsyncWithHttpInfo
     *
     * Checks the permissions are assigned for the given roles
     *
     * @param  string $token The authentication token. (required)
     * @param  string $roles CSV list of the role ids to check (required)
     * @param  string $permissions CSV list of the permissions to check (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function advrolecheckpermAsyncWithHttpInfo($token, $roles, $permissions)
    {
        $returnType = '';
        $request = $this->advrolecheckpermRequest($token, $roles, $permissions);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'advrolecheckperm'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $roles CSV list of the role ids to check (required)
     * @param  string $permissions CSV list of the permissions to check (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function advrolecheckpermRequest($token, $roles, $permissions)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling advrolecheckperm'
            );
        }
        // verify the required parameter 'roles' is set
        if ($roles === null || (is_array($roles) && count($roles) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $roles when calling advrolecheckperm'
            );
        }
        // verify the required parameter 'permissions' is set
        if ($permissions === null || (is_array($permissions) && count($permissions) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $permissions when calling advrolecheckperm'
            );
        }

        $resourcePath = '/advrolecheckperm';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($roles !== null) {
            if('form' === 'form' && is_array($roles)) {
                foreach($roles as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['roles'] = $roles;
            }
        }
        // query params
        if ($permissions !== null) {
            if('form' === 'form' && is_array($permissions)) {
                foreach($permissions as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['permissions'] = $permissions;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation advroledelete
     *
     * Delete a role
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the location to delete. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function advroledelete($token, $id)
    {
        $this->advroledeleteWithHttpInfo($token, $id);
    }

    /**
     * Operation advroledeleteWithHttpInfo
     *
     * Delete a role
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the location to delete. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function advroledeleteWithHttpInfo($token, $id)
    {
        $request = $this->advroledeleteRequest($token, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation advroledeleteAsync
     *
     * Delete a role
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the location to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function advroledeleteAsync($token, $id)
    {
        return $this->advroledeleteAsyncWithHttpInfo($token, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation advroledeleteAsyncWithHttpInfo
     *
     * Delete a role
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the location to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function advroledeleteAsyncWithHttpInfo($token, $id)
    {
        $returnType = '';
        $request = $this->advroledeleteRequest($token, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'advroledelete'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the location to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function advroledeleteRequest($token, $id)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling advroledelete'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling advroledelete'
            );
        }

        $resourcePath = '/advroledelete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($id !== null) {
            if('form' === 'form' && is_array($id)) {
                foreach($id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['id'] = $id;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation advroledeletemapping
     *
     * Delete a role mapping
     *
     * @param  string $token The authentication token. (required)
     * @param  string $map The map name to save the role. (required)
     * @param  string $roleid The id of the role. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function advroledeletemapping($token, $map, $roleid)
    {
        $this->advroledeletemappingWithHttpInfo($token, $map, $roleid);
    }

    /**
     * Operation advroledeletemappingWithHttpInfo
     *
     * Delete a role mapping
     *
     * @param  string $token The authentication token. (required)
     * @param  string $map The map name to save the role. (required)
     * @param  string $roleid The id of the role. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function advroledeletemappingWithHttpInfo($token, $map, $roleid)
    {
        $request = $this->advroledeletemappingRequest($token, $map, $roleid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation advroledeletemappingAsync
     *
     * Delete a role mapping
     *
     * @param  string $token The authentication token. (required)
     * @param  string $map The map name to save the role. (required)
     * @param  string $roleid The id of the role. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function advroledeletemappingAsync($token, $map, $roleid)
    {
        return $this->advroledeletemappingAsyncWithHttpInfo($token, $map, $roleid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation advroledeletemappingAsyncWithHttpInfo
     *
     * Delete a role mapping
     *
     * @param  string $token The authentication token. (required)
     * @param  string $map The map name to save the role. (required)
     * @param  string $roleid The id of the role. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function advroledeletemappingAsyncWithHttpInfo($token, $map, $roleid)
    {
        $returnType = '';
        $request = $this->advroledeletemappingRequest($token, $map, $roleid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'advroledeletemapping'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $map The map name to save the role. (required)
     * @param  string $roleid The id of the role. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function advroledeletemappingRequest($token, $map, $roleid)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling advroledeletemapping'
            );
        }
        // verify the required parameter 'map' is set
        if ($map === null || (is_array($map) && count($map) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $map when calling advroledeletemapping'
            );
        }
        // verify the required parameter 'roleid' is set
        if ($roleid === null || (is_array($roleid) && count($roleid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $roleid when calling advroledeletemapping'
            );
        }

        $resourcePath = '/advroledeletemapping';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($map !== null) {
            if('form' === 'form' && is_array($map)) {
                foreach($map as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['map'] = $map;
            }
        }
        // query params
        if ($roleid !== null) {
            if('form' === 'form' && is_array($roleid)) {
                foreach($roleid as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['roleid'] = $roleid;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation advroleget
     *
     * View details of a role
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the location to get. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function advroleget($token, $id)
    {
        $this->advrolegetWithHttpInfo($token, $id);
    }

    /**
     * Operation advrolegetWithHttpInfo
     *
     * View details of a role
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the location to get. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function advrolegetWithHttpInfo($token, $id)
    {
        $request = $this->advrolegetRequest($token, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation advrolegetAsync
     *
     * View details of a role
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the location to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function advrolegetAsync($token, $id)
    {
        return $this->advrolegetAsyncWithHttpInfo($token, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation advrolegetAsyncWithHttpInfo
     *
     * View details of a role
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the location to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function advrolegetAsyncWithHttpInfo($token, $id)
    {
        $returnType = '';
        $request = $this->advrolegetRequest($token, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'advroleget'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the location to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function advrolegetRequest($token, $id)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling advroleget'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling advroleget'
            );
        }

        $resourcePath = '/advroleget';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($id !== null) {
            if('form' === 'form' && is_array($id)) {
                foreach($id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['id'] = $id;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation advrolelist
     *
     * Lists the roles for the current account
     *
     * @param  string $token The authentication token. (required)
     * @param  bool $includepolicies True to include the policies, defaults to false. (optional)
     * @param  bool $includeinternal True to include the internal roles too. (optional)
     * @param  string $name Filter by name of the role. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function advrolelist($token, $includepolicies = null, $includeinternal = null, $name = null)
    {
        $this->advrolelistWithHttpInfo($token, $includepolicies, $includeinternal, $name);
    }

    /**
     * Operation advrolelistWithHttpInfo
     *
     * Lists the roles for the current account
     *
     * @param  string $token The authentication token. (required)
     * @param  bool $includepolicies True to include the policies, defaults to false. (optional)
     * @param  bool $includeinternal True to include the internal roles too. (optional)
     * @param  string $name Filter by name of the role. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function advrolelistWithHttpInfo($token, $includepolicies = null, $includeinternal = null, $name = null)
    {
        $request = $this->advrolelistRequest($token, $includepolicies, $includeinternal, $name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation advrolelistAsync
     *
     * Lists the roles for the current account
     *
     * @param  string $token The authentication token. (required)
     * @param  bool $includepolicies True to include the policies, defaults to false. (optional)
     * @param  bool $includeinternal True to include the internal roles too. (optional)
     * @param  string $name Filter by name of the role. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function advrolelistAsync($token, $includepolicies = null, $includeinternal = null, $name = null)
    {
        return $this->advrolelistAsyncWithHttpInfo($token, $includepolicies, $includeinternal, $name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation advrolelistAsyncWithHttpInfo
     *
     * Lists the roles for the current account
     *
     * @param  string $token The authentication token. (required)
     * @param  bool $includepolicies True to include the policies, defaults to false. (optional)
     * @param  bool $includeinternal True to include the internal roles too. (optional)
     * @param  string $name Filter by name of the role. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function advrolelistAsyncWithHttpInfo($token, $includepolicies = null, $includeinternal = null, $name = null)
    {
        $returnType = '';
        $request = $this->advrolelistRequest($token, $includepolicies, $includeinternal, $name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'advrolelist'
     *
     * @param  string $token The authentication token. (required)
     * @param  bool $includepolicies True to include the policies, defaults to false. (optional)
     * @param  bool $includeinternal True to include the internal roles too. (optional)
     * @param  string $name Filter by name of the role. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function advrolelistRequest($token, $includepolicies = null, $includeinternal = null, $name = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling advrolelist'
            );
        }

        $resourcePath = '/advrolelist';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($includepolicies !== null) {
            if('form' === 'form' && is_array($includepolicies)) {
                foreach($includepolicies as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['includepolicies'] = $includepolicies;
            }
        }
        // query params
        if ($includeinternal !== null) {
            if('form' === 'form' && is_array($includeinternal)) {
                foreach($includeinternal as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['includeinternal'] = $includeinternal;
            }
        }
        // query params
        if ($name !== null) {
            if('form' === 'form' && is_array($name)) {
                foreach($name as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['name'] = $name;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation advrolelistmaps
     *
     * Lists the maps a roles is mapped to
     *
     * @param  string $token The authentication token. (required)
     * @param  string $roleid The id of the role to list the maps. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function advrolelistmaps($token, $roleid)
    {
        $this->advrolelistmapsWithHttpInfo($token, $roleid);
    }

    /**
     * Operation advrolelistmapsWithHttpInfo
     *
     * Lists the maps a roles is mapped to
     *
     * @param  string $token The authentication token. (required)
     * @param  string $roleid The id of the role to list the maps. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function advrolelistmapsWithHttpInfo($token, $roleid)
    {
        $request = $this->advrolelistmapsRequest($token, $roleid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation advrolelistmapsAsync
     *
     * Lists the maps a roles is mapped to
     *
     * @param  string $token The authentication token. (required)
     * @param  string $roleid The id of the role to list the maps. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function advrolelistmapsAsync($token, $roleid)
    {
        return $this->advrolelistmapsAsyncWithHttpInfo($token, $roleid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation advrolelistmapsAsyncWithHttpInfo
     *
     * Lists the maps a roles is mapped to
     *
     * @param  string $token The authentication token. (required)
     * @param  string $roleid The id of the role to list the maps. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function advrolelistmapsAsyncWithHttpInfo($token, $roleid)
    {
        $returnType = '';
        $request = $this->advrolelistmapsRequest($token, $roleid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'advrolelistmaps'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $roleid The id of the role to list the maps. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function advrolelistmapsRequest($token, $roleid)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling advrolelistmaps'
            );
        }
        // verify the required parameter 'roleid' is set
        if ($roleid === null || (is_array($roleid) && count($roleid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $roleid when calling advrolelistmaps'
            );
        }

        $resourcePath = '/advrolelistmaps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($roleid !== null) {
            if('form' === 'form' && is_array($roleid)) {
                foreach($roleid as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['roleid'] = $roleid;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation advrolelistrolesmapped
     *
     * Lists the roles mappings
     *
     * @param  string $token The authentication token. (required)
     * @param  string $map List only the roles in the specified map. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function advrolelistrolesmapped($token, $map = null)
    {
        $this->advrolelistrolesmappedWithHttpInfo($token, $map);
    }

    /**
     * Operation advrolelistrolesmappedWithHttpInfo
     *
     * Lists the roles mappings
     *
     * @param  string $token The authentication token. (required)
     * @param  string $map List only the roles in the specified map. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function advrolelistrolesmappedWithHttpInfo($token, $map = null)
    {
        $request = $this->advrolelistrolesmappedRequest($token, $map);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation advrolelistrolesmappedAsync
     *
     * Lists the roles mappings
     *
     * @param  string $token The authentication token. (required)
     * @param  string $map List only the roles in the specified map. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function advrolelistrolesmappedAsync($token, $map = null)
    {
        return $this->advrolelistrolesmappedAsyncWithHttpInfo($token, $map)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation advrolelistrolesmappedAsyncWithHttpInfo
     *
     * Lists the roles mappings
     *
     * @param  string $token The authentication token. (required)
     * @param  string $map List only the roles in the specified map. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function advrolelistrolesmappedAsyncWithHttpInfo($token, $map = null)
    {
        $returnType = '';
        $request = $this->advrolelistrolesmappedRequest($token, $map);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'advrolelistrolesmapped'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $map List only the roles in the specified map. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function advrolelistrolesmappedRequest($token, $map = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling advrolelistrolesmapped'
            );
        }

        $resourcePath = '/advrolelistrolesmapped';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($map !== null) {
            if('form' === 'form' && is_array($map)) {
                foreach($map as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['map'] = $map;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation advrolelisttemplates
     *
     * View a list of role templates
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function advrolelisttemplates($token)
    {
        $this->advrolelisttemplatesWithHttpInfo($token);
    }

    /**
     * Operation advrolelisttemplatesWithHttpInfo
     *
     * View a list of role templates
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function advrolelisttemplatesWithHttpInfo($token)
    {
        $request = $this->advrolelisttemplatesRequest($token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation advrolelisttemplatesAsync
     *
     * View a list of role templates
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function advrolelisttemplatesAsync($token)
    {
        return $this->advrolelisttemplatesAsyncWithHttpInfo($token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation advrolelisttemplatesAsyncWithHttpInfo
     *
     * View a list of role templates
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function advrolelisttemplatesAsyncWithHttpInfo($token)
    {
        $returnType = '';
        $request = $this->advrolelisttemplatesRequest($token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'advrolelisttemplates'
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function advrolelisttemplatesRequest($token)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling advrolelisttemplates'
            );
        }

        $resourcePath = '/advrolelisttemplates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation advrolesave
     *
     * Create or edit a role
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function advrolesave($unknown_base_type = null)
    {
        $this->advrolesaveWithHttpInfo($unknown_base_type);
    }

    /**
     * Operation advrolesaveWithHttpInfo
     *
     * Create or edit a role
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function advrolesaveWithHttpInfo($unknown_base_type = null)
    {
        $request = $this->advrolesaveRequest($unknown_base_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation advrolesaveAsync
     *
     * Create or edit a role
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function advrolesaveAsync($unknown_base_type = null)
    {
        return $this->advrolesaveAsyncWithHttpInfo($unknown_base_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation advrolesaveAsyncWithHttpInfo
     *
     * Create or edit a role
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function advrolesaveAsyncWithHttpInfo($unknown_base_type = null)
    {
        $returnType = '';
        $request = $this->advrolesaveRequest($unknown_base_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'advrolesave'
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function advrolesaveRequest($unknown_base_type = null)
    {

        $resourcePath = '/advrolesave';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($unknown_base_type)) {
            $_tempBody = $unknown_base_type;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation advrolesavemapping
     *
     * Saves a role mapping
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function advrolesavemapping($unknown_base_type = null)
    {
        $this->advrolesavemappingWithHttpInfo($unknown_base_type);
    }

    /**
     * Operation advrolesavemappingWithHttpInfo
     *
     * Saves a role mapping
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function advrolesavemappingWithHttpInfo($unknown_base_type = null)
    {
        $request = $this->advrolesavemappingRequest($unknown_base_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation advrolesavemappingAsync
     *
     * Saves a role mapping
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function advrolesavemappingAsync($unknown_base_type = null)
    {
        return $this->advrolesavemappingAsyncWithHttpInfo($unknown_base_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation advrolesavemappingAsyncWithHttpInfo
     *
     * Saves a role mapping
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function advrolesavemappingAsyncWithHttpInfo($unknown_base_type = null)
    {
        $returnType = '';
        $request = $this->advrolesavemappingRequest($unknown_base_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'advrolesavemapping'
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function advrolesavemappingRequest($unknown_base_type = null)
    {

        $resourcePath = '/advrolesavemapping';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($unknown_base_type)) {
            $_tempBody = $unknown_base_type;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation advrolesuserlist
     *
     * List users. Alias to user.list, use that one instead.
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $roleid The id of the role to filter users by, or empty to return all users. (optional)
     * @param  string $onlywithoutcard If is 1 then only the users without a card are returned, otherwise all users are returned. (optional)
     * @param  int $photosize The size in pixels of the photo URLs returned. Defaults to 40. If the size specified is not available, a similar one will be returned. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function advrolesuserlist($token, $from, $count, $roleid = null, $onlywithoutcard = null, $photosize = null)
    {
        $this->advrolesuserlistWithHttpInfo($token, $from, $count, $roleid, $onlywithoutcard, $photosize);
    }

    /**
     * Operation advrolesuserlistWithHttpInfo
     *
     * List users. Alias to user.list, use that one instead.
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $roleid The id of the role to filter users by, or empty to return all users. (optional)
     * @param  string $onlywithoutcard If is 1 then only the users without a card are returned, otherwise all users are returned. (optional)
     * @param  int $photosize The size in pixels of the photo URLs returned. Defaults to 40. If the size specified is not available, a similar one will be returned. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function advrolesuserlistWithHttpInfo($token, $from, $count, $roleid = null, $onlywithoutcard = null, $photosize = null)
    {
        $request = $this->advrolesuserlistRequest($token, $from, $count, $roleid, $onlywithoutcard, $photosize);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation advrolesuserlistAsync
     *
     * List users. Alias to user.list, use that one instead.
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $roleid The id of the role to filter users by, or empty to return all users. (optional)
     * @param  string $onlywithoutcard If is 1 then only the users without a card are returned, otherwise all users are returned. (optional)
     * @param  int $photosize The size in pixels of the photo URLs returned. Defaults to 40. If the size specified is not available, a similar one will be returned. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function advrolesuserlistAsync($token, $from, $count, $roleid = null, $onlywithoutcard = null, $photosize = null)
    {
        return $this->advrolesuserlistAsyncWithHttpInfo($token, $from, $count, $roleid, $onlywithoutcard, $photosize)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation advrolesuserlistAsyncWithHttpInfo
     *
     * List users. Alias to user.list, use that one instead.
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $roleid The id of the role to filter users by, or empty to return all users. (optional)
     * @param  string $onlywithoutcard If is 1 then only the users without a card are returned, otherwise all users are returned. (optional)
     * @param  int $photosize The size in pixels of the photo URLs returned. Defaults to 40. If the size specified is not available, a similar one will be returned. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function advrolesuserlistAsyncWithHttpInfo($token, $from, $count, $roleid = null, $onlywithoutcard = null, $photosize = null)
    {
        $returnType = '';
        $request = $this->advrolesuserlistRequest($token, $from, $count, $roleid, $onlywithoutcard, $photosize);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'advrolesuserlist'
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $roleid The id of the role to filter users by, or empty to return all users. (optional)
     * @param  string $onlywithoutcard If is 1 then only the users without a card are returned, otherwise all users are returned. (optional)
     * @param  int $photosize The size in pixels of the photo URLs returned. Defaults to 40. If the size specified is not available, a similar one will be returned. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function advrolesuserlistRequest($token, $from, $count, $roleid = null, $onlywithoutcard = null, $photosize = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling advrolesuserlist'
            );
        }
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling advrolesuserlist'
            );
        }
        // verify the required parameter 'count' is set
        if ($count === null || (is_array($count) && count($count) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $count when calling advrolesuserlist'
            );
        }

        $resourcePath = '/advrolesuserlist';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }
        // query params
        if ($count !== null) {
            if('form' === 'form' && is_array($count)) {
                foreach($count as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['count'] = $count;
            }
        }
        // query params
        if ($roleid !== null) {
            if('form' === 'form' && is_array($roleid)) {
                foreach($roleid as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['roleid'] = $roleid;
            }
        }
        // query params
        if ($onlywithoutcard !== null) {
            if('form' === 'form' && is_array($onlywithoutcard)) {
                foreach($onlywithoutcard as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['onlywithoutcard'] = $onlywithoutcard;
            }
        }
        // query params
        if ($photosize !== null) {
            if('form' === 'form' && is_array($photosize)) {
                foreach($photosize as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['photosize'] = $photosize;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation advroleuserupgrade
     *
     * Upgrade a user to another role (requires permission to edit those roles)
     *
     * @param  string $token The authentication token. (required)
     * @param  string $userid Id of the user to upgrade (required)
     * @param  string $roleid Id of the role to add (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function advroleuserupgrade($token, $userid, $roleid)
    {
        $this->advroleuserupgradeWithHttpInfo($token, $userid, $roleid);
    }

    /**
     * Operation advroleuserupgradeWithHttpInfo
     *
     * Upgrade a user to another role (requires permission to edit those roles)
     *
     * @param  string $token The authentication token. (required)
     * @param  string $userid Id of the user to upgrade (required)
     * @param  string $roleid Id of the role to add (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function advroleuserupgradeWithHttpInfo($token, $userid, $roleid)
    {
        $request = $this->advroleuserupgradeRequest($token, $userid, $roleid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation advroleuserupgradeAsync
     *
     * Upgrade a user to another role (requires permission to edit those roles)
     *
     * @param  string $token The authentication token. (required)
     * @param  string $userid Id of the user to upgrade (required)
     * @param  string $roleid Id of the role to add (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function advroleuserupgradeAsync($token, $userid, $roleid)
    {
        return $this->advroleuserupgradeAsyncWithHttpInfo($token, $userid, $roleid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation advroleuserupgradeAsyncWithHttpInfo
     *
     * Upgrade a user to another role (requires permission to edit those roles)
     *
     * @param  string $token The authentication token. (required)
     * @param  string $userid Id of the user to upgrade (required)
     * @param  string $roleid Id of the role to add (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function advroleuserupgradeAsyncWithHttpInfo($token, $userid, $roleid)
    {
        $returnType = '';
        $request = $this->advroleuserupgradeRequest($token, $userid, $roleid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'advroleuserupgrade'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $userid Id of the user to upgrade (required)
     * @param  string $roleid Id of the role to add (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function advroleuserupgradeRequest($token, $userid, $roleid)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling advroleuserupgrade'
            );
        }
        // verify the required parameter 'userid' is set
        if ($userid === null || (is_array($userid) && count($userid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userid when calling advroleuserupgrade'
            );
        }
        // verify the required parameter 'roleid' is set
        if ($roleid === null || (is_array($roleid) && count($roleid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $roleid when calling advroleuserupgrade'
            );
        }

        $resourcePath = '/advroleuserupgrade';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($userid !== null) {
            if('form' === 'form' && is_array($userid)) {
                foreach($userid as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['userid'] = $userid;
            }
        }
        // query params
        if ($roleid !== null) {
            if('form' === 'form' && is_array($roleid)) {
                foreach($roleid as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['roleid'] = $roleid;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation appsharegetphone
     *
     * Gets the phone number of the current user
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function appsharegetphone($token)
    {
        $this->appsharegetphoneWithHttpInfo($token);
    }

    /**
     * Operation appsharegetphoneWithHttpInfo
     *
     * Gets the phone number of the current user
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function appsharegetphoneWithHttpInfo($token)
    {
        $request = $this->appsharegetphoneRequest($token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation appsharegetphoneAsync
     *
     * Gets the phone number of the current user
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appsharegetphoneAsync($token)
    {
        return $this->appsharegetphoneAsyncWithHttpInfo($token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation appsharegetphoneAsyncWithHttpInfo
     *
     * Gets the phone number of the current user
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appsharegetphoneAsyncWithHttpInfo($token)
    {
        $returnType = '';
        $request = $this->appsharegetphoneRequest($token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'appsharegetphone'
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function appsharegetphoneRequest($token)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling appsharegetphone'
            );
        }

        $resourcePath = '/appsharegetphone';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation appsharesendtext
     *
     * Sends an SMS with the link to the app
     *
     * @param  string $token The authentication token. (required)
     * @param  string $phonenumber Phone number to where to send the link. Leave empty to the number on file. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function appsharesendtext($token, $phonenumber = null)
    {
        $this->appsharesendtextWithHttpInfo($token, $phonenumber);
    }

    /**
     * Operation appsharesendtextWithHttpInfo
     *
     * Sends an SMS with the link to the app
     *
     * @param  string $token The authentication token. (required)
     * @param  string $phonenumber Phone number to where to send the link. Leave empty to the number on file. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function appsharesendtextWithHttpInfo($token, $phonenumber = null)
    {
        $request = $this->appsharesendtextRequest($token, $phonenumber);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation appsharesendtextAsync
     *
     * Sends an SMS with the link to the app
     *
     * @param  string $token The authentication token. (required)
     * @param  string $phonenumber Phone number to where to send the link. Leave empty to the number on file. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appsharesendtextAsync($token, $phonenumber = null)
    {
        return $this->appsharesendtextAsyncWithHttpInfo($token, $phonenumber)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation appsharesendtextAsyncWithHttpInfo
     *
     * Sends an SMS with the link to the app
     *
     * @param  string $token The authentication token. (required)
     * @param  string $phonenumber Phone number to where to send the link. Leave empty to the number on file. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appsharesendtextAsyncWithHttpInfo($token, $phonenumber = null)
    {
        $returnType = '';
        $request = $this->appsharesendtextRequest($token, $phonenumber);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'appsharesendtext'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $phonenumber Phone number to where to send the link. Leave empty to the number on file. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function appsharesendtextRequest($token, $phonenumber = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling appsharesendtext'
            );
        }

        $resourcePath = '/appsharesendtext';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($phonenumber !== null) {
            if('form' === 'form' && is_array($phonenumber)) {
                foreach($phonenumber as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['phonenumber'] = $phonenumber;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation attendancelogcommentdelete
     *
     * Delete a comment on an attendance log
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the attendance log comment to delete. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function attendancelogcommentdelete($token, $id)
    {
        $this->attendancelogcommentdeleteWithHttpInfo($token, $id);
    }

    /**
     * Operation attendancelogcommentdeleteWithHttpInfo
     *
     * Delete a comment on an attendance log
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the attendance log comment to delete. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function attendancelogcommentdeleteWithHttpInfo($token, $id)
    {
        $request = $this->attendancelogcommentdeleteRequest($token, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation attendancelogcommentdeleteAsync
     *
     * Delete a comment on an attendance log
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the attendance log comment to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function attendancelogcommentdeleteAsync($token, $id)
    {
        return $this->attendancelogcommentdeleteAsyncWithHttpInfo($token, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation attendancelogcommentdeleteAsyncWithHttpInfo
     *
     * Delete a comment on an attendance log
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the attendance log comment to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function attendancelogcommentdeleteAsyncWithHttpInfo($token, $id)
    {
        $returnType = '';
        $request = $this->attendancelogcommentdeleteRequest($token, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'attendancelogcommentdelete'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the attendance log comment to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function attendancelogcommentdeleteRequest($token, $id)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling attendancelogcommentdelete'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling attendancelogcommentdelete'
            );
        }

        $resourcePath = '/attendancelogcommentdelete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($id !== null) {
            if('form' === 'form' && is_array($id)) {
                foreach($id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['id'] = $id;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation attendancelogcommentget
     *
     * View a comment on an attendance log
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the comment to get. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function attendancelogcommentget($token, $id)
    {
        $this->attendancelogcommentgetWithHttpInfo($token, $id);
    }

    /**
     * Operation attendancelogcommentgetWithHttpInfo
     *
     * View a comment on an attendance log
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the comment to get. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function attendancelogcommentgetWithHttpInfo($token, $id)
    {
        $request = $this->attendancelogcommentgetRequest($token, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation attendancelogcommentgetAsync
     *
     * View a comment on an attendance log
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the comment to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function attendancelogcommentgetAsync($token, $id)
    {
        return $this->attendancelogcommentgetAsyncWithHttpInfo($token, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation attendancelogcommentgetAsyncWithHttpInfo
     *
     * View a comment on an attendance log
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the comment to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function attendancelogcommentgetAsyncWithHttpInfo($token, $id)
    {
        $returnType = '';
        $request = $this->attendancelogcommentgetRequest($token, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'attendancelogcommentget'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the comment to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function attendancelogcommentgetRequest($token, $id)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling attendancelogcommentget'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling attendancelogcommentget'
            );
        }

        $resourcePath = '/attendancelogcommentget';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($id !== null) {
            if('form' === 'form' && is_array($id)) {
                foreach($id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['id'] = $id;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation attendancelogcommentlist
     *
     * View all the comments on a specific attendance log
     *
     * @param  string $attendancelog The id of the attendance log whose comments have to be retrieved. (required)
     * @param  string $token The authentication token. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function attendancelogcommentlist($attendancelog, $token = null)
    {
        $this->attendancelogcommentlistWithHttpInfo($attendancelog, $token);
    }

    /**
     * Operation attendancelogcommentlistWithHttpInfo
     *
     * View all the comments on a specific attendance log
     *
     * @param  string $attendancelog The id of the attendance log whose comments have to be retrieved. (required)
     * @param  string $token The authentication token. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function attendancelogcommentlistWithHttpInfo($attendancelog, $token = null)
    {
        $request = $this->attendancelogcommentlistRequest($attendancelog, $token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation attendancelogcommentlistAsync
     *
     * View all the comments on a specific attendance log
     *
     * @param  string $attendancelog The id of the attendance log whose comments have to be retrieved. (required)
     * @param  string $token The authentication token. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function attendancelogcommentlistAsync($attendancelog, $token = null)
    {
        return $this->attendancelogcommentlistAsyncWithHttpInfo($attendancelog, $token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation attendancelogcommentlistAsyncWithHttpInfo
     *
     * View all the comments on a specific attendance log
     *
     * @param  string $attendancelog The id of the attendance log whose comments have to be retrieved. (required)
     * @param  string $token The authentication token. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function attendancelogcommentlistAsyncWithHttpInfo($attendancelog, $token = null)
    {
        $returnType = '';
        $request = $this->attendancelogcommentlistRequest($attendancelog, $token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'attendancelogcommentlist'
     *
     * @param  string $attendancelog The id of the attendance log whose comments have to be retrieved. (required)
     * @param  string $token The authentication token. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function attendancelogcommentlistRequest($attendancelog, $token = null)
    {
        // verify the required parameter 'attendancelog' is set
        if ($attendancelog === null || (is_array($attendancelog) && count($attendancelog) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attendancelog when calling attendancelogcommentlist'
            );
        }

        $resourcePath = '/attendancelogcommentlist';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($attendancelog !== null) {
            if('form' === 'form' && is_array($attendancelog)) {
                foreach($attendancelog as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['attendancelog'] = $attendancelog;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation attendancelogcommentsave
     *
     * Save a comment on an attendance log
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function attendancelogcommentsave($unknown_base_type = null)
    {
        $this->attendancelogcommentsaveWithHttpInfo($unknown_base_type);
    }

    /**
     * Operation attendancelogcommentsaveWithHttpInfo
     *
     * Save a comment on an attendance log
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function attendancelogcommentsaveWithHttpInfo($unknown_base_type = null)
    {
        $request = $this->attendancelogcommentsaveRequest($unknown_base_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation attendancelogcommentsaveAsync
     *
     * Save a comment on an attendance log
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function attendancelogcommentsaveAsync($unknown_base_type = null)
    {
        return $this->attendancelogcommentsaveAsyncWithHttpInfo($unknown_base_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation attendancelogcommentsaveAsyncWithHttpInfo
     *
     * Save a comment on an attendance log
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function attendancelogcommentsaveAsyncWithHttpInfo($unknown_base_type = null)
    {
        $returnType = '';
        $request = $this->attendancelogcommentsaveRequest($unknown_base_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'attendancelogcommentsave'
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function attendancelogcommentsaveRequest($unknown_base_type = null)
    {

        $resourcePath = '/attendancelogcommentsave';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($unknown_base_type)) {
            $_tempBody = $unknown_base_type;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation attendancelogdelete
     *
     * Delete an attendance log
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the attendance log to delete. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function attendancelogdelete($token, $id)
    {
        $this->attendancelogdeleteWithHttpInfo($token, $id);
    }

    /**
     * Operation attendancelogdeleteWithHttpInfo
     *
     * Delete an attendance log
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the attendance log to delete. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function attendancelogdeleteWithHttpInfo($token, $id)
    {
        $request = $this->attendancelogdeleteRequest($token, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation attendancelogdeleteAsync
     *
     * Delete an attendance log
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the attendance log to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function attendancelogdeleteAsync($token, $id)
    {
        return $this->attendancelogdeleteAsyncWithHttpInfo($token, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation attendancelogdeleteAsyncWithHttpInfo
     *
     * Delete an attendance log
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the attendance log to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function attendancelogdeleteAsyncWithHttpInfo($token, $id)
    {
        $returnType = '';
        $request = $this->attendancelogdeleteRequest($token, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'attendancelogdelete'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the attendance log to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function attendancelogdeleteRequest($token, $id)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling attendancelogdelete'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling attendancelogdelete'
            );
        }

        $resourcePath = '/attendancelogdelete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($id !== null) {
            if('form' === 'form' && is_array($id)) {
                foreach($id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['id'] = $id;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation attendancelogget
     *
     * Search and view details of an attendance log
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the attendance log to get. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function attendancelogget($token, $id)
    {
        $this->attendanceloggetWithHttpInfo($token, $id);
    }

    /**
     * Operation attendanceloggetWithHttpInfo
     *
     * Search and view details of an attendance log
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the attendance log to get. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function attendanceloggetWithHttpInfo($token, $id)
    {
        $request = $this->attendanceloggetRequest($token, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation attendanceloggetAsync
     *
     * Search and view details of an attendance log
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the attendance log to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function attendanceloggetAsync($token, $id)
    {
        return $this->attendanceloggetAsyncWithHttpInfo($token, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation attendanceloggetAsyncWithHttpInfo
     *
     * Search and view details of an attendance log
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the attendance log to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function attendanceloggetAsyncWithHttpInfo($token, $id)
    {
        $returnType = '';
        $request = $this->attendanceloggetRequest($token, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'attendancelogget'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the attendance log to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function attendanceloggetRequest($token, $id)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling attendancelogget'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling attendancelogget'
            );
        }

        $resourcePath = '/attendancelogget';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($id !== null) {
            if('form' === 'form' && is_array($id)) {
                foreach($id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['id'] = $id;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation attendanceloggetchangehistory
     *
     * Search and view details of an attendance log's swipe history
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the attendance log to get. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function attendanceloggetchangehistory($token, $id)
    {
        $this->attendanceloggetchangehistoryWithHttpInfo($token, $id);
    }

    /**
     * Operation attendanceloggetchangehistoryWithHttpInfo
     *
     * Search and view details of an attendance log's swipe history
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the attendance log to get. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function attendanceloggetchangehistoryWithHttpInfo($token, $id)
    {
        $request = $this->attendanceloggetchangehistoryRequest($token, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation attendanceloggetchangehistoryAsync
     *
     * Search and view details of an attendance log's swipe history
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the attendance log to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function attendanceloggetchangehistoryAsync($token, $id)
    {
        return $this->attendanceloggetchangehistoryAsyncWithHttpInfo($token, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation attendanceloggetchangehistoryAsyncWithHttpInfo
     *
     * Search and view details of an attendance log's swipe history
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the attendance log to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function attendanceloggetchangehistoryAsyncWithHttpInfo($token, $id)
    {
        $returnType = '';
        $request = $this->attendanceloggetchangehistoryRequest($token, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'attendanceloggetchangehistory'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the attendance log to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function attendanceloggetchangehistoryRequest($token, $id)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling attendanceloggetchangehistory'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling attendanceloggetchangehistory'
            );
        }

        $resourcePath = '/attendanceloggetchangehistory';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($id !== null) {
            if('form' === 'form' && is_array($id)) {
                foreach($id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['id'] = $id;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation attendanceloglist
     *
     * View a list of attendance logs
     *
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $token The authentication token. (optional)
     * @param  string $filter Filter the logs, valid values are: invalid, not-signed-in, not-signed-out, stayed-less-than-required, out-of-event, valid. (optional)
     * @param  string $userid The user ID of the user to get the logs. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function attendanceloglist($from, $count, $token = null, $filter = null, $userid = null)
    {
        $this->attendanceloglistWithHttpInfo($from, $count, $token, $filter, $userid);
    }

    /**
     * Operation attendanceloglistWithHttpInfo
     *
     * View a list of attendance logs
     *
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $token The authentication token. (optional)
     * @param  string $filter Filter the logs, valid values are: invalid, not-signed-in, not-signed-out, stayed-less-than-required, out-of-event, valid. (optional)
     * @param  string $userid The user ID of the user to get the logs. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function attendanceloglistWithHttpInfo($from, $count, $token = null, $filter = null, $userid = null)
    {
        $request = $this->attendanceloglistRequest($from, $count, $token, $filter, $userid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation attendanceloglistAsync
     *
     * View a list of attendance logs
     *
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $token The authentication token. (optional)
     * @param  string $filter Filter the logs, valid values are: invalid, not-signed-in, not-signed-out, stayed-less-than-required, out-of-event, valid. (optional)
     * @param  string $userid The user ID of the user to get the logs. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function attendanceloglistAsync($from, $count, $token = null, $filter = null, $userid = null)
    {
        return $this->attendanceloglistAsyncWithHttpInfo($from, $count, $token, $filter, $userid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation attendanceloglistAsyncWithHttpInfo
     *
     * View a list of attendance logs
     *
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $token The authentication token. (optional)
     * @param  string $filter Filter the logs, valid values are: invalid, not-signed-in, not-signed-out, stayed-less-than-required, out-of-event, valid. (optional)
     * @param  string $userid The user ID of the user to get the logs. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function attendanceloglistAsyncWithHttpInfo($from, $count, $token = null, $filter = null, $userid = null)
    {
        $returnType = '';
        $request = $this->attendanceloglistRequest($from, $count, $token, $filter, $userid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'attendanceloglist'
     *
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $token The authentication token. (optional)
     * @param  string $filter Filter the logs, valid values are: invalid, not-signed-in, not-signed-out, stayed-less-than-required, out-of-event, valid. (optional)
     * @param  string $userid The user ID of the user to get the logs. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function attendanceloglistRequest($from, $count, $token = null, $filter = null, $userid = null)
    {
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling attendanceloglist'
            );
        }
        // verify the required parameter 'count' is set
        if ($count === null || (is_array($count) && count($count) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $count when calling attendanceloglist'
            );
        }

        $resourcePath = '/attendanceloglist';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }
        // query params
        if ($count !== null) {
            if('form' === 'form' && is_array($count)) {
                foreach($count as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['count'] = $count;
            }
        }
        // query params
        if ($filter !== null) {
            if('form' === 'form' && is_array($filter)) {
                foreach($filter as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['filter'] = $filter;
            }
        }
        // query params
        if ($userid !== null) {
            if('form' === 'form' && is_array($userid)) {
                foreach($userid as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['userid'] = $userid;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation attendanceloglistmine
     *
     * Gets the attendance logs of the current user
     *
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $token The authentication token. (optional)
     * @param  string $filter Filter the logs, valid values are: invalid, not-signed-in, not-signed-out, stayed-less-than-required, out-of-event, valid. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function attendanceloglistmine($from, $count, $token = null, $filter = null)
    {
        $this->attendanceloglistmineWithHttpInfo($from, $count, $token, $filter);
    }

    /**
     * Operation attendanceloglistmineWithHttpInfo
     *
     * Gets the attendance logs of the current user
     *
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $token The authentication token. (optional)
     * @param  string $filter Filter the logs, valid values are: invalid, not-signed-in, not-signed-out, stayed-less-than-required, out-of-event, valid. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function attendanceloglistmineWithHttpInfo($from, $count, $token = null, $filter = null)
    {
        $request = $this->attendanceloglistmineRequest($from, $count, $token, $filter);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation attendanceloglistmineAsync
     *
     * Gets the attendance logs of the current user
     *
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $token The authentication token. (optional)
     * @param  string $filter Filter the logs, valid values are: invalid, not-signed-in, not-signed-out, stayed-less-than-required, out-of-event, valid. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function attendanceloglistmineAsync($from, $count, $token = null, $filter = null)
    {
        return $this->attendanceloglistmineAsyncWithHttpInfo($from, $count, $token, $filter)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation attendanceloglistmineAsyncWithHttpInfo
     *
     * Gets the attendance logs of the current user
     *
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $token The authentication token. (optional)
     * @param  string $filter Filter the logs, valid values are: invalid, not-signed-in, not-signed-out, stayed-less-than-required, out-of-event, valid. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function attendanceloglistmineAsyncWithHttpInfo($from, $count, $token = null, $filter = null)
    {
        $returnType = '';
        $request = $this->attendanceloglistmineRequest($from, $count, $token, $filter);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'attendanceloglistmine'
     *
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $token The authentication token. (optional)
     * @param  string $filter Filter the logs, valid values are: invalid, not-signed-in, not-signed-out, stayed-less-than-required, out-of-event, valid. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function attendanceloglistmineRequest($from, $count, $token = null, $filter = null)
    {
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling attendanceloglistmine'
            );
        }
        // verify the required parameter 'count' is set
        if ($count === null || (is_array($count) && count($count) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $count when calling attendanceloglistmine'
            );
        }

        $resourcePath = '/attendanceloglistmine';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }
        // query params
        if ($count !== null) {
            if('form' === 'form' && is_array($count)) {
                foreach($count as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['count'] = $count;
            }
        }
        // query params
        if ($filter !== null) {
            if('form' === 'form' && is_array($filter)) {
                foreach($filter as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['filter'] = $filter;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation attendancelogsave
     *
     * Create or edit an attendance log
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function attendancelogsave($unknown_base_type = null)
    {
        $this->attendancelogsaveWithHttpInfo($unknown_base_type);
    }

    /**
     * Operation attendancelogsaveWithHttpInfo
     *
     * Create or edit an attendance log
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function attendancelogsaveWithHttpInfo($unknown_base_type = null)
    {
        $request = $this->attendancelogsaveRequest($unknown_base_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation attendancelogsaveAsync
     *
     * Create or edit an attendance log
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function attendancelogsaveAsync($unknown_base_type = null)
    {
        return $this->attendancelogsaveAsyncWithHttpInfo($unknown_base_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation attendancelogsaveAsyncWithHttpInfo
     *
     * Create or edit an attendance log
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function attendancelogsaveAsyncWithHttpInfo($unknown_base_type = null)
    {
        $returnType = '';
        $request = $this->attendancelogsaveRequest($unknown_base_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'attendancelogsave'
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function attendancelogsaveRequest($unknown_base_type = null)
    {

        $resourcePath = '/attendancelogsave';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($unknown_base_type)) {
            $_tempBody = $unknown_base_type;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation attendancelogsignout
     *
     * Sign out an attendance log
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the attendance log to sign-out. (optional)
     * @param  string $location The id of the location to filter the users to sign out. (optional)
     * @param  string $event The id of the event to filter the users to sign out. (optional)
     * @param  \DateTime $datetime Specifies the date and time when the specified logs have to be signed out. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function attendancelogsignout($token, $id = null, $location = null, $event = null, $datetime = null)
    {
        $this->attendancelogsignoutWithHttpInfo($token, $id, $location, $event, $datetime);
    }

    /**
     * Operation attendancelogsignoutWithHttpInfo
     *
     * Sign out an attendance log
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the attendance log to sign-out. (optional)
     * @param  string $location The id of the location to filter the users to sign out. (optional)
     * @param  string $event The id of the event to filter the users to sign out. (optional)
     * @param  \DateTime $datetime Specifies the date and time when the specified logs have to be signed out. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function attendancelogsignoutWithHttpInfo($token, $id = null, $location = null, $event = null, $datetime = null)
    {
        $request = $this->attendancelogsignoutRequest($token, $id, $location, $event, $datetime);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation attendancelogsignoutAsync
     *
     * Sign out an attendance log
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the attendance log to sign-out. (optional)
     * @param  string $location The id of the location to filter the users to sign out. (optional)
     * @param  string $event The id of the event to filter the users to sign out. (optional)
     * @param  \DateTime $datetime Specifies the date and time when the specified logs have to be signed out. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function attendancelogsignoutAsync($token, $id = null, $location = null, $event = null, $datetime = null)
    {
        return $this->attendancelogsignoutAsyncWithHttpInfo($token, $id, $location, $event, $datetime)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation attendancelogsignoutAsyncWithHttpInfo
     *
     * Sign out an attendance log
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the attendance log to sign-out. (optional)
     * @param  string $location The id of the location to filter the users to sign out. (optional)
     * @param  string $event The id of the event to filter the users to sign out. (optional)
     * @param  \DateTime $datetime Specifies the date and time when the specified logs have to be signed out. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function attendancelogsignoutAsyncWithHttpInfo($token, $id = null, $location = null, $event = null, $datetime = null)
    {
        $returnType = '';
        $request = $this->attendancelogsignoutRequest($token, $id, $location, $event, $datetime);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'attendancelogsignout'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the attendance log to sign-out. (optional)
     * @param  string $location The id of the location to filter the users to sign out. (optional)
     * @param  string $event The id of the event to filter the users to sign out. (optional)
     * @param  \DateTime $datetime Specifies the date and time when the specified logs have to be signed out. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function attendancelogsignoutRequest($token, $id = null, $location = null, $event = null, $datetime = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling attendancelogsignout'
            );
        }

        $resourcePath = '/attendancelogsignout';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($id !== null) {
            if('form' === 'form' && is_array($id)) {
                foreach($id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['id'] = $id;
            }
        }
        // query params
        if ($location !== null) {
            if('form' === 'form' && is_array($location)) {
                foreach($location as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['location'] = $location;
            }
        }
        // query params
        if ($event !== null) {
            if('form' === 'form' && is_array($event)) {
                foreach($event as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['event'] = $event;
            }
        }
        // query params
        if ($datetime !== null) {
            if('form' === 'form' && is_array($datetime)) {
                foreach($datetime as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['datetime'] = $datetime;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation attendancelogwhosin
     *
     * View who's in a location
     *
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $token The authentication token. (optional)
     * @param  string $location The id of the location to search for users that are in. (optional)
     * @param  string $event The id of the event to search for users that are in. (optional)
     * @param  string $sorting Field to sort by. Either first-name, last-name or sign-in-time. (optional)
     * @param  string $roles The comma-separated list of ids of the roles to search for users that are in. (optional)
     * @param  int $photosize The size in pixels of the photo URLs returned. Defaults to 40. If the size specified is not available, a similar one will be returned. (optional)
     * @param  string $extensions A JSON array containing the extension filters (i.e [{name: &#39;nametofilter&#39;, value: &#39;valuetofilter&#39;}]). (optional)
     * @param  bool $export True to export the results as CSV (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function attendancelogwhosin($from, $count, $token = null, $location = null, $event = null, $sorting = null, $roles = null, $photosize = null, $extensions = null, $export = null)
    {
        $this->attendancelogwhosinWithHttpInfo($from, $count, $token, $location, $event, $sorting, $roles, $photosize, $extensions, $export);
    }

    /**
     * Operation attendancelogwhosinWithHttpInfo
     *
     * View who's in a location
     *
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $token The authentication token. (optional)
     * @param  string $location The id of the location to search for users that are in. (optional)
     * @param  string $event The id of the event to search for users that are in. (optional)
     * @param  string $sorting Field to sort by. Either first-name, last-name or sign-in-time. (optional)
     * @param  string $roles The comma-separated list of ids of the roles to search for users that are in. (optional)
     * @param  int $photosize The size in pixels of the photo URLs returned. Defaults to 40. If the size specified is not available, a similar one will be returned. (optional)
     * @param  string $extensions A JSON array containing the extension filters (i.e [{name: &#39;nametofilter&#39;, value: &#39;valuetofilter&#39;}]). (optional)
     * @param  bool $export True to export the results as CSV (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function attendancelogwhosinWithHttpInfo($from, $count, $token = null, $location = null, $event = null, $sorting = null, $roles = null, $photosize = null, $extensions = null, $export = null)
    {
        $request = $this->attendancelogwhosinRequest($from, $count, $token, $location, $event, $sorting, $roles, $photosize, $extensions, $export);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation attendancelogwhosinAsync
     *
     * View who's in a location
     *
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $token The authentication token. (optional)
     * @param  string $location The id of the location to search for users that are in. (optional)
     * @param  string $event The id of the event to search for users that are in. (optional)
     * @param  string $sorting Field to sort by. Either first-name, last-name or sign-in-time. (optional)
     * @param  string $roles The comma-separated list of ids of the roles to search for users that are in. (optional)
     * @param  int $photosize The size in pixels of the photo URLs returned. Defaults to 40. If the size specified is not available, a similar one will be returned. (optional)
     * @param  string $extensions A JSON array containing the extension filters (i.e [{name: &#39;nametofilter&#39;, value: &#39;valuetofilter&#39;}]). (optional)
     * @param  bool $export True to export the results as CSV (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function attendancelogwhosinAsync($from, $count, $token = null, $location = null, $event = null, $sorting = null, $roles = null, $photosize = null, $extensions = null, $export = null)
    {
        return $this->attendancelogwhosinAsyncWithHttpInfo($from, $count, $token, $location, $event, $sorting, $roles, $photosize, $extensions, $export)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation attendancelogwhosinAsyncWithHttpInfo
     *
     * View who's in a location
     *
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $token The authentication token. (optional)
     * @param  string $location The id of the location to search for users that are in. (optional)
     * @param  string $event The id of the event to search for users that are in. (optional)
     * @param  string $sorting Field to sort by. Either first-name, last-name or sign-in-time. (optional)
     * @param  string $roles The comma-separated list of ids of the roles to search for users that are in. (optional)
     * @param  int $photosize The size in pixels of the photo URLs returned. Defaults to 40. If the size specified is not available, a similar one will be returned. (optional)
     * @param  string $extensions A JSON array containing the extension filters (i.e [{name: &#39;nametofilter&#39;, value: &#39;valuetofilter&#39;}]). (optional)
     * @param  bool $export True to export the results as CSV (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function attendancelogwhosinAsyncWithHttpInfo($from, $count, $token = null, $location = null, $event = null, $sorting = null, $roles = null, $photosize = null, $extensions = null, $export = null)
    {
        $returnType = '';
        $request = $this->attendancelogwhosinRequest($from, $count, $token, $location, $event, $sorting, $roles, $photosize, $extensions, $export);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'attendancelogwhosin'
     *
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $token The authentication token. (optional)
     * @param  string $location The id of the location to search for users that are in. (optional)
     * @param  string $event The id of the event to search for users that are in. (optional)
     * @param  string $sorting Field to sort by. Either first-name, last-name or sign-in-time. (optional)
     * @param  string $roles The comma-separated list of ids of the roles to search for users that are in. (optional)
     * @param  int $photosize The size in pixels of the photo URLs returned. Defaults to 40. If the size specified is not available, a similar one will be returned. (optional)
     * @param  string $extensions A JSON array containing the extension filters (i.e [{name: &#39;nametofilter&#39;, value: &#39;valuetofilter&#39;}]). (optional)
     * @param  bool $export True to export the results as CSV (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function attendancelogwhosinRequest($from, $count, $token = null, $location = null, $event = null, $sorting = null, $roles = null, $photosize = null, $extensions = null, $export = null)
    {
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling attendancelogwhosin'
            );
        }
        // verify the required parameter 'count' is set
        if ($count === null || (is_array($count) && count($count) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $count when calling attendancelogwhosin'
            );
        }

        $resourcePath = '/attendancelogwhosin';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }
        // query params
        if ($count !== null) {
            if('form' === 'form' && is_array($count)) {
                foreach($count as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['count'] = $count;
            }
        }
        // query params
        if ($location !== null) {
            if('form' === 'form' && is_array($location)) {
                foreach($location as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['location'] = $location;
            }
        }
        // query params
        if ($event !== null) {
            if('form' === 'form' && is_array($event)) {
                foreach($event as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['event'] = $event;
            }
        }
        // query params
        if ($sorting !== null) {
            if('form' === 'form' && is_array($sorting)) {
                foreach($sorting as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['sorting'] = $sorting;
            }
        }
        // query params
        if ($roles !== null) {
            if('form' === 'form' && is_array($roles)) {
                foreach($roles as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['roles'] = $roles;
            }
        }
        // query params
        if ($photosize !== null) {
            if('form' === 'form' && is_array($photosize)) {
                foreach($photosize as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['photosize'] = $photosize;
            }
        }
        // query params
        if ($extensions !== null) {
            if('form' === 'form' && is_array($extensions)) {
                foreach($extensions as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['extensions'] = $extensions;
            }
        }
        // query params
        if ($export !== null) {
            if('form' === 'form' && is_array($export)) {
                foreach($export as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['export'] = $export;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation bgjobgetstatus
     *
     * Get background job status
     *
     * @param  string $token The authentication token. (required)
     * @param  string $jobid The ID of the job to get the status. 10 most recent will be returned if not specified. (optional)
     * @param  string $jobtype The job type to filter by. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function bgjobgetstatus($token, $jobid = null, $jobtype = null)
    {
        $this->bgjobgetstatusWithHttpInfo($token, $jobid, $jobtype);
    }

    /**
     * Operation bgjobgetstatusWithHttpInfo
     *
     * Get background job status
     *
     * @param  string $token The authentication token. (required)
     * @param  string $jobid The ID of the job to get the status. 10 most recent will be returned if not specified. (optional)
     * @param  string $jobtype The job type to filter by. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function bgjobgetstatusWithHttpInfo($token, $jobid = null, $jobtype = null)
    {
        $request = $this->bgjobgetstatusRequest($token, $jobid, $jobtype);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation bgjobgetstatusAsync
     *
     * Get background job status
     *
     * @param  string $token The authentication token. (required)
     * @param  string $jobid The ID of the job to get the status. 10 most recent will be returned if not specified. (optional)
     * @param  string $jobtype The job type to filter by. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function bgjobgetstatusAsync($token, $jobid = null, $jobtype = null)
    {
        return $this->bgjobgetstatusAsyncWithHttpInfo($token, $jobid, $jobtype)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation bgjobgetstatusAsyncWithHttpInfo
     *
     * Get background job status
     *
     * @param  string $token The authentication token. (required)
     * @param  string $jobid The ID of the job to get the status. 10 most recent will be returned if not specified. (optional)
     * @param  string $jobtype The job type to filter by. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function bgjobgetstatusAsyncWithHttpInfo($token, $jobid = null, $jobtype = null)
    {
        $returnType = '';
        $request = $this->bgjobgetstatusRequest($token, $jobid, $jobtype);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'bgjobgetstatus'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $jobid The ID of the job to get the status. 10 most recent will be returned if not specified. (optional)
     * @param  string $jobtype The job type to filter by. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function bgjobgetstatusRequest($token, $jobid = null, $jobtype = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling bgjobgetstatus'
            );
        }

        $resourcePath = '/bgjobgetstatus';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($jobid !== null) {
            if('form' === 'form' && is_array($jobid)) {
                foreach($jobid as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['jobid'] = $jobid;
            }
        }
        // query params
        if ($jobtype !== null) {
            if('form' === 'form' && is_array($jobtype)) {
                foreach($jobtype as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['jobtype'] = $jobtype;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation captchagetchallenge
     *
     * Gets a captcha challenge that the user must complete to do certain requests.
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function captchagetchallenge()
    {
        $this->captchagetchallengeWithHttpInfo();
    }

    /**
     * Operation captchagetchallengeWithHttpInfo
     *
     * Gets a captcha challenge that the user must complete to do certain requests.
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function captchagetchallengeWithHttpInfo()
    {
        $request = $this->captchagetchallengeRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation captchagetchallengeAsync
     *
     * Gets a captcha challenge that the user must complete to do certain requests.
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function captchagetchallengeAsync()
    {
        return $this->captchagetchallengeAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation captchagetchallengeAsyncWithHttpInfo
     *
     * Gets a captcha challenge that the user must complete to do certain requests.
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function captchagetchallengeAsyncWithHttpInfo()
    {
        $returnType = '';
        $request = $this->captchagetchallengeRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'captchagetchallenge'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function captchagetchallengeRequest()
    {

        $resourcePath = '/captchagetchallenge';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation captchagetimage
     *
     * Gets a captcha image that the user must complete to do certain requests.
     *
     * @param  string $captchatoken The captcha token or ID returned by the captcha.getchallenge action (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function captchagetimage($captchatoken)
    {
        $this->captchagetimageWithHttpInfo($captchatoken);
    }

    /**
     * Operation captchagetimageWithHttpInfo
     *
     * Gets a captcha image that the user must complete to do certain requests.
     *
     * @param  string $captchatoken The captcha token or ID returned by the captcha.getchallenge action (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function captchagetimageWithHttpInfo($captchatoken)
    {
        $request = $this->captchagetimageRequest($captchatoken);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation captchagetimageAsync
     *
     * Gets a captcha image that the user must complete to do certain requests.
     *
     * @param  string $captchatoken The captcha token or ID returned by the captcha.getchallenge action (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function captchagetimageAsync($captchatoken)
    {
        return $this->captchagetimageAsyncWithHttpInfo($captchatoken)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation captchagetimageAsyncWithHttpInfo
     *
     * Gets a captcha image that the user must complete to do certain requests.
     *
     * @param  string $captchatoken The captcha token or ID returned by the captcha.getchallenge action (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function captchagetimageAsyncWithHttpInfo($captchatoken)
    {
        $returnType = '';
        $request = $this->captchagetimageRequest($captchatoken);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'captchagetimage'
     *
     * @param  string $captchatoken The captcha token or ID returned by the captcha.getchallenge action (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function captchagetimageRequest($captchatoken)
    {
        // verify the required parameter 'captchatoken' is set
        if ($captchatoken === null || (is_array($captchatoken) && count($captchatoken) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $captchatoken when calling captchagetimage'
            );
        }

        $resourcePath = '/captchagetimage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($captchatoken !== null) {
            if('form' === 'form' && is_array($captchatoken)) {
                foreach($captchatoken as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['captchatoken'] = $captchatoken;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation changelog
     *
     * Get the application change log
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function changelog($token)
    {
        $this->changelogWithHttpInfo($token);
    }

    /**
     * Operation changelogWithHttpInfo
     *
     * Get the application change log
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function changelogWithHttpInfo($token)
    {
        $request = $this->changelogRequest($token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation changelogAsync
     *
     * Get the application change log
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function changelogAsync($token)
    {
        return $this->changelogAsyncWithHttpInfo($token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation changelogAsyncWithHttpInfo
     *
     * Get the application change log
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function changelogAsyncWithHttpInfo($token)
    {
        $returnType = '';
        $request = $this->changelogRequest($token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'changelog'
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function changelogRequest($token)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling changelog'
            );
        }

        $resourcePath = '/changelog';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clientget
     *
     * Get client
     *
     * @param  string $token The authentication token. (required)
     * @param  string $client The unique id of the client. (required)
     * @param  string $clientname The custom name of the client. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function clientget($token, $client, $clientname = null)
    {
        $this->clientgetWithHttpInfo($token, $client, $clientname);
    }

    /**
     * Operation clientgetWithHttpInfo
     *
     * Get client
     *
     * @param  string $token The authentication token. (required)
     * @param  string $client The unique id of the client. (required)
     * @param  string $clientname The custom name of the client. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function clientgetWithHttpInfo($token, $client, $clientname = null)
    {
        $request = $this->clientgetRequest($token, $client, $clientname);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation clientgetAsync
     *
     * Get client
     *
     * @param  string $token The authentication token. (required)
     * @param  string $client The unique id of the client. (required)
     * @param  string $clientname The custom name of the client. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientgetAsync($token, $client, $clientname = null)
    {
        return $this->clientgetAsyncWithHttpInfo($token, $client, $clientname)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clientgetAsyncWithHttpInfo
     *
     * Get client
     *
     * @param  string $token The authentication token. (required)
     * @param  string $client The unique id of the client. (required)
     * @param  string $clientname The custom name of the client. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientgetAsyncWithHttpInfo($token, $client, $clientname = null)
    {
        $returnType = '';
        $request = $this->clientgetRequest($token, $client, $clientname);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clientget'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $client The unique id of the client. (required)
     * @param  string $clientname The custom name of the client. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function clientgetRequest($token, $client, $clientname = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling clientget'
            );
        }
        // verify the required parameter 'client' is set
        if ($client === null || (is_array($client) && count($client) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client when calling clientget'
            );
        }

        $resourcePath = '/clientget';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($client !== null) {
            if('form' === 'form' && is_array($client)) {
                foreach($client as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['client'] = $client;
            }
        }
        // query params
        if ($clientname !== null) {
            if('form' === 'form' && is_array($clientname)) {
                foreach($clientname as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['clientname'] = $clientname;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clientlist
     *
     * Gets the clients of the specified conference
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function clientlist($token, $from, $count)
    {
        $this->clientlistWithHttpInfo($token, $from, $count);
    }

    /**
     * Operation clientlistWithHttpInfo
     *
     * Gets the clients of the specified conference
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function clientlistWithHttpInfo($token, $from, $count)
    {
        $request = $this->clientlistRequest($token, $from, $count);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation clientlistAsync
     *
     * Gets the clients of the specified conference
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientlistAsync($token, $from, $count)
    {
        return $this->clientlistAsyncWithHttpInfo($token, $from, $count)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clientlistAsyncWithHttpInfo
     *
     * Gets the clients of the specified conference
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientlistAsyncWithHttpInfo($token, $from, $count)
    {
        $returnType = '';
        $request = $this->clientlistRequest($token, $from, $count);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clientlist'
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function clientlistRequest($token, $from, $count)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling clientlist'
            );
        }
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling clientlist'
            );
        }
        // verify the required parameter 'count' is set
        if ($count === null || (is_array($count) && count($count) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $count when calling clientlist'
            );
        }

        $resourcePath = '/clientlist';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }
        // query params
        if ($count !== null) {
            if('form' === 'form' && is_array($count)) {
                foreach($count as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['count'] = $count;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clientsave
     *
     * Saves a client
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function clientsave($unknown_base_type = null)
    {
        $this->clientsaveWithHttpInfo($unknown_base_type);
    }

    /**
     * Operation clientsaveWithHttpInfo
     *
     * Saves a client
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function clientsaveWithHttpInfo($unknown_base_type = null)
    {
        $request = $this->clientsaveRequest($unknown_base_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation clientsaveAsync
     *
     * Saves a client
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientsaveAsync($unknown_base_type = null)
    {
        return $this->clientsaveAsyncWithHttpInfo($unknown_base_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clientsaveAsyncWithHttpInfo
     *
     * Saves a client
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientsaveAsyncWithHttpInfo($unknown_base_type = null)
    {
        $returnType = '';
        $request = $this->clientsaveRequest($unknown_base_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clientsave'
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function clientsaveRequest($unknown_base_type = null)
    {

        $resourcePath = '/clientsave';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($unknown_base_type)) {
            $_tempBody = $unknown_base_type;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clientsendmessage
     *
     * Send a message to a client
     *
     * @param  string $token The authentication token. (required)
     * @param  string $uniqueclientid The unique id of the client. (required)
     * @param  string $message The body of the message to send. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function clientsendmessage($token, $uniqueclientid, $message)
    {
        $this->clientsendmessageWithHttpInfo($token, $uniqueclientid, $message);
    }

    /**
     * Operation clientsendmessageWithHttpInfo
     *
     * Send a message to a client
     *
     * @param  string $token The authentication token. (required)
     * @param  string $uniqueclientid The unique id of the client. (required)
     * @param  string $message The body of the message to send. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function clientsendmessageWithHttpInfo($token, $uniqueclientid, $message)
    {
        $request = $this->clientsendmessageRequest($token, $uniqueclientid, $message);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation clientsendmessageAsync
     *
     * Send a message to a client
     *
     * @param  string $token The authentication token. (required)
     * @param  string $uniqueclientid The unique id of the client. (required)
     * @param  string $message The body of the message to send. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientsendmessageAsync($token, $uniqueclientid, $message)
    {
        return $this->clientsendmessageAsyncWithHttpInfo($token, $uniqueclientid, $message)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clientsendmessageAsyncWithHttpInfo
     *
     * Send a message to a client
     *
     * @param  string $token The authentication token. (required)
     * @param  string $uniqueclientid The unique id of the client. (required)
     * @param  string $message The body of the message to send. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientsendmessageAsyncWithHttpInfo($token, $uniqueclientid, $message)
    {
        $returnType = '';
        $request = $this->clientsendmessageRequest($token, $uniqueclientid, $message);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clientsendmessage'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $uniqueclientid The unique id of the client. (required)
     * @param  string $message The body of the message to send. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function clientsendmessageRequest($token, $uniqueclientid, $message)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling clientsendmessage'
            );
        }
        // verify the required parameter 'uniqueclientid' is set
        if ($uniqueclientid === null || (is_array($uniqueclientid) && count($uniqueclientid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uniqueclientid when calling clientsendmessage'
            );
        }
        // verify the required parameter 'message' is set
        if ($message === null || (is_array($message) && count($message) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $message when calling clientsendmessage'
            );
        }

        $resourcePath = '/clientsendmessage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($uniqueclientid !== null) {
            if('form' === 'form' && is_array($uniqueclientid)) {
                foreach($uniqueclientid as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['uniqueclientid'] = $uniqueclientid;
            }
        }
        // query params
        if ($message !== null) {
            if('form' === 'form' && is_array($message)) {
                foreach($message as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['message'] = $message;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation creditdelete
     *
     * Delete a credit
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the credit to delete. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function creditdelete($token, $id)
    {
        $this->creditdeleteWithHttpInfo($token, $id);
    }

    /**
     * Operation creditdeleteWithHttpInfo
     *
     * Delete a credit
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the credit to delete. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function creditdeleteWithHttpInfo($token, $id)
    {
        $request = $this->creditdeleteRequest($token, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation creditdeleteAsync
     *
     * Delete a credit
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the credit to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function creditdeleteAsync($token, $id)
    {
        return $this->creditdeleteAsyncWithHttpInfo($token, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation creditdeleteAsyncWithHttpInfo
     *
     * Delete a credit
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the credit to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function creditdeleteAsyncWithHttpInfo($token, $id)
    {
        $returnType = '';
        $request = $this->creditdeleteRequest($token, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'creditdelete'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the credit to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function creditdeleteRequest($token, $id)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling creditdelete'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling creditdelete'
            );
        }

        $resourcePath = '/creditdelete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($id !== null) {
            if('form' === 'form' && is_array($id)) {
                foreach($id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['id'] = $id;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation creditdiscountmethods
     *
     * Gets the valid discount methods.
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function creditdiscountmethods()
    {
        $this->creditdiscountmethodsWithHttpInfo();
    }

    /**
     * Operation creditdiscountmethodsWithHttpInfo
     *
     * Gets the valid discount methods.
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function creditdiscountmethodsWithHttpInfo()
    {
        $request = $this->creditdiscountmethodsRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation creditdiscountmethodsAsync
     *
     * Gets the valid discount methods.
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function creditdiscountmethodsAsync()
    {
        return $this->creditdiscountmethodsAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation creditdiscountmethodsAsyncWithHttpInfo
     *
     * Gets the valid discount methods.
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function creditdiscountmethodsAsyncWithHttpInfo()
    {
        $returnType = '';
        $request = $this->creditdiscountmethodsRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'creditdiscountmethods'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function creditdiscountmethodsRequest()
    {

        $resourcePath = '/creditdiscountmethods';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation creditget
     *
     * View details of assigned credit
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the credit to get. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function creditget($token, $id)
    {
        $this->creditgetWithHttpInfo($token, $id);
    }

    /**
     * Operation creditgetWithHttpInfo
     *
     * View details of assigned credit
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the credit to get. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function creditgetWithHttpInfo($token, $id)
    {
        $request = $this->creditgetRequest($token, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation creditgetAsync
     *
     * View details of assigned credit
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the credit to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function creditgetAsync($token, $id)
    {
        return $this->creditgetAsyncWithHttpInfo($token, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation creditgetAsyncWithHttpInfo
     *
     * View details of assigned credit
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the credit to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function creditgetAsyncWithHttpInfo($token, $id)
    {
        $returnType = '';
        $request = $this->creditgetRequest($token, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'creditget'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the credit to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function creditgetRequest($token, $id)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling creditget'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling creditget'
            );
        }

        $resourcePath = '/creditget';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($id !== null) {
            if('form' === 'form' && is_array($id)) {
                foreach($id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['id'] = $id;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation creditgetuserbalance
     *
     * Get the total amount of credits of the specified user
     *
     * @param  string $token The authentication token. (required)
     * @param  string $user The id of the user whose balance has to be returned. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function creditgetuserbalance($token, $user)
    {
        $this->creditgetuserbalanceWithHttpInfo($token, $user);
    }

    /**
     * Operation creditgetuserbalanceWithHttpInfo
     *
     * Get the total amount of credits of the specified user
     *
     * @param  string $token The authentication token. (required)
     * @param  string $user The id of the user whose balance has to be returned. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function creditgetuserbalanceWithHttpInfo($token, $user)
    {
        $request = $this->creditgetuserbalanceRequest($token, $user);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation creditgetuserbalanceAsync
     *
     * Get the total amount of credits of the specified user
     *
     * @param  string $token The authentication token. (required)
     * @param  string $user The id of the user whose balance has to be returned. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function creditgetuserbalanceAsync($token, $user)
    {
        return $this->creditgetuserbalanceAsyncWithHttpInfo($token, $user)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation creditgetuserbalanceAsyncWithHttpInfo
     *
     * Get the total amount of credits of the specified user
     *
     * @param  string $token The authentication token. (required)
     * @param  string $user The id of the user whose balance has to be returned. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function creditgetuserbalanceAsyncWithHttpInfo($token, $user)
    {
        $returnType = '';
        $request = $this->creditgetuserbalanceRequest($token, $user);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'creditgetuserbalance'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $user The id of the user whose balance has to be returned. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function creditgetuserbalanceRequest($token, $user)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling creditgetuserbalance'
            );
        }
        // verify the required parameter 'user' is set
        if ($user === null || (is_array($user) && count($user) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user when calling creditgetuserbalance'
            );
        }

        $resourcePath = '/creditgetuserbalance';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($user !== null) {
            if('form' === 'form' && is_array($user)) {
                foreach($user as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['user'] = $user;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation creditlist
     *
     * View a list of credits for a specific user
     *
     * @param  string $token The authentication token. (required)
     * @param  string $user The id of the user. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function creditlist($token, $user, $from, $count)
    {
        $this->creditlistWithHttpInfo($token, $user, $from, $count);
    }

    /**
     * Operation creditlistWithHttpInfo
     *
     * View a list of credits for a specific user
     *
     * @param  string $token The authentication token. (required)
     * @param  string $user The id of the user. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function creditlistWithHttpInfo($token, $user, $from, $count)
    {
        $request = $this->creditlistRequest($token, $user, $from, $count);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation creditlistAsync
     *
     * View a list of credits for a specific user
     *
     * @param  string $token The authentication token. (required)
     * @param  string $user The id of the user. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function creditlistAsync($token, $user, $from, $count)
    {
        return $this->creditlistAsyncWithHttpInfo($token, $user, $from, $count)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation creditlistAsyncWithHttpInfo
     *
     * View a list of credits for a specific user
     *
     * @param  string $token The authentication token. (required)
     * @param  string $user The id of the user. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function creditlistAsyncWithHttpInfo($token, $user, $from, $count)
    {
        $returnType = '';
        $request = $this->creditlistRequest($token, $user, $from, $count);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'creditlist'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $user The id of the user. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function creditlistRequest($token, $user, $from, $count)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling creditlist'
            );
        }
        // verify the required parameter 'user' is set
        if ($user === null || (is_array($user) && count($user) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user when calling creditlist'
            );
        }
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling creditlist'
            );
        }
        // verify the required parameter 'count' is set
        if ($count === null || (is_array($count) && count($count) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $count when calling creditlist'
            );
        }

        $resourcePath = '/creditlist';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($user !== null) {
            if('form' === 'form' && is_array($user)) {
                foreach($user as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['user'] = $user;
            }
        }
        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }
        // query params
        if ($count !== null) {
            if('form' === 'form' && is_array($count)) {
                foreach($count as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['count'] = $count;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation creditlistdetails
     *
     * Gets the credit usage details
     *
     * @param  string $token The authentication token. (required)
     * @param  string $credit The id of the credit to look up for details. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function creditlistdetails($token, $credit, $from, $count)
    {
        $this->creditlistdetailsWithHttpInfo($token, $credit, $from, $count);
    }

    /**
     * Operation creditlistdetailsWithHttpInfo
     *
     * Gets the credit usage details
     *
     * @param  string $token The authentication token. (required)
     * @param  string $credit The id of the credit to look up for details. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function creditlistdetailsWithHttpInfo($token, $credit, $from, $count)
    {
        $request = $this->creditlistdetailsRequest($token, $credit, $from, $count);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation creditlistdetailsAsync
     *
     * Gets the credit usage details
     *
     * @param  string $token The authentication token. (required)
     * @param  string $credit The id of the credit to look up for details. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function creditlistdetailsAsync($token, $credit, $from, $count)
    {
        return $this->creditlistdetailsAsyncWithHttpInfo($token, $credit, $from, $count)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation creditlistdetailsAsyncWithHttpInfo
     *
     * Gets the credit usage details
     *
     * @param  string $token The authentication token. (required)
     * @param  string $credit The id of the credit to look up for details. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function creditlistdetailsAsyncWithHttpInfo($token, $credit, $from, $count)
    {
        $returnType = '';
        $request = $this->creditlistdetailsRequest($token, $credit, $from, $count);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'creditlistdetails'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $credit The id of the credit to look up for details. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function creditlistdetailsRequest($token, $credit, $from, $count)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling creditlistdetails'
            );
        }
        // verify the required parameter 'credit' is set
        if ($credit === null || (is_array($credit) && count($credit) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $credit when calling creditlistdetails'
            );
        }
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling creditlistdetails'
            );
        }
        // verify the required parameter 'count' is set
        if ($count === null || (is_array($count) && count($count) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $count when calling creditlistdetails'
            );
        }

        $resourcePath = '/creditlistdetails';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($credit !== null) {
            if('form' === 'form' && is_array($credit)) {
                foreach($credit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['credit'] = $credit;
            }
        }
        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }
        // query params
        if ($count !== null) {
            if('form' === 'form' && is_array($count)) {
                foreach($count as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['count'] = $count;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation creditlistmine
     *
     * View the list of credits of the current user
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function creditlistmine($token, $from, $count)
    {
        $this->creditlistmineWithHttpInfo($token, $from, $count);
    }

    /**
     * Operation creditlistmineWithHttpInfo
     *
     * View the list of credits of the current user
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function creditlistmineWithHttpInfo($token, $from, $count)
    {
        $request = $this->creditlistmineRequest($token, $from, $count);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation creditlistmineAsync
     *
     * View the list of credits of the current user
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function creditlistmineAsync($token, $from, $count)
    {
        return $this->creditlistmineAsyncWithHttpInfo($token, $from, $count)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation creditlistmineAsyncWithHttpInfo
     *
     * View the list of credits of the current user
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function creditlistmineAsyncWithHttpInfo($token, $from, $count)
    {
        $returnType = '';
        $request = $this->creditlistmineRequest($token, $from, $count);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'creditlistmine'
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function creditlistmineRequest($token, $from, $count)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling creditlistmine'
            );
        }
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling creditlistmine'
            );
        }
        // verify the required parameter 'count' is set
        if ($count === null || (is_array($count) && count($count) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $count when calling creditlistmine'
            );
        }

        $resourcePath = '/creditlistmine';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }
        // query params
        if ($count !== null) {
            if('form' === 'form' && is_array($count)) {
                foreach($count as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['count'] = $count;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation creditplandelete
     *
     * Deletes a credit plan
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the credit plan to delete. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function creditplandelete($token, $id)
    {
        $this->creditplandeleteWithHttpInfo($token, $id);
    }

    /**
     * Operation creditplandeleteWithHttpInfo
     *
     * Deletes a credit plan
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the credit plan to delete. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function creditplandeleteWithHttpInfo($token, $id)
    {
        $request = $this->creditplandeleteRequest($token, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation creditplandeleteAsync
     *
     * Deletes a credit plan
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the credit plan to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function creditplandeleteAsync($token, $id)
    {
        return $this->creditplandeleteAsyncWithHttpInfo($token, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation creditplandeleteAsyncWithHttpInfo
     *
     * Deletes a credit plan
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the credit plan to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function creditplandeleteAsyncWithHttpInfo($token, $id)
    {
        $returnType = '';
        $request = $this->creditplandeleteRequest($token, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'creditplandelete'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the credit plan to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function creditplandeleteRequest($token, $id)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling creditplandelete'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling creditplandelete'
            );
        }

        $resourcePath = '/creditplandelete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($id !== null) {
            if('form' === 'form' && is_array($id)) {
                foreach($id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['id'] = $id;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation creditplanget
     *
     * Gets a credit plan
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the credit plan to get. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function creditplanget($token, $id)
    {
        $this->creditplangetWithHttpInfo($token, $id);
    }

    /**
     * Operation creditplangetWithHttpInfo
     *
     * Gets a credit plan
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the credit plan to get. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function creditplangetWithHttpInfo($token, $id)
    {
        $request = $this->creditplangetRequest($token, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation creditplangetAsync
     *
     * Gets a credit plan
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the credit plan to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function creditplangetAsync($token, $id)
    {
        return $this->creditplangetAsyncWithHttpInfo($token, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation creditplangetAsyncWithHttpInfo
     *
     * Gets a credit plan
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the credit plan to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function creditplangetAsyncWithHttpInfo($token, $id)
    {
        $returnType = '';
        $request = $this->creditplangetRequest($token, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'creditplanget'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the credit plan to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function creditplangetRequest($token, $id)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling creditplanget'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling creditplanget'
            );
        }

        $resourcePath = '/creditplanget';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($id !== null) {
            if('form' === 'form' && is_array($id)) {
                foreach($id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['id'] = $id;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation creditplanlist
     *
     * Gets the credit plans available
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function creditplanlist($token, $from, $count)
    {
        $this->creditplanlistWithHttpInfo($token, $from, $count);
    }

    /**
     * Operation creditplanlistWithHttpInfo
     *
     * Gets the credit plans available
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function creditplanlistWithHttpInfo($token, $from, $count)
    {
        $request = $this->creditplanlistRequest($token, $from, $count);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation creditplanlistAsync
     *
     * Gets the credit plans available
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function creditplanlistAsync($token, $from, $count)
    {
        return $this->creditplanlistAsyncWithHttpInfo($token, $from, $count)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation creditplanlistAsyncWithHttpInfo
     *
     * Gets the credit plans available
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function creditplanlistAsyncWithHttpInfo($token, $from, $count)
    {
        $returnType = '';
        $request = $this->creditplanlistRequest($token, $from, $count);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'creditplanlist'
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function creditplanlistRequest($token, $from, $count)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling creditplanlist'
            );
        }
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling creditplanlist'
            );
        }
        // verify the required parameter 'count' is set
        if ($count === null || (is_array($count) && count($count) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $count when calling creditplanlist'
            );
        }

        $resourcePath = '/creditplanlist';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }
        // query params
        if ($count !== null) {
            if('form' === 'form' && is_array($count)) {
                foreach($count as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['count'] = $count;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation creditplansave
     *
     * Saves a credit plan
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function creditplansave($unknown_base_type = null)
    {
        $this->creditplansaveWithHttpInfo($unknown_base_type);
    }

    /**
     * Operation creditplansaveWithHttpInfo
     *
     * Saves a credit plan
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function creditplansaveWithHttpInfo($unknown_base_type = null)
    {
        $request = $this->creditplansaveRequest($unknown_base_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation creditplansaveAsync
     *
     * Saves a credit plan
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function creditplansaveAsync($unknown_base_type = null)
    {
        return $this->creditplansaveAsyncWithHttpInfo($unknown_base_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation creditplansaveAsyncWithHttpInfo
     *
     * Saves a credit plan
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function creditplansaveAsyncWithHttpInfo($unknown_base_type = null)
    {
        $returnType = '';
        $request = $this->creditplansaveRequest($unknown_base_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'creditplansave'
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function creditplansaveRequest($unknown_base_type = null)
    {

        $resourcePath = '/creditplansave';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($unknown_base_type)) {
            $_tempBody = $unknown_base_type;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation creditsave
     *
     * Create or edit credit for a user
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function creditsave($unknown_base_type = null)
    {
        $this->creditsaveWithHttpInfo($unknown_base_type);
    }

    /**
     * Operation creditsaveWithHttpInfo
     *
     * Create or edit credit for a user
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function creditsaveWithHttpInfo($unknown_base_type = null)
    {
        $request = $this->creditsaveRequest($unknown_base_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation creditsaveAsync
     *
     * Create or edit credit for a user
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function creditsaveAsync($unknown_base_type = null)
    {
        return $this->creditsaveAsyncWithHttpInfo($unknown_base_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation creditsaveAsyncWithHttpInfo
     *
     * Create or edit credit for a user
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function creditsaveAsyncWithHttpInfo($unknown_base_type = null)
    {
        $returnType = '';
        $request = $this->creditsaveRequest($unknown_base_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'creditsave'
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function creditsaveRequest($unknown_base_type = null)
    {

        $resourcePath = '/creditsave';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($unknown_base_type)) {
            $_tempBody = $unknown_base_type;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation creditsavedetails
     *
     * Create or edit credit details
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function creditsavedetails($unknown_base_type = null)
    {
        $this->creditsavedetailsWithHttpInfo($unknown_base_type);
    }

    /**
     * Operation creditsavedetailsWithHttpInfo
     *
     * Create or edit credit details
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function creditsavedetailsWithHttpInfo($unknown_base_type = null)
    {
        $request = $this->creditsavedetailsRequest($unknown_base_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation creditsavedetailsAsync
     *
     * Create or edit credit details
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function creditsavedetailsAsync($unknown_base_type = null)
    {
        return $this->creditsavedetailsAsyncWithHttpInfo($unknown_base_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation creditsavedetailsAsyncWithHttpInfo
     *
     * Create or edit credit details
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function creditsavedetailsAsyncWithHttpInfo($unknown_base_type = null)
    {
        $returnType = '';
        $request = $this->creditsavedetailsRequest($unknown_base_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'creditsavedetails'
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function creditsavedetailsRequest($unknown_base_type = null)
    {

        $resourcePath = '/creditsavedetails';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($unknown_base_type)) {
            $_tempBody = $unknown_base_type;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation doc
     *
     * Get the documentation
     *
     * @param  bool $excludeanonymous If true it excludes the anonymous actions from the returned list. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function doc($excludeanonymous = null)
    {
        $this->docWithHttpInfo($excludeanonymous);
    }

    /**
     * Operation docWithHttpInfo
     *
     * Get the documentation
     *
     * @param  bool $excludeanonymous If true it excludes the anonymous actions from the returned list. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function docWithHttpInfo($excludeanonymous = null)
    {
        $request = $this->docRequest($excludeanonymous);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation docAsync
     *
     * Get the documentation
     *
     * @param  bool $excludeanonymous If true it excludes the anonymous actions from the returned list. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function docAsync($excludeanonymous = null)
    {
        return $this->docAsyncWithHttpInfo($excludeanonymous)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation docAsyncWithHttpInfo
     *
     * Get the documentation
     *
     * @param  bool $excludeanonymous If true it excludes the anonymous actions from the returned list. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function docAsyncWithHttpInfo($excludeanonymous = null)
    {
        $returnType = '';
        $request = $this->docRequest($excludeanonymous);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'doc'
     *
     * @param  bool $excludeanonymous If true it excludes the anonymous actions from the returned list. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function docRequest($excludeanonymous = null)
    {

        $resourcePath = '/doc';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($excludeanonymous !== null) {
            if('form' === 'form' && is_array($excludeanonymous)) {
                foreach($excludeanonymous as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['excludeanonymous'] = $excludeanonymous;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation easyloginaddbgimage
     *
     * Adds background image for the login
     *
     * @param  string $token The authentication token. (required)
     * @param  string $upload Set &#39;file&#39; as value to indicate that a file is being submitted in the body (instead of a JSON object). (required)
     * @param  string $filename The original filename, needed to process the file. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function easyloginaddbgimage($token, $upload, $filename)
    {
        $this->easyloginaddbgimageWithHttpInfo($token, $upload, $filename);
    }

    /**
     * Operation easyloginaddbgimageWithHttpInfo
     *
     * Adds background image for the login
     *
     * @param  string $token The authentication token. (required)
     * @param  string $upload Set &#39;file&#39; as value to indicate that a file is being submitted in the body (instead of a JSON object). (required)
     * @param  string $filename The original filename, needed to process the file. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function easyloginaddbgimageWithHttpInfo($token, $upload, $filename)
    {
        $request = $this->easyloginaddbgimageRequest($token, $upload, $filename);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation easyloginaddbgimageAsync
     *
     * Adds background image for the login
     *
     * @param  string $token The authentication token. (required)
     * @param  string $upload Set &#39;file&#39; as value to indicate that a file is being submitted in the body (instead of a JSON object). (required)
     * @param  string $filename The original filename, needed to process the file. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function easyloginaddbgimageAsync($token, $upload, $filename)
    {
        return $this->easyloginaddbgimageAsyncWithHttpInfo($token, $upload, $filename)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation easyloginaddbgimageAsyncWithHttpInfo
     *
     * Adds background image for the login
     *
     * @param  string $token The authentication token. (required)
     * @param  string $upload Set &#39;file&#39; as value to indicate that a file is being submitted in the body (instead of a JSON object). (required)
     * @param  string $filename The original filename, needed to process the file. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function easyloginaddbgimageAsyncWithHttpInfo($token, $upload, $filename)
    {
        $returnType = '';
        $request = $this->easyloginaddbgimageRequest($token, $upload, $filename);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'easyloginaddbgimage'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $upload Set &#39;file&#39; as value to indicate that a file is being submitted in the body (instead of a JSON object). (required)
     * @param  string $filename The original filename, needed to process the file. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function easyloginaddbgimageRequest($token, $upload, $filename)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling easyloginaddbgimage'
            );
        }
        // verify the required parameter 'upload' is set
        if ($upload === null || (is_array($upload) && count($upload) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $upload when calling easyloginaddbgimage'
            );
        }
        // verify the required parameter 'filename' is set
        if ($filename === null || (is_array($filename) && count($filename) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $filename when calling easyloginaddbgimage'
            );
        }

        $resourcePath = '/easyloginaddbgimage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($upload !== null) {
            if('form' === 'form' && is_array($upload)) {
                foreach($upload as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['upload'] = $upload;
            }
        }
        // query params
        if ($filename !== null) {
            if('form' === 'form' && is_array($filename)) {
                foreach($filename as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['filename'] = $filename;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation eventdelete
     *
     * Delete a course
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the event to delete. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function eventdelete($token, $id)
    {
        $this->eventdeleteWithHttpInfo($token, $id);
    }

    /**
     * Operation eventdeleteWithHttpInfo
     *
     * Delete a course
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the event to delete. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function eventdeleteWithHttpInfo($token, $id)
    {
        $request = $this->eventdeleteRequest($token, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation eventdeleteAsync
     *
     * Delete a course
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the event to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function eventdeleteAsync($token, $id)
    {
        return $this->eventdeleteAsyncWithHttpInfo($token, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation eventdeleteAsyncWithHttpInfo
     *
     * Delete a course
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the event to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function eventdeleteAsyncWithHttpInfo($token, $id)
    {
        $returnType = '';
        $request = $this->eventdeleteRequest($token, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'eventdelete'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the event to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function eventdeleteRequest($token, $id)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling eventdelete'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling eventdelete'
            );
        }

        $resourcePath = '/eventdelete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($id !== null) {
            if('form' === 'form' && is_array($id)) {
                foreach($id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['id'] = $id;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation eventget
     *
     * Search and view details of a course
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the event to get. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function eventget($token, $id)
    {
        $this->eventgetWithHttpInfo($token, $id);
    }

    /**
     * Operation eventgetWithHttpInfo
     *
     * Search and view details of a course
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the event to get. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function eventgetWithHttpInfo($token, $id)
    {
        $request = $this->eventgetRequest($token, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation eventgetAsync
     *
     * Search and view details of a course
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the event to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function eventgetAsync($token, $id)
    {
        return $this->eventgetAsyncWithHttpInfo($token, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation eventgetAsyncWithHttpInfo
     *
     * Search and view details of a course
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the event to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function eventgetAsyncWithHttpInfo($token, $id)
    {
        $returnType = '';
        $request = $this->eventgetRequest($token, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'eventget'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the event to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function eventgetRequest($token, $id)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling eventget'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling eventget'
            );
        }

        $resourcePath = '/eventget';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($id !== null) {
            if('form' === 'form' && is_array($id)) {
                foreach($id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['id'] = $id;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation eventgetsessionsbydate
     *
     * View a list of courses by date
     *
     * @param  string $token The authentication token. (required)
     * @param  string $location The location to filter the events. (optional)
     * @param  \DateTime $date The date to filter the events. Today will be used if this parameter is omitted. (optional)
     * @param  string $type Type of event to list. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function eventgetsessionsbydate($token, $location = null, $date = null, $type = null)
    {
        $this->eventgetsessionsbydateWithHttpInfo($token, $location, $date, $type);
    }

    /**
     * Operation eventgetsessionsbydateWithHttpInfo
     *
     * View a list of courses by date
     *
     * @param  string $token The authentication token. (required)
     * @param  string $location The location to filter the events. (optional)
     * @param  \DateTime $date The date to filter the events. Today will be used if this parameter is omitted. (optional)
     * @param  string $type Type of event to list. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function eventgetsessionsbydateWithHttpInfo($token, $location = null, $date = null, $type = null)
    {
        $request = $this->eventgetsessionsbydateRequest($token, $location, $date, $type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation eventgetsessionsbydateAsync
     *
     * View a list of courses by date
     *
     * @param  string $token The authentication token. (required)
     * @param  string $location The location to filter the events. (optional)
     * @param  \DateTime $date The date to filter the events. Today will be used if this parameter is omitted. (optional)
     * @param  string $type Type of event to list. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function eventgetsessionsbydateAsync($token, $location = null, $date = null, $type = null)
    {
        return $this->eventgetsessionsbydateAsyncWithHttpInfo($token, $location, $date, $type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation eventgetsessionsbydateAsyncWithHttpInfo
     *
     * View a list of courses by date
     *
     * @param  string $token The authentication token. (required)
     * @param  string $location The location to filter the events. (optional)
     * @param  \DateTime $date The date to filter the events. Today will be used if this parameter is omitted. (optional)
     * @param  string $type Type of event to list. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function eventgetsessionsbydateAsyncWithHttpInfo($token, $location = null, $date = null, $type = null)
    {
        $returnType = '';
        $request = $this->eventgetsessionsbydateRequest($token, $location, $date, $type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'eventgetsessionsbydate'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $location The location to filter the events. (optional)
     * @param  \DateTime $date The date to filter the events. Today will be used if this parameter is omitted. (optional)
     * @param  string $type Type of event to list. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function eventgetsessionsbydateRequest($token, $location = null, $date = null, $type = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling eventgetsessionsbydate'
            );
        }

        $resourcePath = '/eventgetsessionsbydate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($location !== null) {
            if('form' === 'form' && is_array($location)) {
                foreach($location as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['location'] = $location;
            }
        }
        // query params
        if ($date !== null) {
            if('form' === 'form' && is_array($date)) {
                foreach($date as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['date'] = $date;
            }
        }
        // query params
        if ($type !== null) {
            if('form' === 'form' && is_array($type)) {
                foreach($type as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['type'] = $type;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation eventlist
     *
     * View a list of courses
     *
     * @param  string $token The authentication token. (required)
     * @param  string $from The first record to return. (required)
     * @param  string $count The max number of records to return. (required)
     * @param  bool $summaryonly True to return only the event information and not the associated schedule, dept, etc. Defaults to false. (optional)
     * @param  string $termid Id of the term to list the events. Null to list all events. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function eventlist($token, $from, $count, $summaryonly = null, $termid = null)
    {
        $this->eventlistWithHttpInfo($token, $from, $count, $summaryonly, $termid);
    }

    /**
     * Operation eventlistWithHttpInfo
     *
     * View a list of courses
     *
     * @param  string $token The authentication token. (required)
     * @param  string $from The first record to return. (required)
     * @param  string $count The max number of records to return. (required)
     * @param  bool $summaryonly True to return only the event information and not the associated schedule, dept, etc. Defaults to false. (optional)
     * @param  string $termid Id of the term to list the events. Null to list all events. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function eventlistWithHttpInfo($token, $from, $count, $summaryonly = null, $termid = null)
    {
        $request = $this->eventlistRequest($token, $from, $count, $summaryonly, $termid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation eventlistAsync
     *
     * View a list of courses
     *
     * @param  string $token The authentication token. (required)
     * @param  string $from The first record to return. (required)
     * @param  string $count The max number of records to return. (required)
     * @param  bool $summaryonly True to return only the event information and not the associated schedule, dept, etc. Defaults to false. (optional)
     * @param  string $termid Id of the term to list the events. Null to list all events. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function eventlistAsync($token, $from, $count, $summaryonly = null, $termid = null)
    {
        return $this->eventlistAsyncWithHttpInfo($token, $from, $count, $summaryonly, $termid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation eventlistAsyncWithHttpInfo
     *
     * View a list of courses
     *
     * @param  string $token The authentication token. (required)
     * @param  string $from The first record to return. (required)
     * @param  string $count The max number of records to return. (required)
     * @param  bool $summaryonly True to return only the event information and not the associated schedule, dept, etc. Defaults to false. (optional)
     * @param  string $termid Id of the term to list the events. Null to list all events. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function eventlistAsyncWithHttpInfo($token, $from, $count, $summaryonly = null, $termid = null)
    {
        $returnType = '';
        $request = $this->eventlistRequest($token, $from, $count, $summaryonly, $termid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'eventlist'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $from The first record to return. (required)
     * @param  string $count The max number of records to return. (required)
     * @param  bool $summaryonly True to return only the event information and not the associated schedule, dept, etc. Defaults to false. (optional)
     * @param  string $termid Id of the term to list the events. Null to list all events. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function eventlistRequest($token, $from, $count, $summaryonly = null, $termid = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling eventlist'
            );
        }
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling eventlist'
            );
        }
        // verify the required parameter 'count' is set
        if ($count === null || (is_array($count) && count($count) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $count when calling eventlist'
            );
        }

        $resourcePath = '/eventlist';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }
        // query params
        if ($count !== null) {
            if('form' === 'form' && is_array($count)) {
                foreach($count as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['count'] = $count;
            }
        }
        // query params
        if ($summaryonly !== null) {
            if('form' === 'form' && is_array($summaryonly)) {
                foreach($summaryonly as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['summaryonly'] = $summaryonly;
            }
        }
        // query params
        if ($termid !== null) {
            if('form' === 'form' && is_array($termid)) {
                foreach($termid as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['termid'] = $termid;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation eventsave
     *
     * Create or edit a course
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function eventsave($unknown_base_type = null)
    {
        $this->eventsaveWithHttpInfo($unknown_base_type);
    }

    /**
     * Operation eventsaveWithHttpInfo
     *
     * Create or edit a course
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function eventsaveWithHttpInfo($unknown_base_type = null)
    {
        $request = $this->eventsaveRequest($unknown_base_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation eventsaveAsync
     *
     * Create or edit a course
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function eventsaveAsync($unknown_base_type = null)
    {
        return $this->eventsaveAsyncWithHttpInfo($unknown_base_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation eventsaveAsyncWithHttpInfo
     *
     * Create or edit a course
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function eventsaveAsyncWithHttpInfo($unknown_base_type = null)
    {
        $returnType = '';
        $request = $this->eventsaveRequest($unknown_base_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'eventsave'
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function eventsaveRequest($unknown_base_type = null)
    {

        $resourcePath = '/eventsave';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($unknown_base_type)) {
            $_tempBody = $unknown_base_type;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation eventsearchgroup
     *
     * Searches for the available event groups
     *
     * @param  string $token The authentication token. (required)
     * @param  string $query Query to search event groups. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function eventsearchgroup($token, $query)
    {
        $this->eventsearchgroupWithHttpInfo($token, $query);
    }

    /**
     * Operation eventsearchgroupWithHttpInfo
     *
     * Searches for the available event groups
     *
     * @param  string $token The authentication token. (required)
     * @param  string $query Query to search event groups. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function eventsearchgroupWithHttpInfo($token, $query)
    {
        $request = $this->eventsearchgroupRequest($token, $query);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation eventsearchgroupAsync
     *
     * Searches for the available event groups
     *
     * @param  string $token The authentication token. (required)
     * @param  string $query Query to search event groups. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function eventsearchgroupAsync($token, $query)
    {
        return $this->eventsearchgroupAsyncWithHttpInfo($token, $query)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation eventsearchgroupAsyncWithHttpInfo
     *
     * Searches for the available event groups
     *
     * @param  string $token The authentication token. (required)
     * @param  string $query Query to search event groups. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function eventsearchgroupAsyncWithHttpInfo($token, $query)
    {
        $returnType = '';
        $request = $this->eventsearchgroupRequest($token, $query);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'eventsearchgroup'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $query Query to search event groups. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function eventsearchgroupRequest($token, $query)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling eventsearchgroup'
            );
        }
        // verify the required parameter 'query' is set
        if ($query === null || (is_array($query) && count($query) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query when calling eventsearchgroup'
            );
        }

        $resourcePath = '/eventsearchgroup';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($query !== null) {
            if('form' === 'form' && is_array($query)) {
                foreach($query as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['query'] = $query;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation export
     *
     * Export AccuCampus data
     *
     * @param  string $token The authentication token. (required)
     * @param  string $exporttype What to export. (required)
     * @param  string $exportformat The format of the resulting file. Valid types are CSV, HTML, XLS. (required)
     * @param  string $filters Pipe separated filters for the export, eg: aaa&#x3D;val|bbb&#x3D;val|... (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function export($token, $exporttype, $exportformat, $filters = null)
    {
        $this->exportWithHttpInfo($token, $exporttype, $exportformat, $filters);
    }

    /**
     * Operation exportWithHttpInfo
     *
     * Export AccuCampus data
     *
     * @param  string $token The authentication token. (required)
     * @param  string $exporttype What to export. (required)
     * @param  string $exportformat The format of the resulting file. Valid types are CSV, HTML, XLS. (required)
     * @param  string $filters Pipe separated filters for the export, eg: aaa&#x3D;val|bbb&#x3D;val|... (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function exportWithHttpInfo($token, $exporttype, $exportformat, $filters = null)
    {
        $request = $this->exportRequest($token, $exporttype, $exportformat, $filters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation exportAsync
     *
     * Export AccuCampus data
     *
     * @param  string $token The authentication token. (required)
     * @param  string $exporttype What to export. (required)
     * @param  string $exportformat The format of the resulting file. Valid types are CSV, HTML, XLS. (required)
     * @param  string $filters Pipe separated filters for the export, eg: aaa&#x3D;val|bbb&#x3D;val|... (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function exportAsync($token, $exporttype, $exportformat, $filters = null)
    {
        return $this->exportAsyncWithHttpInfo($token, $exporttype, $exportformat, $filters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation exportAsyncWithHttpInfo
     *
     * Export AccuCampus data
     *
     * @param  string $token The authentication token. (required)
     * @param  string $exporttype What to export. (required)
     * @param  string $exportformat The format of the resulting file. Valid types are CSV, HTML, XLS. (required)
     * @param  string $filters Pipe separated filters for the export, eg: aaa&#x3D;val|bbb&#x3D;val|... (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function exportAsyncWithHttpInfo($token, $exporttype, $exportformat, $filters = null)
    {
        $returnType = '';
        $request = $this->exportRequest($token, $exporttype, $exportformat, $filters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'export'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $exporttype What to export. (required)
     * @param  string $exportformat The format of the resulting file. Valid types are CSV, HTML, XLS. (required)
     * @param  string $filters Pipe separated filters for the export, eg: aaa&#x3D;val|bbb&#x3D;val|... (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function exportRequest($token, $exporttype, $exportformat, $filters = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling export'
            );
        }
        // verify the required parameter 'exporttype' is set
        if ($exporttype === null || (is_array($exporttype) && count($exporttype) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $exporttype when calling export'
            );
        }
        // verify the required parameter 'exportformat' is set
        if ($exportformat === null || (is_array($exportformat) && count($exportformat) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $exportformat when calling export'
            );
        }

        $resourcePath = '/export';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($exporttype !== null) {
            if('form' === 'form' && is_array($exporttype)) {
                foreach($exporttype as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['exporttype'] = $exporttype;
            }
        }
        // query params
        if ($exportformat !== null) {
            if('form' === 'form' && is_array($exportformat)) {
                foreach($exportformat as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['exportformat'] = $exportformat;
            }
        }
        // query params
        if ($filters !== null) {
            if('form' === 'form' && is_array($filters)) {
                foreach($filters as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['filters'] = $filters;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation exportlisttypes
     *
     * Lists available export types
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function exportlisttypes($token)
    {
        $this->exportlisttypesWithHttpInfo($token);
    }

    /**
     * Operation exportlisttypesWithHttpInfo
     *
     * Lists available export types
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function exportlisttypesWithHttpInfo($token)
    {
        $request = $this->exportlisttypesRequest($token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation exportlisttypesAsync
     *
     * Lists available export types
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function exportlisttypesAsync($token)
    {
        return $this->exportlisttypesAsyncWithHttpInfo($token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation exportlisttypesAsyncWithHttpInfo
     *
     * Lists available export types
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function exportlisttypesAsyncWithHttpInfo($token)
    {
        $returnType = '';
        $request = $this->exportlisttypesRequest($token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'exportlisttypes'
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function exportlisttypesRequest($token)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling exportlisttypes'
            );
        }

        $resourcePath = '/exportlisttypes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation featurelist
     *
     * Lists the available features.
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function featurelist($token)
    {
        $this->featurelistWithHttpInfo($token);
    }

    /**
     * Operation featurelistWithHttpInfo
     *
     * Lists the available features.
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function featurelistWithHttpInfo($token)
    {
        $request = $this->featurelistRequest($token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation featurelistAsync
     *
     * Lists the available features.
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function featurelistAsync($token)
    {
        return $this->featurelistAsyncWithHttpInfo($token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation featurelistAsyncWithHttpInfo
     *
     * Lists the available features.
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function featurelistAsyncWithHttpInfo($token)
    {
        $returnType = '';
        $request = $this->featurelistRequest($token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'featurelist'
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function featurelistRequest($token)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling featurelist'
            );
        }

        $resourcePath = '/featurelist';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation holidaylist
     *
     * View a list of entered holidays
     *
     * @param  string $token The authentication token. (required)
     * @param  string $term The term to get holidays from. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function holidaylist($token, $term)
    {
        $this->holidaylistWithHttpInfo($token, $term);
    }

    /**
     * Operation holidaylistWithHttpInfo
     *
     * View a list of entered holidays
     *
     * @param  string $token The authentication token. (required)
     * @param  string $term The term to get holidays from. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function holidaylistWithHttpInfo($token, $term)
    {
        $request = $this->holidaylistRequest($token, $term);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation holidaylistAsync
     *
     * View a list of entered holidays
     *
     * @param  string $token The authentication token. (required)
     * @param  string $term The term to get holidays from. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function holidaylistAsync($token, $term)
    {
        return $this->holidaylistAsyncWithHttpInfo($token, $term)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation holidaylistAsyncWithHttpInfo
     *
     * View a list of entered holidays
     *
     * @param  string $token The authentication token. (required)
     * @param  string $term The term to get holidays from. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function holidaylistAsyncWithHttpInfo($token, $term)
    {
        $returnType = '';
        $request = $this->holidaylistRequest($token, $term);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'holidaylist'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $term The term to get holidays from. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function holidaylistRequest($token, $term)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling holidaylist'
            );
        }
        // verify the required parameter 'term' is set
        if ($term === null || (is_array($term) && count($term) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $term when calling holidaylist'
            );
        }

        $resourcePath = '/holidaylist';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($term !== null) {
            if('form' === 'form' && is_array($term)) {
                foreach($term as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['term'] = $term;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation holidaysave
     *
     * Create or edit a list of holidays
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function holidaysave($unknown_base_type = null)
    {
        $this->holidaysaveWithHttpInfo($unknown_base_type);
    }

    /**
     * Operation holidaysaveWithHttpInfo
     *
     * Create or edit a list of holidays
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function holidaysaveWithHttpInfo($unknown_base_type = null)
    {
        $request = $this->holidaysaveRequest($unknown_base_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation holidaysaveAsync
     *
     * Create or edit a list of holidays
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function holidaysaveAsync($unknown_base_type = null)
    {
        return $this->holidaysaveAsyncWithHttpInfo($unknown_base_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation holidaysaveAsyncWithHttpInfo
     *
     * Create or edit a list of holidays
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function holidaysaveAsyncWithHttpInfo($unknown_base_type = null)
    {
        $returnType = '';
        $request = $this->holidaysaveRequest($unknown_base_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'holidaysave'
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function holidaysaveRequest($unknown_base_type = null)
    {

        $resourcePath = '/holidaysave';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($unknown_base_type)) {
            $_tempBody = $unknown_base_type;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation holidaysuggest
     *
     * View the holiday suggestions in the given term
     *
     * @param  string $token The authentication token. (required)
     * @param  string $term The term to get holidays from. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function holidaysuggest($token, $term)
    {
        $this->holidaysuggestWithHttpInfo($token, $term);
    }

    /**
     * Operation holidaysuggestWithHttpInfo
     *
     * View the holiday suggestions in the given term
     *
     * @param  string $token The authentication token. (required)
     * @param  string $term The term to get holidays from. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function holidaysuggestWithHttpInfo($token, $term)
    {
        $request = $this->holidaysuggestRequest($token, $term);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation holidaysuggestAsync
     *
     * View the holiday suggestions in the given term
     *
     * @param  string $token The authentication token. (required)
     * @param  string $term The term to get holidays from. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function holidaysuggestAsync($token, $term)
    {
        return $this->holidaysuggestAsyncWithHttpInfo($token, $term)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation holidaysuggestAsyncWithHttpInfo
     *
     * View the holiday suggestions in the given term
     *
     * @param  string $token The authentication token. (required)
     * @param  string $term The term to get holidays from. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function holidaysuggestAsyncWithHttpInfo($token, $term)
    {
        $returnType = '';
        $request = $this->holidaysuggestRequest($token, $term);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'holidaysuggest'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $term The term to get holidays from. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function holidaysuggestRequest($token, $term)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling holidaysuggest'
            );
        }
        // verify the required parameter 'term' is set
        if ($term === null || (is_array($term) && count($term) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $term when calling holidaysuggest'
            );
        }

        $resourcePath = '/holidaysuggest';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($term !== null) {
            if('form' === 'form' && is_array($term)) {
                foreach($term as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['term'] = $term;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation import
     *
     * Import data into AccuCampus
     *
     * @param  string $token The authentication token. (required)
     * @param  string $importtype The kind of data that is being uploaded. (required)
     * @param  string $upload Set &#39;file&#39; as value to indicate that a file is being submitted in the body (instead of a JSON object). (required)
     * @param  string $filename The local name of the uploaded file. For later reference. (optional)
     * @param  string $parameters Import parameters, in a key-value pair JSON-serialized object. Eg {&#39;parameter&#39;:&#39;value&#39;}. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function import($token, $importtype, $upload, $filename = null, $parameters = null)
    {
        $this->importWithHttpInfo($token, $importtype, $upload, $filename, $parameters);
    }

    /**
     * Operation importWithHttpInfo
     *
     * Import data into AccuCampus
     *
     * @param  string $token The authentication token. (required)
     * @param  string $importtype The kind of data that is being uploaded. (required)
     * @param  string $upload Set &#39;file&#39; as value to indicate that a file is being submitted in the body (instead of a JSON object). (required)
     * @param  string $filename The local name of the uploaded file. For later reference. (optional)
     * @param  string $parameters Import parameters, in a key-value pair JSON-serialized object. Eg {&#39;parameter&#39;:&#39;value&#39;}. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function importWithHttpInfo($token, $importtype, $upload, $filename = null, $parameters = null)
    {
        $request = $this->importRequest($token, $importtype, $upload, $filename, $parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation importAsync
     *
     * Import data into AccuCampus
     *
     * @param  string $token The authentication token. (required)
     * @param  string $importtype The kind of data that is being uploaded. (required)
     * @param  string $upload Set &#39;file&#39; as value to indicate that a file is being submitted in the body (instead of a JSON object). (required)
     * @param  string $filename The local name of the uploaded file. For later reference. (optional)
     * @param  string $parameters Import parameters, in a key-value pair JSON-serialized object. Eg {&#39;parameter&#39;:&#39;value&#39;}. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function importAsync($token, $importtype, $upload, $filename = null, $parameters = null)
    {
        return $this->importAsyncWithHttpInfo($token, $importtype, $upload, $filename, $parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation importAsyncWithHttpInfo
     *
     * Import data into AccuCampus
     *
     * @param  string $token The authentication token. (required)
     * @param  string $importtype The kind of data that is being uploaded. (required)
     * @param  string $upload Set &#39;file&#39; as value to indicate that a file is being submitted in the body (instead of a JSON object). (required)
     * @param  string $filename The local name of the uploaded file. For later reference. (optional)
     * @param  string $parameters Import parameters, in a key-value pair JSON-serialized object. Eg {&#39;parameter&#39;:&#39;value&#39;}. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function importAsyncWithHttpInfo($token, $importtype, $upload, $filename = null, $parameters = null)
    {
        $returnType = '';
        $request = $this->importRequest($token, $importtype, $upload, $filename, $parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'import'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $importtype The kind of data that is being uploaded. (required)
     * @param  string $upload Set &#39;file&#39; as value to indicate that a file is being submitted in the body (instead of a JSON object). (required)
     * @param  string $filename The local name of the uploaded file. For later reference. (optional)
     * @param  string $parameters Import parameters, in a key-value pair JSON-serialized object. Eg {&#39;parameter&#39;:&#39;value&#39;}. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function importRequest($token, $importtype, $upload, $filename = null, $parameters = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling import'
            );
        }
        // verify the required parameter 'importtype' is set
        if ($importtype === null || (is_array($importtype) && count($importtype) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $importtype when calling import'
            );
        }
        // verify the required parameter 'upload' is set
        if ($upload === null || (is_array($upload) && count($upload) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $upload when calling import'
            );
        }

        $resourcePath = '/import';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($importtype !== null) {
            if('form' === 'form' && is_array($importtype)) {
                foreach($importtype as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['importtype'] = $importtype;
            }
        }
        // query params
        if ($upload !== null) {
            if('form' === 'form' && is_array($upload)) {
                foreach($upload as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['upload'] = $upload;
            }
        }
        // query params
        if ($filename !== null) {
            if('form' === 'form' && is_array($filename)) {
                foreach($filename as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['filename'] = $filename;
            }
        }
        // query params
        if ($parameters !== null) {
            if('form' === 'form' && is_array($parameters)) {
                foreach($parameters as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['parameters'] = $parameters;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation importlisttypes
     *
     * Lists available import types
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function importlisttypes($token)
    {
        $this->importlisttypesWithHttpInfo($token);
    }

    /**
     * Operation importlisttypesWithHttpInfo
     *
     * Lists available import types
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function importlisttypesWithHttpInfo($token)
    {
        $request = $this->importlisttypesRequest($token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation importlisttypesAsync
     *
     * Lists available import types
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function importlisttypesAsync($token)
    {
        return $this->importlisttypesAsyncWithHttpInfo($token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation importlisttypesAsyncWithHttpInfo
     *
     * Lists available import types
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function importlisttypesAsyncWithHttpInfo($token)
    {
        $returnType = '';
        $request = $this->importlisttypesRequest($token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'importlisttypes'
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function importlisttypesRequest($token)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling importlisttypes'
            );
        }

        $resourcePath = '/importlisttypes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation licenseacceptagreement
     *
     * Accept the license agreement
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function licenseacceptagreement($token)
    {
        $this->licenseacceptagreementWithHttpInfo($token);
    }

    /**
     * Operation licenseacceptagreementWithHttpInfo
     *
     * Accept the license agreement
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function licenseacceptagreementWithHttpInfo($token)
    {
        $request = $this->licenseacceptagreementRequest($token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation licenseacceptagreementAsync
     *
     * Accept the license agreement
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function licenseacceptagreementAsync($token)
    {
        return $this->licenseacceptagreementAsyncWithHttpInfo($token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation licenseacceptagreementAsyncWithHttpInfo
     *
     * Accept the license agreement
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function licenseacceptagreementAsyncWithHttpInfo($token)
    {
        $returnType = '';
        $request = $this->licenseacceptagreementRequest($token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'licenseacceptagreement'
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function licenseacceptagreementRequest($token)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling licenseacceptagreement'
            );
        }

        $resourcePath = '/licenseacceptagreement';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation licensegetagreementstatus
     *
     * Check if license agreement has been accepted
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function licensegetagreementstatus($token)
    {
        $this->licensegetagreementstatusWithHttpInfo($token);
    }

    /**
     * Operation licensegetagreementstatusWithHttpInfo
     *
     * Check if license agreement has been accepted
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function licensegetagreementstatusWithHttpInfo($token)
    {
        $request = $this->licensegetagreementstatusRequest($token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation licensegetagreementstatusAsync
     *
     * Check if license agreement has been accepted
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function licensegetagreementstatusAsync($token)
    {
        return $this->licensegetagreementstatusAsyncWithHttpInfo($token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation licensegetagreementstatusAsyncWithHttpInfo
     *
     * Check if license agreement has been accepted
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function licensegetagreementstatusAsyncWithHttpInfo($token)
    {
        $returnType = '';
        $request = $this->licensegetagreementstatusRequest($token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'licensegetagreementstatus'
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function licensegetagreementstatusRequest($token)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling licensegetagreementstatus'
            );
        }

        $resourcePath = '/licensegetagreementstatus';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation licensegetcurrent
     *
     * Gets the current license information
     *
     * @param  string $token The authentication token. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function licensegetcurrent($token = null)
    {
        $this->licensegetcurrentWithHttpInfo($token);
    }

    /**
     * Operation licensegetcurrentWithHttpInfo
     *
     * Gets the current license information
     *
     * @param  string $token The authentication token. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function licensegetcurrentWithHttpInfo($token = null)
    {
        $request = $this->licensegetcurrentRequest($token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation licensegetcurrentAsync
     *
     * Gets the current license information
     *
     * @param  string $token The authentication token. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function licensegetcurrentAsync($token = null)
    {
        return $this->licensegetcurrentAsyncWithHttpInfo($token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation licensegetcurrentAsyncWithHttpInfo
     *
     * Gets the current license information
     *
     * @param  string $token The authentication token. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function licensegetcurrentAsyncWithHttpInfo($token = null)
    {
        $returnType = '';
        $request = $this->licensegetcurrentRequest($token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'licensegetcurrent'
     *
     * @param  string $token The authentication token. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function licensegetcurrentRequest($token = null)
    {

        $resourcePath = '/licensegetcurrent';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation licenserenew
     *
     * Contact Engineerica in order to renew the AccuCampus subscription
     *
     * @param  string $token The authentication token. (required)
     * @param  string $email The e-mail of the user sending the request. (required)
     * @param  string $phonenumber The phone number of the user sending the request. (required)
     * @param  string $jobtitle The job title of the user sending the request. (optional)
     * @param  string $institution The institution of the user sending the request. (optional)
     * @param  string $comments Comments entered by the user sending the request. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function licenserenew($token, $email, $phonenumber, $jobtitle = null, $institution = null, $comments = null)
    {
        $this->licenserenewWithHttpInfo($token, $email, $phonenumber, $jobtitle, $institution, $comments);
    }

    /**
     * Operation licenserenewWithHttpInfo
     *
     * Contact Engineerica in order to renew the AccuCampus subscription
     *
     * @param  string $token The authentication token. (required)
     * @param  string $email The e-mail of the user sending the request. (required)
     * @param  string $phonenumber The phone number of the user sending the request. (required)
     * @param  string $jobtitle The job title of the user sending the request. (optional)
     * @param  string $institution The institution of the user sending the request. (optional)
     * @param  string $comments Comments entered by the user sending the request. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function licenserenewWithHttpInfo($token, $email, $phonenumber, $jobtitle = null, $institution = null, $comments = null)
    {
        $request = $this->licenserenewRequest($token, $email, $phonenumber, $jobtitle, $institution, $comments);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation licenserenewAsync
     *
     * Contact Engineerica in order to renew the AccuCampus subscription
     *
     * @param  string $token The authentication token. (required)
     * @param  string $email The e-mail of the user sending the request. (required)
     * @param  string $phonenumber The phone number of the user sending the request. (required)
     * @param  string $jobtitle The job title of the user sending the request. (optional)
     * @param  string $institution The institution of the user sending the request. (optional)
     * @param  string $comments Comments entered by the user sending the request. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function licenserenewAsync($token, $email, $phonenumber, $jobtitle = null, $institution = null, $comments = null)
    {
        return $this->licenserenewAsyncWithHttpInfo($token, $email, $phonenumber, $jobtitle, $institution, $comments)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation licenserenewAsyncWithHttpInfo
     *
     * Contact Engineerica in order to renew the AccuCampus subscription
     *
     * @param  string $token The authentication token. (required)
     * @param  string $email The e-mail of the user sending the request. (required)
     * @param  string $phonenumber The phone number of the user sending the request. (required)
     * @param  string $jobtitle The job title of the user sending the request. (optional)
     * @param  string $institution The institution of the user sending the request. (optional)
     * @param  string $comments Comments entered by the user sending the request. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function licenserenewAsyncWithHttpInfo($token, $email, $phonenumber, $jobtitle = null, $institution = null, $comments = null)
    {
        $returnType = '';
        $request = $this->licenserenewRequest($token, $email, $phonenumber, $jobtitle, $institution, $comments);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'licenserenew'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $email The e-mail of the user sending the request. (required)
     * @param  string $phonenumber The phone number of the user sending the request. (required)
     * @param  string $jobtitle The job title of the user sending the request. (optional)
     * @param  string $institution The institution of the user sending the request. (optional)
     * @param  string $comments Comments entered by the user sending the request. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function licenserenewRequest($token, $email, $phonenumber, $jobtitle = null, $institution = null, $comments = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling licenserenew'
            );
        }
        // verify the required parameter 'email' is set
        if ($email === null || (is_array($email) && count($email) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $email when calling licenserenew'
            );
        }
        // verify the required parameter 'phonenumber' is set
        if ($phonenumber === null || (is_array($phonenumber) && count($phonenumber) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $phonenumber when calling licenserenew'
            );
        }

        $resourcePath = '/licenserenew';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($email !== null) {
            if('form' === 'form' && is_array($email)) {
                foreach($email as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['email'] = $email;
            }
        }
        // query params
        if ($phonenumber !== null) {
            if('form' === 'form' && is_array($phonenumber)) {
                foreach($phonenumber as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['phonenumber'] = $phonenumber;
            }
        }
        // query params
        if ($jobtitle !== null) {
            if('form' === 'form' && is_array($jobtitle)) {
                foreach($jobtitle as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['jobtitle'] = $jobtitle;
            }
        }
        // query params
        if ($institution !== null) {
            if('form' === 'form' && is_array($institution)) {
                foreach($institution as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['institution'] = $institution;
            }
        }
        // query params
        if ($comments !== null) {
            if('form' === 'form' && is_array($comments)) {
                foreach($comments as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['comments'] = $comments;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listtimezones
     *
     * Lists the available timezones
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function listtimezones()
    {
        $this->listtimezonesWithHttpInfo();
    }

    /**
     * Operation listtimezonesWithHttpInfo
     *
     * Lists the available timezones
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function listtimezonesWithHttpInfo()
    {
        $request = $this->listtimezonesRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation listtimezonesAsync
     *
     * Lists the available timezones
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listtimezonesAsync()
    {
        return $this->listtimezonesAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listtimezonesAsyncWithHttpInfo
     *
     * Lists the available timezones
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listtimezonesAsyncWithHttpInfo()
    {
        $returnType = '';
        $request = $this->listtimezonesRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listtimezones'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listtimezonesRequest()
    {

        $resourcePath = '/listtimezones';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation locationdelete
     *
     * Delete a location
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the location to delete. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function locationdelete($token, $id)
    {
        $this->locationdeleteWithHttpInfo($token, $id);
    }

    /**
     * Operation locationdeleteWithHttpInfo
     *
     * Delete a location
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the location to delete. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function locationdeleteWithHttpInfo($token, $id)
    {
        $request = $this->locationdeleteRequest($token, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation locationdeleteAsync
     *
     * Delete a location
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the location to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function locationdeleteAsync($token, $id)
    {
        return $this->locationdeleteAsyncWithHttpInfo($token, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation locationdeleteAsyncWithHttpInfo
     *
     * Delete a location
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the location to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function locationdeleteAsyncWithHttpInfo($token, $id)
    {
        $returnType = '';
        $request = $this->locationdeleteRequest($token, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'locationdelete'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the location to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function locationdeleteRequest($token, $id)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling locationdelete'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling locationdelete'
            );
        }

        $resourcePath = '/locationdelete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($id !== null) {
            if('form' === 'form' && is_array($id)) {
                foreach($id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['id'] = $id;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation locationget
     *
     * Search and view details of a location
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the location to get. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function locationget($token, $id)
    {
        $this->locationgetWithHttpInfo($token, $id);
    }

    /**
     * Operation locationgetWithHttpInfo
     *
     * Search and view details of a location
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the location to get. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function locationgetWithHttpInfo($token, $id)
    {
        $request = $this->locationgetRequest($token, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation locationgetAsync
     *
     * Search and view details of a location
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the location to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function locationgetAsync($token, $id)
    {
        return $this->locationgetAsyncWithHttpInfo($token, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation locationgetAsyncWithHttpInfo
     *
     * Search and view details of a location
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the location to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function locationgetAsyncWithHttpInfo($token, $id)
    {
        $returnType = '';
        $request = $this->locationgetRequest($token, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'locationget'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the location to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function locationgetRequest($token, $id)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling locationget'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling locationget'
            );
        }

        $resourcePath = '/locationget';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($id !== null) {
            if('form' === 'form' && is_array($id)) {
                foreach($id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['id'] = $id;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation locationlist
     *
     * View a list of locations
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $locations The comma-separated list containing the ids of the locations to list. (optional)
     * @param  bool $sortbygroup True to list locations sorted by the &#39;Located In&#39; property. Defaults to false. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function locationlist($token, $from, $count, $locations = null, $sortbygroup = null)
    {
        $this->locationlistWithHttpInfo($token, $from, $count, $locations, $sortbygroup);
    }

    /**
     * Operation locationlistWithHttpInfo
     *
     * View a list of locations
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $locations The comma-separated list containing the ids of the locations to list. (optional)
     * @param  bool $sortbygroup True to list locations sorted by the &#39;Located In&#39; property. Defaults to false. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function locationlistWithHttpInfo($token, $from, $count, $locations = null, $sortbygroup = null)
    {
        $request = $this->locationlistRequest($token, $from, $count, $locations, $sortbygroup);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation locationlistAsync
     *
     * View a list of locations
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $locations The comma-separated list containing the ids of the locations to list. (optional)
     * @param  bool $sortbygroup True to list locations sorted by the &#39;Located In&#39; property. Defaults to false. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function locationlistAsync($token, $from, $count, $locations = null, $sortbygroup = null)
    {
        return $this->locationlistAsyncWithHttpInfo($token, $from, $count, $locations, $sortbygroup)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation locationlistAsyncWithHttpInfo
     *
     * View a list of locations
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $locations The comma-separated list containing the ids of the locations to list. (optional)
     * @param  bool $sortbygroup True to list locations sorted by the &#39;Located In&#39; property. Defaults to false. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function locationlistAsyncWithHttpInfo($token, $from, $count, $locations = null, $sortbygroup = null)
    {
        $returnType = '';
        $request = $this->locationlistRequest($token, $from, $count, $locations, $sortbygroup);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'locationlist'
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $locations The comma-separated list containing the ids of the locations to list. (optional)
     * @param  bool $sortbygroup True to list locations sorted by the &#39;Located In&#39; property. Defaults to false. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function locationlistRequest($token, $from, $count, $locations = null, $sortbygroup = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling locationlist'
            );
        }
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling locationlist'
            );
        }
        // verify the required parameter 'count' is set
        if ($count === null || (is_array($count) && count($count) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $count when calling locationlist'
            );
        }

        $resourcePath = '/locationlist';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }
        // query params
        if ($count !== null) {
            if('form' === 'form' && is_array($count)) {
                foreach($count as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['count'] = $count;
            }
        }
        // query params
        if ($locations !== null) {
            if('form' === 'form' && is_array($locations)) {
                foreach($locations as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['locations'] = $locations;
            }
        }
        // query params
        if ($sortbygroup !== null) {
            if('form' === 'form' && is_array($sortbygroup)) {
                foreach($sortbygroup as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['sortbygroup'] = $sortbygroup;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation locationsave
     *
     * Create or edit a location
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function locationsave($unknown_base_type = null)
    {
        $this->locationsaveWithHttpInfo($unknown_base_type);
    }

    /**
     * Operation locationsaveWithHttpInfo
     *
     * Create or edit a location
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function locationsaveWithHttpInfo($unknown_base_type = null)
    {
        $request = $this->locationsaveRequest($unknown_base_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation locationsaveAsync
     *
     * Create or edit a location
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function locationsaveAsync($unknown_base_type = null)
    {
        return $this->locationsaveAsyncWithHttpInfo($unknown_base_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation locationsaveAsyncWithHttpInfo
     *
     * Create or edit a location
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function locationsaveAsyncWithHttpInfo($unknown_base_type = null)
    {
        $returnType = '';
        $request = $this->locationsaveRequest($unknown_base_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'locationsave'
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function locationsaveRequest($unknown_base_type = null)
    {

        $resourcePath = '/locationsave';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($unknown_base_type)) {
            $_tempBody = $unknown_base_type;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation login
     *
     * Login
     *
     * @param  string $domain The account domain to login. (required)
     * @param  string $username The username (email) of the user to login as. (required)
     * @param  string $password The password of the user to login as. (required)
     * @param  string $method The authentication method. Valid values are &#39;token&#39; and &#39;cookie&#39;. (required)
     * @param  bool $rememberme If true then the session will not expire. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function login($domain, $username, $password, $method, $rememberme = null)
    {
        $this->loginWithHttpInfo($domain, $username, $password, $method, $rememberme);
    }

    /**
     * Operation loginWithHttpInfo
     *
     * Login
     *
     * @param  string $domain The account domain to login. (required)
     * @param  string $username The username (email) of the user to login as. (required)
     * @param  string $password The password of the user to login as. (required)
     * @param  string $method The authentication method. Valid values are &#39;token&#39; and &#39;cookie&#39;. (required)
     * @param  bool $rememberme If true then the session will not expire. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function loginWithHttpInfo($domain, $username, $password, $method, $rememberme = null)
    {
        $request = $this->loginRequest($domain, $username, $password, $method, $rememberme);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation loginAsync
     *
     * Login
     *
     * @param  string $domain The account domain to login. (required)
     * @param  string $username The username (email) of the user to login as. (required)
     * @param  string $password The password of the user to login as. (required)
     * @param  string $method The authentication method. Valid values are &#39;token&#39; and &#39;cookie&#39;. (required)
     * @param  bool $rememberme If true then the session will not expire. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function loginAsync($domain, $username, $password, $method, $rememberme = null)
    {
        return $this->loginAsyncWithHttpInfo($domain, $username, $password, $method, $rememberme)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation loginAsyncWithHttpInfo
     *
     * Login
     *
     * @param  string $domain The account domain to login. (required)
     * @param  string $username The username (email) of the user to login as. (required)
     * @param  string $password The password of the user to login as. (required)
     * @param  string $method The authentication method. Valid values are &#39;token&#39; and &#39;cookie&#39;. (required)
     * @param  bool $rememberme If true then the session will not expire. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function loginAsyncWithHttpInfo($domain, $username, $password, $method, $rememberme = null)
    {
        $returnType = '';
        $request = $this->loginRequest($domain, $username, $password, $method, $rememberme);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'login'
     *
     * @param  string $domain The account domain to login. (required)
     * @param  string $username The username (email) of the user to login as. (required)
     * @param  string $password The password of the user to login as. (required)
     * @param  string $method The authentication method. Valid values are &#39;token&#39; and &#39;cookie&#39;. (required)
     * @param  bool $rememberme If true then the session will not expire. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function loginRequest($domain, $username, $password, $method, $rememberme = null)
    {
        // verify the required parameter 'domain' is set
        if ($domain === null || (is_array($domain) && count($domain) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $domain when calling login'
            );
        }
        // verify the required parameter 'username' is set
        if ($username === null || (is_array($username) && count($username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $username when calling login'
            );
        }
        // verify the required parameter 'password' is set
        if ($password === null || (is_array($password) && count($password) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $password when calling login'
            );
        }
        // verify the required parameter 'method' is set
        if ($method === null || (is_array($method) && count($method) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $method when calling login'
            );
        }

        $resourcePath = '/login';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($domain !== null) {
            if('form' === 'form' && is_array($domain)) {
                foreach($domain as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['domain'] = $domain;
            }
        }
        // query params
        if ($username !== null) {
            if('form' === 'form' && is_array($username)) {
                foreach($username as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['username'] = $username;
            }
        }
        // query params
        if ($password !== null) {
            if('form' === 'form' && is_array($password)) {
                foreach($password as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['password'] = $password;
            }
        }
        // query params
        if ($method !== null) {
            if('form' === 'form' && is_array($method)) {
                foreach($method as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['method'] = $method;
            }
        }
        // query params
        if ($rememberme !== null) {
            if('form' === 'form' && is_array($rememberme)) {
                foreach($rememberme as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['rememberme'] = $rememberme;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation logout
     *
     * Logout
     *
     * @param  string $token The authentication token used to login. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function logout($token = null)
    {
        $this->logoutWithHttpInfo($token);
    }

    /**
     * Operation logoutWithHttpInfo
     *
     * Logout
     *
     * @param  string $token The authentication token used to login. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function logoutWithHttpInfo($token = null)
    {
        $request = $this->logoutRequest($token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation logoutAsync
     *
     * Logout
     *
     * @param  string $token The authentication token used to login. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function logoutAsync($token = null)
    {
        return $this->logoutAsyncWithHttpInfo($token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation logoutAsyncWithHttpInfo
     *
     * Logout
     *
     * @param  string $token The authentication token used to login. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function logoutAsyncWithHttpInfo($token = null)
    {
        $returnType = '';
        $request = $this->logoutRequest($token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'logout'
     *
     * @param  string $token The authentication token used to login. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function logoutRequest($token = null)
    {

        $resourcePath = '/logout';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation memorizedreportdelete
     *
     * Delete memorized report
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the report settings to delete. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function memorizedreportdelete($token, $id)
    {
        $this->memorizedreportdeleteWithHttpInfo($token, $id);
    }

    /**
     * Operation memorizedreportdeleteWithHttpInfo
     *
     * Delete memorized report
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the report settings to delete. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function memorizedreportdeleteWithHttpInfo($token, $id)
    {
        $request = $this->memorizedreportdeleteRequest($token, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation memorizedreportdeleteAsync
     *
     * Delete memorized report
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the report settings to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function memorizedreportdeleteAsync($token, $id)
    {
        return $this->memorizedreportdeleteAsyncWithHttpInfo($token, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation memorizedreportdeleteAsyncWithHttpInfo
     *
     * Delete memorized report
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the report settings to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function memorizedreportdeleteAsyncWithHttpInfo($token, $id)
    {
        $returnType = '';
        $request = $this->memorizedreportdeleteRequest($token, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'memorizedreportdelete'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the report settings to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function memorizedreportdeleteRequest($token, $id)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling memorizedreportdelete'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling memorizedreportdelete'
            );
        }

        $resourcePath = '/memorizedreportdelete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($id !== null) {
            if('form' === 'form' && is_array($id)) {
                foreach($id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['id'] = $id;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation memorizedreportget
     *
     * View details of a memorized report
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the report configuration to get. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function memorizedreportget($token, $id)
    {
        $this->memorizedreportgetWithHttpInfo($token, $id);
    }

    /**
     * Operation memorizedreportgetWithHttpInfo
     *
     * View details of a memorized report
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the report configuration to get. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function memorizedreportgetWithHttpInfo($token, $id)
    {
        $request = $this->memorizedreportgetRequest($token, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation memorizedreportgetAsync
     *
     * View details of a memorized report
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the report configuration to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function memorizedreportgetAsync($token, $id)
    {
        return $this->memorizedreportgetAsyncWithHttpInfo($token, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation memorizedreportgetAsyncWithHttpInfo
     *
     * View details of a memorized report
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the report configuration to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function memorizedreportgetAsyncWithHttpInfo($token, $id)
    {
        $returnType = '';
        $request = $this->memorizedreportgetRequest($token, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'memorizedreportget'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the report configuration to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function memorizedreportgetRequest($token, $id)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling memorizedreportget'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling memorizedreportget'
            );
        }

        $resourcePath = '/memorizedreportget';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($id !== null) {
            if('form' === 'form' && is_array($id)) {
                foreach($id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['id'] = $id;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation memorizedreportlist
     *
     * View a list of all his memorized reports
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $customname If specified filters the memorized reports by custom name. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function memorizedreportlist($token, $from, $count, $customname = null)
    {
        $this->memorizedreportlistWithHttpInfo($token, $from, $count, $customname);
    }

    /**
     * Operation memorizedreportlistWithHttpInfo
     *
     * View a list of all his memorized reports
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $customname If specified filters the memorized reports by custom name. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function memorizedreportlistWithHttpInfo($token, $from, $count, $customname = null)
    {
        $request = $this->memorizedreportlistRequest($token, $from, $count, $customname);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation memorizedreportlistAsync
     *
     * View a list of all his memorized reports
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $customname If specified filters the memorized reports by custom name. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function memorizedreportlistAsync($token, $from, $count, $customname = null)
    {
        return $this->memorizedreportlistAsyncWithHttpInfo($token, $from, $count, $customname)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation memorizedreportlistAsyncWithHttpInfo
     *
     * View a list of all his memorized reports
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $customname If specified filters the memorized reports by custom name. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function memorizedreportlistAsyncWithHttpInfo($token, $from, $count, $customname = null)
    {
        $returnType = '';
        $request = $this->memorizedreportlistRequest($token, $from, $count, $customname);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'memorizedreportlist'
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $customname If specified filters the memorized reports by custom name. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function memorizedreportlistRequest($token, $from, $count, $customname = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling memorizedreportlist'
            );
        }
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling memorizedreportlist'
            );
        }
        // verify the required parameter 'count' is set
        if ($count === null || (is_array($count) && count($count) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $count when calling memorizedreportlist'
            );
        }

        $resourcePath = '/memorizedreportlist';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($customname !== null) {
            if('form' === 'form' && is_array($customname)) {
                foreach($customname as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['customname'] = $customname;
            }
        }
        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }
        // query params
        if ($count !== null) {
            if('form' === 'form' && is_array($count)) {
                foreach($count as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['count'] = $count;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation memorizedreportsave
     *
     * Create or edit a memorized report
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function memorizedreportsave($unknown_base_type = null)
    {
        $this->memorizedreportsaveWithHttpInfo($unknown_base_type);
    }

    /**
     * Operation memorizedreportsaveWithHttpInfo
     *
     * Create or edit a memorized report
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function memorizedreportsaveWithHttpInfo($unknown_base_type = null)
    {
        $request = $this->memorizedreportsaveRequest($unknown_base_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation memorizedreportsaveAsync
     *
     * Create or edit a memorized report
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function memorizedreportsaveAsync($unknown_base_type = null)
    {
        return $this->memorizedreportsaveAsyncWithHttpInfo($unknown_base_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation memorizedreportsaveAsyncWithHttpInfo
     *
     * Create or edit a memorized report
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function memorizedreportsaveAsyncWithHttpInfo($unknown_base_type = null)
    {
        $returnType = '';
        $request = $this->memorizedreportsaveRequest($unknown_base_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'memorizedreportsave'
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function memorizedreportsaveRequest($unknown_base_type = null)
    {

        $resourcePath = '/memorizedreportsave';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($unknown_base_type)) {
            $_tempBody = $unknown_base_type;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation menugetitems
     *
     * Gets the items on the menu
     *
     * @param  string $menuid The Id of the menu to get. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function menugetitems($menuid)
    {
        $this->menugetitemsWithHttpInfo($menuid);
    }

    /**
     * Operation menugetitemsWithHttpInfo
     *
     * Gets the items on the menu
     *
     * @param  string $menuid The Id of the menu to get. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function menugetitemsWithHttpInfo($menuid)
    {
        $request = $this->menugetitemsRequest($menuid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation menugetitemsAsync
     *
     * Gets the items on the menu
     *
     * @param  string $menuid The Id of the menu to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function menugetitemsAsync($menuid)
    {
        return $this->menugetitemsAsyncWithHttpInfo($menuid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation menugetitemsAsyncWithHttpInfo
     *
     * Gets the items on the menu
     *
     * @param  string $menuid The Id of the menu to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function menugetitemsAsyncWithHttpInfo($menuid)
    {
        $returnType = '';
        $request = $this->menugetitemsRequest($menuid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'menugetitems'
     *
     * @param  string $menuid The Id of the menu to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function menugetitemsRequest($menuid)
    {
        // verify the required parameter 'menuid' is set
        if ($menuid === null || (is_array($menuid) && count($menuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $menuid when calling menugetitems'
            );
        }

        $resourcePath = '/menugetitems';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($menuid !== null) {
            if('form' === 'form' && is_array($menuid)) {
                foreach($menuid as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['menuid'] = $menuid;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation myaccount
     *
     * Gets the logged in user account.
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function myaccount($token)
    {
        $this->myaccountWithHttpInfo($token);
    }

    /**
     * Operation myaccountWithHttpInfo
     *
     * Gets the logged in user account.
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function myaccountWithHttpInfo($token)
    {
        $request = $this->myaccountRequest($token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation myaccountAsync
     *
     * Gets the logged in user account.
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function myaccountAsync($token)
    {
        return $this->myaccountAsyncWithHttpInfo($token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation myaccountAsyncWithHttpInfo
     *
     * Gets the logged in user account.
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function myaccountAsyncWithHttpInfo($token)
    {
        $returnType = '';
        $request = $this->myaccountRequest($token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'myaccount'
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function myaccountRequest($token)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling myaccount'
            );
        }

        $resourcePath = '/myaccount';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation myianatimezone
     *
     * Gets the current time zone's iana name
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function myianatimezone($token)
    {
        $this->myianatimezoneWithHttpInfo($token);
    }

    /**
     * Operation myianatimezoneWithHttpInfo
     *
     * Gets the current time zone's iana name
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function myianatimezoneWithHttpInfo($token)
    {
        $request = $this->myianatimezoneRequest($token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation myianatimezoneAsync
     *
     * Gets the current time zone's iana name
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function myianatimezoneAsync($token)
    {
        return $this->myianatimezoneAsyncWithHttpInfo($token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation myianatimezoneAsyncWithHttpInfo
     *
     * Gets the current time zone's iana name
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function myianatimezoneAsyncWithHttpInfo($token)
    {
        $returnType = '';
        $request = $this->myianatimezoneRequest($token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'myianatimezone'
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function myianatimezoneRequest($token)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling myianatimezone'
            );
        }

        $resourcePath = '/myianatimezone';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation myprofile
     *
     * Gets the logged in user information.
     *
     * @param  string $token The authentication token. (required)
     * @param  int $photosize The size in pixels of the photo URLs returned. Defaults to 40. If the size specified is not available, a similar one will be returned. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function myprofile($token, $photosize = null)
    {
        $this->myprofileWithHttpInfo($token, $photosize);
    }

    /**
     * Operation myprofileWithHttpInfo
     *
     * Gets the logged in user information.
     *
     * @param  string $token The authentication token. (required)
     * @param  int $photosize The size in pixels of the photo URLs returned. Defaults to 40. If the size specified is not available, a similar one will be returned. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function myprofileWithHttpInfo($token, $photosize = null)
    {
        $request = $this->myprofileRequest($token, $photosize);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation myprofileAsync
     *
     * Gets the logged in user information.
     *
     * @param  string $token The authentication token. (required)
     * @param  int $photosize The size in pixels of the photo URLs returned. Defaults to 40. If the size specified is not available, a similar one will be returned. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function myprofileAsync($token, $photosize = null)
    {
        return $this->myprofileAsyncWithHttpInfo($token, $photosize)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation myprofileAsyncWithHttpInfo
     *
     * Gets the logged in user information.
     *
     * @param  string $token The authentication token. (required)
     * @param  int $photosize The size in pixels of the photo URLs returned. Defaults to 40. If the size specified is not available, a similar one will be returned. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function myprofileAsyncWithHttpInfo($token, $photosize = null)
    {
        $returnType = '';
        $request = $this->myprofileRequest($token, $photosize);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'myprofile'
     *
     * @param  string $token The authentication token. (required)
     * @param  int $photosize The size in pixels of the photo URLs returned. Defaults to 40. If the size specified is not available, a similar one will be returned. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function myprofileRequest($token, $photosize = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling myprofile'
            );
        }

        $resourcePath = '/myprofile';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($photosize !== null) {
            if('form' === 'form' && is_array($photosize)) {
                foreach($photosize as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['photosize'] = $photosize;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation myrights
     *
     * Gets the list of actions the user can execute.
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function myrights($token)
    {
        $this->myrightsWithHttpInfo($token);
    }

    /**
     * Operation myrightsWithHttpInfo
     *
     * Gets the list of actions the user can execute.
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function myrightsWithHttpInfo($token)
    {
        $request = $this->myrightsRequest($token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation myrightsAsync
     *
     * Gets the list of actions the user can execute.
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function myrightsAsync($token)
    {
        return $this->myrightsAsyncWithHttpInfo($token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation myrightsAsyncWithHttpInfo
     *
     * Gets the list of actions the user can execute.
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function myrightsAsyncWithHttpInfo($token)
    {
        $returnType = '';
        $request = $this->myrightsRequest($token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'myrights'
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function myrightsRequest($token)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling myrights'
            );
        }

        $resourcePath = '/myrights';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation mysaveprofile
     *
     * Updates logged user's profile information
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function mysaveprofile($unknown_base_type = null)
    {
        $this->mysaveprofileWithHttpInfo($unknown_base_type);
    }

    /**
     * Operation mysaveprofileWithHttpInfo
     *
     * Updates logged user's profile information
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function mysaveprofileWithHttpInfo($unknown_base_type = null)
    {
        $request = $this->mysaveprofileRequest($unknown_base_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation mysaveprofileAsync
     *
     * Updates logged user's profile information
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function mysaveprofileAsync($unknown_base_type = null)
    {
        return $this->mysaveprofileAsyncWithHttpInfo($unknown_base_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation mysaveprofileAsyncWithHttpInfo
     *
     * Updates logged user's profile information
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function mysaveprofileAsyncWithHttpInfo($unknown_base_type = null)
    {
        $returnType = '';
        $request = $this->mysaveprofileRequest($unknown_base_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'mysaveprofile'
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function mysaveprofileRequest($unknown_base_type = null)
    {

        $resourcePath = '/mysaveprofile';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($unknown_base_type)) {
            $_tempBody = $unknown_base_type;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation notificationdelete
     *
     * Delete a notification
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the notification to delete. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function notificationdelete($token, $id)
    {
        $this->notificationdeleteWithHttpInfo($token, $id);
    }

    /**
     * Operation notificationdeleteWithHttpInfo
     *
     * Delete a notification
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the notification to delete. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function notificationdeleteWithHttpInfo($token, $id)
    {
        $request = $this->notificationdeleteRequest($token, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation notificationdeleteAsync
     *
     * Delete a notification
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the notification to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function notificationdeleteAsync($token, $id)
    {
        return $this->notificationdeleteAsyncWithHttpInfo($token, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation notificationdeleteAsyncWithHttpInfo
     *
     * Delete a notification
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the notification to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function notificationdeleteAsyncWithHttpInfo($token, $id)
    {
        $returnType = '';
        $request = $this->notificationdeleteRequest($token, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'notificationdelete'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the notification to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function notificationdeleteRequest($token, $id)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling notificationdelete'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling notificationdelete'
            );
        }

        $resourcePath = '/notificationdelete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($id !== null) {
            if('form' === 'form' && is_array($id)) {
                foreach($id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['id'] = $id;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation notificationget
     *
     * View a notification
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the notification to get. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function notificationget($token, $id)
    {
        $this->notificationgetWithHttpInfo($token, $id);
    }

    /**
     * Operation notificationgetWithHttpInfo
     *
     * View a notification
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the notification to get. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function notificationgetWithHttpInfo($token, $id)
    {
        $request = $this->notificationgetRequest($token, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation notificationgetAsync
     *
     * View a notification
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the notification to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function notificationgetAsync($token, $id)
    {
        return $this->notificationgetAsyncWithHttpInfo($token, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation notificationgetAsyncWithHttpInfo
     *
     * View a notification
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the notification to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function notificationgetAsyncWithHttpInfo($token, $id)
    {
        $returnType = '';
        $request = $this->notificationgetRequest($token, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'notificationget'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the notification to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function notificationgetRequest($token, $id)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling notificationget'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling notificationget'
            );
        }

        $resourcePath = '/notificationget';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($id !== null) {
            if('form' === 'form' && is_array($id)) {
                foreach($id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['id'] = $id;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation notificationgetforstation
     *
     * Gets all public (in station) notifications for the specific user
     *
     * @param  string $station The id of the sign-in station to get. (required)
     * @param  string $user The card of the user. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function notificationgetforstation($station, $user)
    {
        $this->notificationgetforstationWithHttpInfo($station, $user);
    }

    /**
     * Operation notificationgetforstationWithHttpInfo
     *
     * Gets all public (in station) notifications for the specific user
     *
     * @param  string $station The id of the sign-in station to get. (required)
     * @param  string $user The card of the user. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function notificationgetforstationWithHttpInfo($station, $user)
    {
        $request = $this->notificationgetforstationRequest($station, $user);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation notificationgetforstationAsync
     *
     * Gets all public (in station) notifications for the specific user
     *
     * @param  string $station The id of the sign-in station to get. (required)
     * @param  string $user The card of the user. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function notificationgetforstationAsync($station, $user)
    {
        return $this->notificationgetforstationAsyncWithHttpInfo($station, $user)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation notificationgetforstationAsyncWithHttpInfo
     *
     * Gets all public (in station) notifications for the specific user
     *
     * @param  string $station The id of the sign-in station to get. (required)
     * @param  string $user The card of the user. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function notificationgetforstationAsyncWithHttpInfo($station, $user)
    {
        $returnType = '';
        $request = $this->notificationgetforstationRequest($station, $user);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'notificationgetforstation'
     *
     * @param  string $station The id of the sign-in station to get. (required)
     * @param  string $user The card of the user. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function notificationgetforstationRequest($station, $user)
    {
        // verify the required parameter 'station' is set
        if ($station === null || (is_array($station) && count($station) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $station when calling notificationgetforstation'
            );
        }
        // verify the required parameter 'user' is set
        if ($user === null || (is_array($user) && count($user) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user when calling notificationgetforstation'
            );
        }

        $resourcePath = '/notificationgetforstation';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($station !== null) {
            if('form' === 'form' && is_array($station)) {
                foreach($station as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['station'] = $station;
            }
        }
        // query params
        if ($user !== null) {
            if('form' === 'form' && is_array($user)) {
                foreach($user as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['user'] = $user;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation notificationgetunreadcount
     *
     * Get the number of unread notifications
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function notificationgetunreadcount($token)
    {
        $this->notificationgetunreadcountWithHttpInfo($token);
    }

    /**
     * Operation notificationgetunreadcountWithHttpInfo
     *
     * Get the number of unread notifications
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function notificationgetunreadcountWithHttpInfo($token)
    {
        $request = $this->notificationgetunreadcountRequest($token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation notificationgetunreadcountAsync
     *
     * Get the number of unread notifications
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function notificationgetunreadcountAsync($token)
    {
        return $this->notificationgetunreadcountAsyncWithHttpInfo($token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation notificationgetunreadcountAsyncWithHttpInfo
     *
     * Get the number of unread notifications
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function notificationgetunreadcountAsyncWithHttpInfo($token)
    {
        $returnType = '';
        $request = $this->notificationgetunreadcountRequest($token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'notificationgetunreadcount'
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function notificationgetunreadcountRequest($token)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling notificationgetunreadcount'
            );
        }

        $resourcePath = '/notificationgetunreadcount';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation notificationlist
     *
     * View a list of all sent notifications
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $recipient The recipient whose notifications have to be listed. (optional)
     * @param  int $status The status of the notifications to list. Read, Unread or All. (optional)
     * @param  \DateTime $startdate The start date of the period to filter the notifications. (optional)
     * @param  \DateTime $enddate The end date of the period to filter the notifications. (optional)
     * @param  bool $sentonscreen Specifies whether to list the notifications that were sent on-screen or not. (optional)
     * @param  bool $sentemail Specifies whether to list the notifications that were sent via e-mail or not. (optional)
     * @param  bool $sentsms Specifies whether to list the notifications that were sent via sms or not. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function notificationlist($token, $from, $count, $recipient = null, $status = null, $startdate = null, $enddate = null, $sentonscreen = null, $sentemail = null, $sentsms = null)
    {
        $this->notificationlistWithHttpInfo($token, $from, $count, $recipient, $status, $startdate, $enddate, $sentonscreen, $sentemail, $sentsms);
    }

    /**
     * Operation notificationlistWithHttpInfo
     *
     * View a list of all sent notifications
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $recipient The recipient whose notifications have to be listed. (optional)
     * @param  int $status The status of the notifications to list. Read, Unread or All. (optional)
     * @param  \DateTime $startdate The start date of the period to filter the notifications. (optional)
     * @param  \DateTime $enddate The end date of the period to filter the notifications. (optional)
     * @param  bool $sentonscreen Specifies whether to list the notifications that were sent on-screen or not. (optional)
     * @param  bool $sentemail Specifies whether to list the notifications that were sent via e-mail or not. (optional)
     * @param  bool $sentsms Specifies whether to list the notifications that were sent via sms or not. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function notificationlistWithHttpInfo($token, $from, $count, $recipient = null, $status = null, $startdate = null, $enddate = null, $sentonscreen = null, $sentemail = null, $sentsms = null)
    {
        $request = $this->notificationlistRequest($token, $from, $count, $recipient, $status, $startdate, $enddate, $sentonscreen, $sentemail, $sentsms);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation notificationlistAsync
     *
     * View a list of all sent notifications
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $recipient The recipient whose notifications have to be listed. (optional)
     * @param  int $status The status of the notifications to list. Read, Unread or All. (optional)
     * @param  \DateTime $startdate The start date of the period to filter the notifications. (optional)
     * @param  \DateTime $enddate The end date of the period to filter the notifications. (optional)
     * @param  bool $sentonscreen Specifies whether to list the notifications that were sent on-screen or not. (optional)
     * @param  bool $sentemail Specifies whether to list the notifications that were sent via e-mail or not. (optional)
     * @param  bool $sentsms Specifies whether to list the notifications that were sent via sms or not. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function notificationlistAsync($token, $from, $count, $recipient = null, $status = null, $startdate = null, $enddate = null, $sentonscreen = null, $sentemail = null, $sentsms = null)
    {
        return $this->notificationlistAsyncWithHttpInfo($token, $from, $count, $recipient, $status, $startdate, $enddate, $sentonscreen, $sentemail, $sentsms)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation notificationlistAsyncWithHttpInfo
     *
     * View a list of all sent notifications
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $recipient The recipient whose notifications have to be listed. (optional)
     * @param  int $status The status of the notifications to list. Read, Unread or All. (optional)
     * @param  \DateTime $startdate The start date of the period to filter the notifications. (optional)
     * @param  \DateTime $enddate The end date of the period to filter the notifications. (optional)
     * @param  bool $sentonscreen Specifies whether to list the notifications that were sent on-screen or not. (optional)
     * @param  bool $sentemail Specifies whether to list the notifications that were sent via e-mail or not. (optional)
     * @param  bool $sentsms Specifies whether to list the notifications that were sent via sms or not. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function notificationlistAsyncWithHttpInfo($token, $from, $count, $recipient = null, $status = null, $startdate = null, $enddate = null, $sentonscreen = null, $sentemail = null, $sentsms = null)
    {
        $returnType = '';
        $request = $this->notificationlistRequest($token, $from, $count, $recipient, $status, $startdate, $enddate, $sentonscreen, $sentemail, $sentsms);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'notificationlist'
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $recipient The recipient whose notifications have to be listed. (optional)
     * @param  int $status The status of the notifications to list. Read, Unread or All. (optional)
     * @param  \DateTime $startdate The start date of the period to filter the notifications. (optional)
     * @param  \DateTime $enddate The end date of the period to filter the notifications. (optional)
     * @param  bool $sentonscreen Specifies whether to list the notifications that were sent on-screen or not. (optional)
     * @param  bool $sentemail Specifies whether to list the notifications that were sent via e-mail or not. (optional)
     * @param  bool $sentsms Specifies whether to list the notifications that were sent via sms or not. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function notificationlistRequest($token, $from, $count, $recipient = null, $status = null, $startdate = null, $enddate = null, $sentonscreen = null, $sentemail = null, $sentsms = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling notificationlist'
            );
        }
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling notificationlist'
            );
        }
        // verify the required parameter 'count' is set
        if ($count === null || (is_array($count) && count($count) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $count when calling notificationlist'
            );
        }

        $resourcePath = '/notificationlist';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }
        // query params
        if ($count !== null) {
            if('form' === 'form' && is_array($count)) {
                foreach($count as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['count'] = $count;
            }
        }
        // query params
        if ($recipient !== null) {
            if('form' === 'form' && is_array($recipient)) {
                foreach($recipient as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['recipient'] = $recipient;
            }
        }
        // query params
        if ($status !== null) {
            if('form' === 'form' && is_array($status)) {
                foreach($status as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['status'] = $status;
            }
        }
        // query params
        if ($startdate !== null) {
            if('form' === 'form' && is_array($startdate)) {
                foreach($startdate as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['startdate'] = $startdate;
            }
        }
        // query params
        if ($enddate !== null) {
            if('form' === 'form' && is_array($enddate)) {
                foreach($enddate as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['enddate'] = $enddate;
            }
        }
        // query params
        if ($sentonscreen !== null) {
            if('form' === 'form' && is_array($sentonscreen)) {
                foreach($sentonscreen as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['sentonscreen'] = $sentonscreen;
            }
        }
        // query params
        if ($sentemail !== null) {
            if('form' === 'form' && is_array($sentemail)) {
                foreach($sentemail as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['sentemail'] = $sentemail;
            }
        }
        // query params
        if ($sentsms !== null) {
            if('form' === 'form' && is_array($sentsms)) {
                foreach($sentsms as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['sentsms'] = $sentsms;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation notificationlistmine
     *
     * View all the notifications sent to the current user
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  int $status Specifies the status of the notifications to list. Read, Unread or All. (optional)
     * @param  \DateTime $startdate The start date of the period to filter the notifications. (optional)
     * @param  \DateTime $enddate The end date of the period to filter the notifications. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function notificationlistmine($token, $from, $count, $status = null, $startdate = null, $enddate = null)
    {
        $this->notificationlistmineWithHttpInfo($token, $from, $count, $status, $startdate, $enddate);
    }

    /**
     * Operation notificationlistmineWithHttpInfo
     *
     * View all the notifications sent to the current user
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  int $status Specifies the status of the notifications to list. Read, Unread or All. (optional)
     * @param  \DateTime $startdate The start date of the period to filter the notifications. (optional)
     * @param  \DateTime $enddate The end date of the period to filter the notifications. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function notificationlistmineWithHttpInfo($token, $from, $count, $status = null, $startdate = null, $enddate = null)
    {
        $request = $this->notificationlistmineRequest($token, $from, $count, $status, $startdate, $enddate);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation notificationlistmineAsync
     *
     * View all the notifications sent to the current user
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  int $status Specifies the status of the notifications to list. Read, Unread or All. (optional)
     * @param  \DateTime $startdate The start date of the period to filter the notifications. (optional)
     * @param  \DateTime $enddate The end date of the period to filter the notifications. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function notificationlistmineAsync($token, $from, $count, $status = null, $startdate = null, $enddate = null)
    {
        return $this->notificationlistmineAsyncWithHttpInfo($token, $from, $count, $status, $startdate, $enddate)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation notificationlistmineAsyncWithHttpInfo
     *
     * View all the notifications sent to the current user
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  int $status Specifies the status of the notifications to list. Read, Unread or All. (optional)
     * @param  \DateTime $startdate The start date of the period to filter the notifications. (optional)
     * @param  \DateTime $enddate The end date of the period to filter the notifications. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function notificationlistmineAsyncWithHttpInfo($token, $from, $count, $status = null, $startdate = null, $enddate = null)
    {
        $returnType = '';
        $request = $this->notificationlistmineRequest($token, $from, $count, $status, $startdate, $enddate);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'notificationlistmine'
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  int $status Specifies the status of the notifications to list. Read, Unread or All. (optional)
     * @param  \DateTime $startdate The start date of the period to filter the notifications. (optional)
     * @param  \DateTime $enddate The end date of the period to filter the notifications. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function notificationlistmineRequest($token, $from, $count, $status = null, $startdate = null, $enddate = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling notificationlistmine'
            );
        }
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling notificationlistmine'
            );
        }
        // verify the required parameter 'count' is set
        if ($count === null || (is_array($count) && count($count) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $count when calling notificationlistmine'
            );
        }

        $resourcePath = '/notificationlistmine';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }
        // query params
        if ($count !== null) {
            if('form' === 'form' && is_array($count)) {
                foreach($count as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['count'] = $count;
            }
        }
        // query params
        if ($status !== null) {
            if('form' === 'form' && is_array($status)) {
                foreach($status as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['status'] = $status;
            }
        }
        // query params
        if ($startdate !== null) {
            if('form' === 'form' && is_array($startdate)) {
                foreach($startdate as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['startdate'] = $startdate;
            }
        }
        // query params
        if ($enddate !== null) {
            if('form' === 'form' && is_array($enddate)) {
                foreach($enddate as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['enddate'] = $enddate;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation notificationmarkasread
     *
     * Mark a notification as read
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the notification to mark as read. If not specified all notifications of the logged user will be marked as read. (optional)
     * @param  int $status Specifies the status to filter the notifications. Read, Unread or All. (optional)
     * @param  \DateTime $startdate The start date of the period to filter the notifications. (optional)
     * @param  \DateTime $enddate The end date of the period to filter the notifications. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function notificationmarkasread($token, $id = null, $status = null, $startdate = null, $enddate = null)
    {
        $this->notificationmarkasreadWithHttpInfo($token, $id, $status, $startdate, $enddate);
    }

    /**
     * Operation notificationmarkasreadWithHttpInfo
     *
     * Mark a notification as read
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the notification to mark as read. If not specified all notifications of the logged user will be marked as read. (optional)
     * @param  int $status Specifies the status to filter the notifications. Read, Unread or All. (optional)
     * @param  \DateTime $startdate The start date of the period to filter the notifications. (optional)
     * @param  \DateTime $enddate The end date of the period to filter the notifications. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function notificationmarkasreadWithHttpInfo($token, $id = null, $status = null, $startdate = null, $enddate = null)
    {
        $request = $this->notificationmarkasreadRequest($token, $id, $status, $startdate, $enddate);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation notificationmarkasreadAsync
     *
     * Mark a notification as read
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the notification to mark as read. If not specified all notifications of the logged user will be marked as read. (optional)
     * @param  int $status Specifies the status to filter the notifications. Read, Unread or All. (optional)
     * @param  \DateTime $startdate The start date of the period to filter the notifications. (optional)
     * @param  \DateTime $enddate The end date of the period to filter the notifications. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function notificationmarkasreadAsync($token, $id = null, $status = null, $startdate = null, $enddate = null)
    {
        return $this->notificationmarkasreadAsyncWithHttpInfo($token, $id, $status, $startdate, $enddate)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation notificationmarkasreadAsyncWithHttpInfo
     *
     * Mark a notification as read
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the notification to mark as read. If not specified all notifications of the logged user will be marked as read. (optional)
     * @param  int $status Specifies the status to filter the notifications. Read, Unread or All. (optional)
     * @param  \DateTime $startdate The start date of the period to filter the notifications. (optional)
     * @param  \DateTime $enddate The end date of the period to filter the notifications. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function notificationmarkasreadAsyncWithHttpInfo($token, $id = null, $status = null, $startdate = null, $enddate = null)
    {
        $returnType = '';
        $request = $this->notificationmarkasreadRequest($token, $id, $status, $startdate, $enddate);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'notificationmarkasread'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the notification to mark as read. If not specified all notifications of the logged user will be marked as read. (optional)
     * @param  int $status Specifies the status to filter the notifications. Read, Unread or All. (optional)
     * @param  \DateTime $startdate The start date of the period to filter the notifications. (optional)
     * @param  \DateTime $enddate The end date of the period to filter the notifications. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function notificationmarkasreadRequest($token, $id = null, $status = null, $startdate = null, $enddate = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling notificationmarkasread'
            );
        }

        $resourcePath = '/notificationmarkasread';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($id !== null) {
            if('form' === 'form' && is_array($id)) {
                foreach($id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['id'] = $id;
            }
        }
        // query params
        if ($status !== null) {
            if('form' === 'form' && is_array($status)) {
                foreach($status as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['status'] = $status;
            }
        }
        // query params
        if ($startdate !== null) {
            if('form' === 'form' && is_array($startdate)) {
                foreach($startdate as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['startdate'] = $startdate;
            }
        }
        // query params
        if ($enddate !== null) {
            if('form' === 'form' && is_array($enddate)) {
                foreach($enddate as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['enddate'] = $enddate;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation notificationmarkasunread
     *
     * Mark a notification as unread
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the notification to mark as unread. If not specified all notifications of the logged user will be marked as unread. (optional)
     * @param  int $status Specifies the status to filter the notifications. Read, Unread or All. (optional)
     * @param  \DateTime $startdate The start date of the period to filter the notifications. (optional)
     * @param  \DateTime $enddate The end date of the period to filter the notifications. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function notificationmarkasunread($token, $id = null, $status = null, $startdate = null, $enddate = null)
    {
        $this->notificationmarkasunreadWithHttpInfo($token, $id, $status, $startdate, $enddate);
    }

    /**
     * Operation notificationmarkasunreadWithHttpInfo
     *
     * Mark a notification as unread
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the notification to mark as unread. If not specified all notifications of the logged user will be marked as unread. (optional)
     * @param  int $status Specifies the status to filter the notifications. Read, Unread or All. (optional)
     * @param  \DateTime $startdate The start date of the period to filter the notifications. (optional)
     * @param  \DateTime $enddate The end date of the period to filter the notifications. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function notificationmarkasunreadWithHttpInfo($token, $id = null, $status = null, $startdate = null, $enddate = null)
    {
        $request = $this->notificationmarkasunreadRequest($token, $id, $status, $startdate, $enddate);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation notificationmarkasunreadAsync
     *
     * Mark a notification as unread
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the notification to mark as unread. If not specified all notifications of the logged user will be marked as unread. (optional)
     * @param  int $status Specifies the status to filter the notifications. Read, Unread or All. (optional)
     * @param  \DateTime $startdate The start date of the period to filter the notifications. (optional)
     * @param  \DateTime $enddate The end date of the period to filter the notifications. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function notificationmarkasunreadAsync($token, $id = null, $status = null, $startdate = null, $enddate = null)
    {
        return $this->notificationmarkasunreadAsyncWithHttpInfo($token, $id, $status, $startdate, $enddate)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation notificationmarkasunreadAsyncWithHttpInfo
     *
     * Mark a notification as unread
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the notification to mark as unread. If not specified all notifications of the logged user will be marked as unread. (optional)
     * @param  int $status Specifies the status to filter the notifications. Read, Unread or All. (optional)
     * @param  \DateTime $startdate The start date of the period to filter the notifications. (optional)
     * @param  \DateTime $enddate The end date of the period to filter the notifications. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function notificationmarkasunreadAsyncWithHttpInfo($token, $id = null, $status = null, $startdate = null, $enddate = null)
    {
        $returnType = '';
        $request = $this->notificationmarkasunreadRequest($token, $id, $status, $startdate, $enddate);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'notificationmarkasunread'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the notification to mark as unread. If not specified all notifications of the logged user will be marked as unread. (optional)
     * @param  int $status Specifies the status to filter the notifications. Read, Unread or All. (optional)
     * @param  \DateTime $startdate The start date of the period to filter the notifications. (optional)
     * @param  \DateTime $enddate The end date of the period to filter the notifications. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function notificationmarkasunreadRequest($token, $id = null, $status = null, $startdate = null, $enddate = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling notificationmarkasunread'
            );
        }

        $resourcePath = '/notificationmarkasunread';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($id !== null) {
            if('form' === 'form' && is_array($id)) {
                foreach($id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['id'] = $id;
            }
        }
        // query params
        if ($status !== null) {
            if('form' === 'form' && is_array($status)) {
                foreach($status as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['status'] = $status;
            }
        }
        // query params
        if ($startdate !== null) {
            if('form' === 'form' && is_array($startdate)) {
                foreach($startdate as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['startdate'] = $startdate;
            }
        }
        // query params
        if ($enddate !== null) {
            if('form' === 'form' && is_array($enddate)) {
                foreach($enddate as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['enddate'] = $enddate;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation notificationsend
     *
     * Send notifications on screen, via email or text to users
     *
     * @param  string $token The authentication token. (required)
     * @param  bool $emailenabled Whether send the notification via email. (required)
     * @param  bool $onscreenenabled Whether to display the notification on screen. (required)
     * @param  bool $smsenabled Whether to send the notification via text message. (required)
     * @param  string $title Notification title. (required)
     * @param  string $tousers Comma-separated Ids of users to send the notification. (optional)
     * @param  string $togroups Comma-separated Ids of user groups to send the notification. (optional)
     * @param  string $onscreenbody Body of the message for on-screen display. (optional)
     * @param  string $onscreenclick What to do when the notification is clicked. Valid values: hide, view, url. (optional)
     * @param  string $onscreenurl Url to redirect the user, if onscreenclick&#x3D;url. (optional)
     * @param  string $onscreenclass How to display the notification. Valid values: info, success, warning, error (optional)
     * @param  int $onscreenduration Time in seconds to display the notification. (optional)
     * @param  int $showonstation Whether to show the notification in the sign-in station. (optional)
     * @param  string $emailfromname Name of the email sender. (optional)
     * @param  string $emailfrom Reply-to email. (optional)
     * @param  string $emailsubject Subject of the email. (optional)
     * @param  string $emailbody Body of the email. (optional)
     * @param  string $textmessagebody Message for SMS. Max 160 characters. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function notificationsend($token, $emailenabled, $onscreenenabled, $smsenabled, $title, $tousers = null, $togroups = null, $onscreenbody = null, $onscreenclick = null, $onscreenurl = null, $onscreenclass = null, $onscreenduration = null, $showonstation = null, $emailfromname = null, $emailfrom = null, $emailsubject = null, $emailbody = null, $textmessagebody = null)
    {
        $this->notificationsendWithHttpInfo($token, $emailenabled, $onscreenenabled, $smsenabled, $title, $tousers, $togroups, $onscreenbody, $onscreenclick, $onscreenurl, $onscreenclass, $onscreenduration, $showonstation, $emailfromname, $emailfrom, $emailsubject, $emailbody, $textmessagebody);
    }

    /**
     * Operation notificationsendWithHttpInfo
     *
     * Send notifications on screen, via email or text to users
     *
     * @param  string $token The authentication token. (required)
     * @param  bool $emailenabled Whether send the notification via email. (required)
     * @param  bool $onscreenenabled Whether to display the notification on screen. (required)
     * @param  bool $smsenabled Whether to send the notification via text message. (required)
     * @param  string $title Notification title. (required)
     * @param  string $tousers Comma-separated Ids of users to send the notification. (optional)
     * @param  string $togroups Comma-separated Ids of user groups to send the notification. (optional)
     * @param  string $onscreenbody Body of the message for on-screen display. (optional)
     * @param  string $onscreenclick What to do when the notification is clicked. Valid values: hide, view, url. (optional)
     * @param  string $onscreenurl Url to redirect the user, if onscreenclick&#x3D;url. (optional)
     * @param  string $onscreenclass How to display the notification. Valid values: info, success, warning, error (optional)
     * @param  int $onscreenduration Time in seconds to display the notification. (optional)
     * @param  int $showonstation Whether to show the notification in the sign-in station. (optional)
     * @param  string $emailfromname Name of the email sender. (optional)
     * @param  string $emailfrom Reply-to email. (optional)
     * @param  string $emailsubject Subject of the email. (optional)
     * @param  string $emailbody Body of the email. (optional)
     * @param  string $textmessagebody Message for SMS. Max 160 characters. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function notificationsendWithHttpInfo($token, $emailenabled, $onscreenenabled, $smsenabled, $title, $tousers = null, $togroups = null, $onscreenbody = null, $onscreenclick = null, $onscreenurl = null, $onscreenclass = null, $onscreenduration = null, $showonstation = null, $emailfromname = null, $emailfrom = null, $emailsubject = null, $emailbody = null, $textmessagebody = null)
    {
        $request = $this->notificationsendRequest($token, $emailenabled, $onscreenenabled, $smsenabled, $title, $tousers, $togroups, $onscreenbody, $onscreenclick, $onscreenurl, $onscreenclass, $onscreenduration, $showonstation, $emailfromname, $emailfrom, $emailsubject, $emailbody, $textmessagebody);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation notificationsendAsync
     *
     * Send notifications on screen, via email or text to users
     *
     * @param  string $token The authentication token. (required)
     * @param  bool $emailenabled Whether send the notification via email. (required)
     * @param  bool $onscreenenabled Whether to display the notification on screen. (required)
     * @param  bool $smsenabled Whether to send the notification via text message. (required)
     * @param  string $title Notification title. (required)
     * @param  string $tousers Comma-separated Ids of users to send the notification. (optional)
     * @param  string $togroups Comma-separated Ids of user groups to send the notification. (optional)
     * @param  string $onscreenbody Body of the message for on-screen display. (optional)
     * @param  string $onscreenclick What to do when the notification is clicked. Valid values: hide, view, url. (optional)
     * @param  string $onscreenurl Url to redirect the user, if onscreenclick&#x3D;url. (optional)
     * @param  string $onscreenclass How to display the notification. Valid values: info, success, warning, error (optional)
     * @param  int $onscreenduration Time in seconds to display the notification. (optional)
     * @param  int $showonstation Whether to show the notification in the sign-in station. (optional)
     * @param  string $emailfromname Name of the email sender. (optional)
     * @param  string $emailfrom Reply-to email. (optional)
     * @param  string $emailsubject Subject of the email. (optional)
     * @param  string $emailbody Body of the email. (optional)
     * @param  string $textmessagebody Message for SMS. Max 160 characters. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function notificationsendAsync($token, $emailenabled, $onscreenenabled, $smsenabled, $title, $tousers = null, $togroups = null, $onscreenbody = null, $onscreenclick = null, $onscreenurl = null, $onscreenclass = null, $onscreenduration = null, $showonstation = null, $emailfromname = null, $emailfrom = null, $emailsubject = null, $emailbody = null, $textmessagebody = null)
    {
        return $this->notificationsendAsyncWithHttpInfo($token, $emailenabled, $onscreenenabled, $smsenabled, $title, $tousers, $togroups, $onscreenbody, $onscreenclick, $onscreenurl, $onscreenclass, $onscreenduration, $showonstation, $emailfromname, $emailfrom, $emailsubject, $emailbody, $textmessagebody)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation notificationsendAsyncWithHttpInfo
     *
     * Send notifications on screen, via email or text to users
     *
     * @param  string $token The authentication token. (required)
     * @param  bool $emailenabled Whether send the notification via email. (required)
     * @param  bool $onscreenenabled Whether to display the notification on screen. (required)
     * @param  bool $smsenabled Whether to send the notification via text message. (required)
     * @param  string $title Notification title. (required)
     * @param  string $tousers Comma-separated Ids of users to send the notification. (optional)
     * @param  string $togroups Comma-separated Ids of user groups to send the notification. (optional)
     * @param  string $onscreenbody Body of the message for on-screen display. (optional)
     * @param  string $onscreenclick What to do when the notification is clicked. Valid values: hide, view, url. (optional)
     * @param  string $onscreenurl Url to redirect the user, if onscreenclick&#x3D;url. (optional)
     * @param  string $onscreenclass How to display the notification. Valid values: info, success, warning, error (optional)
     * @param  int $onscreenduration Time in seconds to display the notification. (optional)
     * @param  int $showonstation Whether to show the notification in the sign-in station. (optional)
     * @param  string $emailfromname Name of the email sender. (optional)
     * @param  string $emailfrom Reply-to email. (optional)
     * @param  string $emailsubject Subject of the email. (optional)
     * @param  string $emailbody Body of the email. (optional)
     * @param  string $textmessagebody Message for SMS. Max 160 characters. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function notificationsendAsyncWithHttpInfo($token, $emailenabled, $onscreenenabled, $smsenabled, $title, $tousers = null, $togroups = null, $onscreenbody = null, $onscreenclick = null, $onscreenurl = null, $onscreenclass = null, $onscreenduration = null, $showonstation = null, $emailfromname = null, $emailfrom = null, $emailsubject = null, $emailbody = null, $textmessagebody = null)
    {
        $returnType = '';
        $request = $this->notificationsendRequest($token, $emailenabled, $onscreenenabled, $smsenabled, $title, $tousers, $togroups, $onscreenbody, $onscreenclick, $onscreenurl, $onscreenclass, $onscreenduration, $showonstation, $emailfromname, $emailfrom, $emailsubject, $emailbody, $textmessagebody);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'notificationsend'
     *
     * @param  string $token The authentication token. (required)
     * @param  bool $emailenabled Whether send the notification via email. (required)
     * @param  bool $onscreenenabled Whether to display the notification on screen. (required)
     * @param  bool $smsenabled Whether to send the notification via text message. (required)
     * @param  string $title Notification title. (required)
     * @param  string $tousers Comma-separated Ids of users to send the notification. (optional)
     * @param  string $togroups Comma-separated Ids of user groups to send the notification. (optional)
     * @param  string $onscreenbody Body of the message for on-screen display. (optional)
     * @param  string $onscreenclick What to do when the notification is clicked. Valid values: hide, view, url. (optional)
     * @param  string $onscreenurl Url to redirect the user, if onscreenclick&#x3D;url. (optional)
     * @param  string $onscreenclass How to display the notification. Valid values: info, success, warning, error (optional)
     * @param  int $onscreenduration Time in seconds to display the notification. (optional)
     * @param  int $showonstation Whether to show the notification in the sign-in station. (optional)
     * @param  string $emailfromname Name of the email sender. (optional)
     * @param  string $emailfrom Reply-to email. (optional)
     * @param  string $emailsubject Subject of the email. (optional)
     * @param  string $emailbody Body of the email. (optional)
     * @param  string $textmessagebody Message for SMS. Max 160 characters. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function notificationsendRequest($token, $emailenabled, $onscreenenabled, $smsenabled, $title, $tousers = null, $togroups = null, $onscreenbody = null, $onscreenclick = null, $onscreenurl = null, $onscreenclass = null, $onscreenduration = null, $showonstation = null, $emailfromname = null, $emailfrom = null, $emailsubject = null, $emailbody = null, $textmessagebody = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling notificationsend'
            );
        }
        // verify the required parameter 'emailenabled' is set
        if ($emailenabled === null || (is_array($emailenabled) && count($emailenabled) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $emailenabled when calling notificationsend'
            );
        }
        // verify the required parameter 'onscreenenabled' is set
        if ($onscreenenabled === null || (is_array($onscreenenabled) && count($onscreenenabled) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $onscreenenabled when calling notificationsend'
            );
        }
        // verify the required parameter 'smsenabled' is set
        if ($smsenabled === null || (is_array($smsenabled) && count($smsenabled) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $smsenabled when calling notificationsend'
            );
        }
        // verify the required parameter 'title' is set
        if ($title === null || (is_array($title) && count($title) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $title when calling notificationsend'
            );
        }

        $resourcePath = '/notificationsend';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($tousers !== null) {
            if('form' === 'form' && is_array($tousers)) {
                foreach($tousers as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['tousers'] = $tousers;
            }
        }
        // query params
        if ($togroups !== null) {
            if('form' === 'form' && is_array($togroups)) {
                foreach($togroups as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['togroups'] = $togroups;
            }
        }
        // query params
        if ($emailenabled !== null) {
            if('form' === 'form' && is_array($emailenabled)) {
                foreach($emailenabled as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['emailenabled'] = $emailenabled;
            }
        }
        // query params
        if ($onscreenenabled !== null) {
            if('form' === 'form' && is_array($onscreenenabled)) {
                foreach($onscreenenabled as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['onscreenenabled'] = $onscreenenabled;
            }
        }
        // query params
        if ($smsenabled !== null) {
            if('form' === 'form' && is_array($smsenabled)) {
                foreach($smsenabled as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['smsenabled'] = $smsenabled;
            }
        }
        // query params
        if ($title !== null) {
            if('form' === 'form' && is_array($title)) {
                foreach($title as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['title'] = $title;
            }
        }
        // query params
        if ($onscreenbody !== null) {
            if('form' === 'form' && is_array($onscreenbody)) {
                foreach($onscreenbody as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['onscreenbody'] = $onscreenbody;
            }
        }
        // query params
        if ($onscreenclick !== null) {
            if('form' === 'form' && is_array($onscreenclick)) {
                foreach($onscreenclick as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['onscreenclick'] = $onscreenclick;
            }
        }
        // query params
        if ($onscreenurl !== null) {
            if('form' === 'form' && is_array($onscreenurl)) {
                foreach($onscreenurl as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['onscreenurl'] = $onscreenurl;
            }
        }
        // query params
        if ($onscreenclass !== null) {
            if('form' === 'form' && is_array($onscreenclass)) {
                foreach($onscreenclass as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['onscreenclass'] = $onscreenclass;
            }
        }
        // query params
        if ($onscreenduration !== null) {
            if('form' === 'form' && is_array($onscreenduration)) {
                foreach($onscreenduration as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['onscreenduration'] = $onscreenduration;
            }
        }
        // query params
        if ($showonstation !== null) {
            if('form' === 'form' && is_array($showonstation)) {
                foreach($showonstation as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['showonstation'] = $showonstation;
            }
        }
        // query params
        if ($emailfromname !== null) {
            if('form' === 'form' && is_array($emailfromname)) {
                foreach($emailfromname as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['emailfromname'] = $emailfromname;
            }
        }
        // query params
        if ($emailfrom !== null) {
            if('form' === 'form' && is_array($emailfrom)) {
                foreach($emailfrom as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['emailfrom'] = $emailfrom;
            }
        }
        // query params
        if ($emailsubject !== null) {
            if('form' === 'form' && is_array($emailsubject)) {
                foreach($emailsubject as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['emailsubject'] = $emailsubject;
            }
        }
        // query params
        if ($emailbody !== null) {
            if('form' === 'form' && is_array($emailbody)) {
                foreach($emailbody as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['emailbody'] = $emailbody;
            }
        }
        // query params
        if ($textmessagebody !== null) {
            if('form' === 'form' && is_array($textmessagebody)) {
                foreach($textmessagebody as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['textmessagebody'] = $textmessagebody;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation notificationsendonscreen
     *
     * Send on-screen notifications
     *
     * @param  string $token The authentication token. (required)
     * @param  string $notification The ID of the notification to send. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function notificationsendonscreen($token, $notification)
    {
        $this->notificationsendonscreenWithHttpInfo($token, $notification);
    }

    /**
     * Operation notificationsendonscreenWithHttpInfo
     *
     * Send on-screen notifications
     *
     * @param  string $token The authentication token. (required)
     * @param  string $notification The ID of the notification to send. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function notificationsendonscreenWithHttpInfo($token, $notification)
    {
        $request = $this->notificationsendonscreenRequest($token, $notification);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation notificationsendonscreenAsync
     *
     * Send on-screen notifications
     *
     * @param  string $token The authentication token. (required)
     * @param  string $notification The ID of the notification to send. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function notificationsendonscreenAsync($token, $notification)
    {
        return $this->notificationsendonscreenAsyncWithHttpInfo($token, $notification)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation notificationsendonscreenAsyncWithHttpInfo
     *
     * Send on-screen notifications
     *
     * @param  string $token The authentication token. (required)
     * @param  string $notification The ID of the notification to send. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function notificationsendonscreenAsyncWithHttpInfo($token, $notification)
    {
        $returnType = '';
        $request = $this->notificationsendonscreenRequest($token, $notification);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'notificationsendonscreen'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $notification The ID of the notification to send. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function notificationsendonscreenRequest($token, $notification)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling notificationsendonscreen'
            );
        }
        // verify the required parameter 'notification' is set
        if ($notification === null || (is_array($notification) && count($notification) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $notification when calling notificationsendonscreen'
            );
        }

        $resourcePath = '/notificationsendonscreen';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($notification !== null) {
            if('form' === 'form' && is_array($notification)) {
                foreach($notification as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['notification'] = $notification;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation notificationtopicdelete
     *
     * Delete a notification topic
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the notification topic to delete. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function notificationtopicdelete($token, $id)
    {
        $this->notificationtopicdeleteWithHttpInfo($token, $id);
    }

    /**
     * Operation notificationtopicdeleteWithHttpInfo
     *
     * Delete a notification topic
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the notification topic to delete. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function notificationtopicdeleteWithHttpInfo($token, $id)
    {
        $request = $this->notificationtopicdeleteRequest($token, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation notificationtopicdeleteAsync
     *
     * Delete a notification topic
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the notification topic to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function notificationtopicdeleteAsync($token, $id)
    {
        return $this->notificationtopicdeleteAsyncWithHttpInfo($token, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation notificationtopicdeleteAsyncWithHttpInfo
     *
     * Delete a notification topic
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the notification topic to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function notificationtopicdeleteAsyncWithHttpInfo($token, $id)
    {
        $returnType = '';
        $request = $this->notificationtopicdeleteRequest($token, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'notificationtopicdelete'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the notification topic to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function notificationtopicdeleteRequest($token, $id)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling notificationtopicdelete'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling notificationtopicdelete'
            );
        }

        $resourcePath = '/notificationtopicdelete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($id !== null) {
            if('form' === 'form' && is_array($id)) {
                foreach($id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['id'] = $id;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation notificationtopicget
     *
     * Search and view details of a notification topic
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the notification topic to get. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function notificationtopicget($token, $id)
    {
        $this->notificationtopicgetWithHttpInfo($token, $id);
    }

    /**
     * Operation notificationtopicgetWithHttpInfo
     *
     * Search and view details of a notification topic
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the notification topic to get. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function notificationtopicgetWithHttpInfo($token, $id)
    {
        $request = $this->notificationtopicgetRequest($token, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation notificationtopicgetAsync
     *
     * Search and view details of a notification topic
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the notification topic to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function notificationtopicgetAsync($token, $id)
    {
        return $this->notificationtopicgetAsyncWithHttpInfo($token, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation notificationtopicgetAsyncWithHttpInfo
     *
     * Search and view details of a notification topic
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the notification topic to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function notificationtopicgetAsyncWithHttpInfo($token, $id)
    {
        $returnType = '';
        $request = $this->notificationtopicgetRequest($token, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'notificationtopicget'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the notification topic to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function notificationtopicgetRequest($token, $id)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling notificationtopicget'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling notificationtopicget'
            );
        }

        $resourcePath = '/notificationtopicget';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($id !== null) {
            if('form' === 'form' && is_array($id)) {
                foreach($id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['id'] = $id;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation notificationtopiclist
     *
     * List all the notification topics
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function notificationtopiclist($token, $from, $count)
    {
        $this->notificationtopiclistWithHttpInfo($token, $from, $count);
    }

    /**
     * Operation notificationtopiclistWithHttpInfo
     *
     * List all the notification topics
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function notificationtopiclistWithHttpInfo($token, $from, $count)
    {
        $request = $this->notificationtopiclistRequest($token, $from, $count);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation notificationtopiclistAsync
     *
     * List all the notification topics
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function notificationtopiclistAsync($token, $from, $count)
    {
        return $this->notificationtopiclistAsyncWithHttpInfo($token, $from, $count)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation notificationtopiclistAsyncWithHttpInfo
     *
     * List all the notification topics
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function notificationtopiclistAsyncWithHttpInfo($token, $from, $count)
    {
        $returnType = '';
        $request = $this->notificationtopiclistRequest($token, $from, $count);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'notificationtopiclist'
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function notificationtopiclistRequest($token, $from, $count)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling notificationtopiclist'
            );
        }
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling notificationtopiclist'
            );
        }
        // verify the required parameter 'count' is set
        if ($count === null || (is_array($count) && count($count) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $count when calling notificationtopiclist'
            );
        }

        $resourcePath = '/notificationtopiclist';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }
        // query params
        if ($count !== null) {
            if('form' === 'form' && is_array($count)) {
                foreach($count as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['count'] = $count;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation notificationtopiclistsubscribe
     *
     * List all the notification topics available to subscribe
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function notificationtopiclistsubscribe($token)
    {
        $this->notificationtopiclistsubscribeWithHttpInfo($token);
    }

    /**
     * Operation notificationtopiclistsubscribeWithHttpInfo
     *
     * List all the notification topics available to subscribe
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function notificationtopiclistsubscribeWithHttpInfo($token)
    {
        $request = $this->notificationtopiclistsubscribeRequest($token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation notificationtopiclistsubscribeAsync
     *
     * List all the notification topics available to subscribe
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function notificationtopiclistsubscribeAsync($token)
    {
        return $this->notificationtopiclistsubscribeAsyncWithHttpInfo($token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation notificationtopiclistsubscribeAsyncWithHttpInfo
     *
     * List all the notification topics available to subscribe
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function notificationtopiclistsubscribeAsyncWithHttpInfo($token)
    {
        $returnType = '';
        $request = $this->notificationtopiclistsubscribeRequest($token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'notificationtopiclistsubscribe'
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function notificationtopiclistsubscribeRequest($token)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling notificationtopiclistsubscribe'
            );
        }

        $resourcePath = '/notificationtopiclistsubscribe';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation notificationtopicsave
     *
     * Create or edit a notification topic
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function notificationtopicsave($unknown_base_type = null)
    {
        $this->notificationtopicsaveWithHttpInfo($unknown_base_type);
    }

    /**
     * Operation notificationtopicsaveWithHttpInfo
     *
     * Create or edit a notification topic
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function notificationtopicsaveWithHttpInfo($unknown_base_type = null)
    {
        $request = $this->notificationtopicsaveRequest($unknown_base_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation notificationtopicsaveAsync
     *
     * Create or edit a notification topic
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function notificationtopicsaveAsync($unknown_base_type = null)
    {
        return $this->notificationtopicsaveAsyncWithHttpInfo($unknown_base_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation notificationtopicsaveAsyncWithHttpInfo
     *
     * Create or edit a notification topic
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function notificationtopicsaveAsyncWithHttpInfo($unknown_base_type = null)
    {
        $returnType = '';
        $request = $this->notificationtopicsaveRequest($unknown_base_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'notificationtopicsave'
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function notificationtopicsaveRequest($unknown_base_type = null)
    {

        $resourcePath = '/notificationtopicsave';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($unknown_base_type)) {
            $_tempBody = $unknown_base_type;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pushderegister
     *
     * Deregisters the current device to receive push notifications
     *
     * @param  string $devicetoken The device token where to send the notification. (required)
     * @param  string $platform Either ios or android (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function pushderegister($devicetoken, $platform)
    {
        $this->pushderegisterWithHttpInfo($devicetoken, $platform);
    }

    /**
     * Operation pushderegisterWithHttpInfo
     *
     * Deregisters the current device to receive push notifications
     *
     * @param  string $devicetoken The device token where to send the notification. (required)
     * @param  string $platform Either ios or android (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function pushderegisterWithHttpInfo($devicetoken, $platform)
    {
        $request = $this->pushderegisterRequest($devicetoken, $platform);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation pushderegisterAsync
     *
     * Deregisters the current device to receive push notifications
     *
     * @param  string $devicetoken The device token where to send the notification. (required)
     * @param  string $platform Either ios or android (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pushderegisterAsync($devicetoken, $platform)
    {
        return $this->pushderegisterAsyncWithHttpInfo($devicetoken, $platform)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pushderegisterAsyncWithHttpInfo
     *
     * Deregisters the current device to receive push notifications
     *
     * @param  string $devicetoken The device token where to send the notification. (required)
     * @param  string $platform Either ios or android (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pushderegisterAsyncWithHttpInfo($devicetoken, $platform)
    {
        $returnType = '';
        $request = $this->pushderegisterRequest($devicetoken, $platform);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pushderegister'
     *
     * @param  string $devicetoken The device token where to send the notification. (required)
     * @param  string $platform Either ios or android (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pushderegisterRequest($devicetoken, $platform)
    {
        // verify the required parameter 'devicetoken' is set
        if ($devicetoken === null || (is_array($devicetoken) && count($devicetoken) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $devicetoken when calling pushderegister'
            );
        }
        // verify the required parameter 'platform' is set
        if ($platform === null || (is_array($platform) && count($platform) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $platform when calling pushderegister'
            );
        }

        $resourcePath = '/pushderegister';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($devicetoken !== null) {
            if('form' === 'form' && is_array($devicetoken)) {
                foreach($devicetoken as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['devicetoken'] = $devicetoken;
            }
        }
        // query params
        if ($platform !== null) {
            if('form' === 'form' && is_array($platform)) {
                foreach($platform as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['platform'] = $platform;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pushregister
     *
     * Registers the current device to receive push notifications
     *
     * @param  string $devicetoken The device token where to send the notification. (required)
     * @param  string $platform Either ios or android (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function pushregister($devicetoken, $platform)
    {
        $this->pushregisterWithHttpInfo($devicetoken, $platform);
    }

    /**
     * Operation pushregisterWithHttpInfo
     *
     * Registers the current device to receive push notifications
     *
     * @param  string $devicetoken The device token where to send the notification. (required)
     * @param  string $platform Either ios or android (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function pushregisterWithHttpInfo($devicetoken, $platform)
    {
        $request = $this->pushregisterRequest($devicetoken, $platform);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation pushregisterAsync
     *
     * Registers the current device to receive push notifications
     *
     * @param  string $devicetoken The device token where to send the notification. (required)
     * @param  string $platform Either ios or android (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pushregisterAsync($devicetoken, $platform)
    {
        return $this->pushregisterAsyncWithHttpInfo($devicetoken, $platform)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pushregisterAsyncWithHttpInfo
     *
     * Registers the current device to receive push notifications
     *
     * @param  string $devicetoken The device token where to send the notification. (required)
     * @param  string $platform Either ios or android (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pushregisterAsyncWithHttpInfo($devicetoken, $platform)
    {
        $returnType = '';
        $request = $this->pushregisterRequest($devicetoken, $platform);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pushregister'
     *
     * @param  string $devicetoken The device token where to send the notification. (required)
     * @param  string $platform Either ios or android (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pushregisterRequest($devicetoken, $platform)
    {
        // verify the required parameter 'devicetoken' is set
        if ($devicetoken === null || (is_array($devicetoken) && count($devicetoken) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $devicetoken when calling pushregister'
            );
        }
        // verify the required parameter 'platform' is set
        if ($platform === null || (is_array($platform) && count($platform) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $platform when calling pushregister'
            );
        }

        $resourcePath = '/pushregister';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($devicetoken !== null) {
            if('form' === 'form' && is_array($devicetoken)) {
                foreach($devicetoken as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['devicetoken'] = $devicetoken;
            }
        }
        // query params
        if ($platform !== null) {
            if('form' === 'form' && is_array($platform)) {
                foreach($platform as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['platform'] = $platform;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation qrlabelsprint
     *
     * Print and email QR labels
     *
     * @param  string $token The authentication token. (required)
     * @param  string $user The id of the user whose label needs to be printed. (optional)
     * @param  string $group The id of the group whose members&#39; labels need to be printed. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function qrlabelsprint($token, $user = null, $group = null)
    {
        $this->qrlabelsprintWithHttpInfo($token, $user, $group);
    }

    /**
     * Operation qrlabelsprintWithHttpInfo
     *
     * Print and email QR labels
     *
     * @param  string $token The authentication token. (required)
     * @param  string $user The id of the user whose label needs to be printed. (optional)
     * @param  string $group The id of the group whose members&#39; labels need to be printed. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function qrlabelsprintWithHttpInfo($token, $user = null, $group = null)
    {
        $request = $this->qrlabelsprintRequest($token, $user, $group);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation qrlabelsprintAsync
     *
     * Print and email QR labels
     *
     * @param  string $token The authentication token. (required)
     * @param  string $user The id of the user whose label needs to be printed. (optional)
     * @param  string $group The id of the group whose members&#39; labels need to be printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function qrlabelsprintAsync($token, $user = null, $group = null)
    {
        return $this->qrlabelsprintAsyncWithHttpInfo($token, $user, $group)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation qrlabelsprintAsyncWithHttpInfo
     *
     * Print and email QR labels
     *
     * @param  string $token The authentication token. (required)
     * @param  string $user The id of the user whose label needs to be printed. (optional)
     * @param  string $group The id of the group whose members&#39; labels need to be printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function qrlabelsprintAsyncWithHttpInfo($token, $user = null, $group = null)
    {
        $returnType = '';
        $request = $this->qrlabelsprintRequest($token, $user, $group);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'qrlabelsprint'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $user The id of the user whose label needs to be printed. (optional)
     * @param  string $group The id of the group whose members&#39; labels need to be printed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function qrlabelsprintRequest($token, $user = null, $group = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling qrlabelsprint'
            );
        }

        $resourcePath = '/qrlabelsprint';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($user !== null) {
            if('form' === 'form' && is_array($user)) {
                foreach($user as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['user'] = $user;
            }
        }
        // query params
        if ($group !== null) {
            if('form' === 'form' && is_array($group)) {
                foreach($group as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['group'] = $group;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation qrloginget
     *
     * Gets an image of a QR token
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function qrloginget($token)
    {
        $this->qrlogingetWithHttpInfo($token);
    }

    /**
     * Operation qrlogingetWithHttpInfo
     *
     * Gets an image of a QR token
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function qrlogingetWithHttpInfo($token)
    {
        $request = $this->qrlogingetRequest($token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation qrlogingetAsync
     *
     * Gets an image of a QR token
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function qrlogingetAsync($token)
    {
        return $this->qrlogingetAsyncWithHttpInfo($token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation qrlogingetAsyncWithHttpInfo
     *
     * Gets an image of a QR token
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function qrlogingetAsyncWithHttpInfo($token)
    {
        $returnType = '';
        $request = $this->qrlogingetRequest($token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'qrloginget'
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function qrlogingetRequest($token)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling qrloginget'
            );
        }

        $resourcePath = '/qrloginget';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation qrloginlogin
     *
     * Login
     *
     * @param  string $onetimetoken The token read from the QR code. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function qrloginlogin($onetimetoken)
    {
        $this->qrloginloginWithHttpInfo($onetimetoken);
    }

    /**
     * Operation qrloginloginWithHttpInfo
     *
     * Login
     *
     * @param  string $onetimetoken The token read from the QR code. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function qrloginloginWithHttpInfo($onetimetoken)
    {
        $request = $this->qrloginloginRequest($onetimetoken);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation qrloginloginAsync
     *
     * Login
     *
     * @param  string $onetimetoken The token read from the QR code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function qrloginloginAsync($onetimetoken)
    {
        return $this->qrloginloginAsyncWithHttpInfo($onetimetoken)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation qrloginloginAsyncWithHttpInfo
     *
     * Login
     *
     * @param  string $onetimetoken The token read from the QR code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function qrloginloginAsyncWithHttpInfo($onetimetoken)
    {
        $returnType = '';
        $request = $this->qrloginloginRequest($onetimetoken);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'qrloginlogin'
     *
     * @param  string $onetimetoken The token read from the QR code. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function qrloginloginRequest($onetimetoken)
    {
        // verify the required parameter 'onetimetoken' is set
        if ($onetimetoken === null || (is_array($onetimetoken) && count($onetimetoken) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $onetimetoken when calling qrloginlogin'
            );
        }

        $resourcePath = '/qrloginlogin';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($onetimetoken !== null) {
            if('form' === 'form' && is_array($onetimetoken)) {
                foreach($onetimetoken as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['onetimetoken'] = $onetimetoken;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation quickpaneldeletewidget
     *
     * Deletes a widget from the Quick Panel
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the widget. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function quickpaneldeletewidget($token, $id)
    {
        $this->quickpaneldeletewidgetWithHttpInfo($token, $id);
    }

    /**
     * Operation quickpaneldeletewidgetWithHttpInfo
     *
     * Deletes a widget from the Quick Panel
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the widget. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function quickpaneldeletewidgetWithHttpInfo($token, $id)
    {
        $request = $this->quickpaneldeletewidgetRequest($token, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation quickpaneldeletewidgetAsync
     *
     * Deletes a widget from the Quick Panel
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the widget. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function quickpaneldeletewidgetAsync($token, $id)
    {
        return $this->quickpaneldeletewidgetAsyncWithHttpInfo($token, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation quickpaneldeletewidgetAsyncWithHttpInfo
     *
     * Deletes a widget from the Quick Panel
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the widget. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function quickpaneldeletewidgetAsyncWithHttpInfo($token, $id)
    {
        $returnType = '';
        $request = $this->quickpaneldeletewidgetRequest($token, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'quickpaneldeletewidget'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the widget. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function quickpaneldeletewidgetRequest($token, $id)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling quickpaneldeletewidget'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling quickpaneldeletewidget'
            );
        }

        $resourcePath = '/quickpaneldeletewidget';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($id !== null) {
            if('form' === 'form' && is_array($id)) {
                foreach($id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['id'] = $id;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation quickpanelfetchwidget
     *
     * Fetches the information for a specific widget.
     *
     * @param  string $token The authentication token. (required)
     * @param  string $widgetid The ID of the data to fetch it&#39;s data. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function quickpanelfetchwidget($token, $widgetid)
    {
        $this->quickpanelfetchwidgetWithHttpInfo($token, $widgetid);
    }

    /**
     * Operation quickpanelfetchwidgetWithHttpInfo
     *
     * Fetches the information for a specific widget.
     *
     * @param  string $token The authentication token. (required)
     * @param  string $widgetid The ID of the data to fetch it&#39;s data. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function quickpanelfetchwidgetWithHttpInfo($token, $widgetid)
    {
        $request = $this->quickpanelfetchwidgetRequest($token, $widgetid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation quickpanelfetchwidgetAsync
     *
     * Fetches the information for a specific widget.
     *
     * @param  string $token The authentication token. (required)
     * @param  string $widgetid The ID of the data to fetch it&#39;s data. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function quickpanelfetchwidgetAsync($token, $widgetid)
    {
        return $this->quickpanelfetchwidgetAsyncWithHttpInfo($token, $widgetid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation quickpanelfetchwidgetAsyncWithHttpInfo
     *
     * Fetches the information for a specific widget.
     *
     * @param  string $token The authentication token. (required)
     * @param  string $widgetid The ID of the data to fetch it&#39;s data. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function quickpanelfetchwidgetAsyncWithHttpInfo($token, $widgetid)
    {
        $returnType = '';
        $request = $this->quickpanelfetchwidgetRequest($token, $widgetid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'quickpanelfetchwidget'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $widgetid The ID of the data to fetch it&#39;s data. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function quickpanelfetchwidgetRequest($token, $widgetid)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling quickpanelfetchwidget'
            );
        }
        // verify the required parameter 'widgetid' is set
        if ($widgetid === null || (is_array($widgetid) && count($widgetid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $widgetid when calling quickpanelfetchwidget'
            );
        }

        $resourcePath = '/quickpanelfetchwidget';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($widgetid !== null) {
            if('form' === 'form' && is_array($widgetid)) {
                foreach($widgetid as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['widgetid'] = $widgetid;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation quickpanelgetwidget
     *
     * View details of a widget included in the Quick Panel
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the widget to get. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function quickpanelgetwidget($token, $id)
    {
        $this->quickpanelgetwidgetWithHttpInfo($token, $id);
    }

    /**
     * Operation quickpanelgetwidgetWithHttpInfo
     *
     * View details of a widget included in the Quick Panel
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the widget to get. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function quickpanelgetwidgetWithHttpInfo($token, $id)
    {
        $request = $this->quickpanelgetwidgetRequest($token, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation quickpanelgetwidgetAsync
     *
     * View details of a widget included in the Quick Panel
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the widget to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function quickpanelgetwidgetAsync($token, $id)
    {
        return $this->quickpanelgetwidgetAsyncWithHttpInfo($token, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation quickpanelgetwidgetAsyncWithHttpInfo
     *
     * View details of a widget included in the Quick Panel
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the widget to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function quickpanelgetwidgetAsyncWithHttpInfo($token, $id)
    {
        $returnType = '';
        $request = $this->quickpanelgetwidgetRequest($token, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'quickpanelgetwidget'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the widget to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function quickpanelgetwidgetRequest($token, $id)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling quickpanelgetwidget'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling quickpanelgetwidget'
            );
        }

        $resourcePath = '/quickpanelgetwidget';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($id !== null) {
            if('form' === 'form' && is_array($id)) {
                foreach($id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['id'] = $id;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation quickpanelinit
     *
     * Returns the initial information required to show the quick panels
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function quickpanelinit($token)
    {
        $this->quickpanelinitWithHttpInfo($token);
    }

    /**
     * Operation quickpanelinitWithHttpInfo
     *
     * Returns the initial information required to show the quick panels
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function quickpanelinitWithHttpInfo($token)
    {
        $request = $this->quickpanelinitRequest($token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation quickpanelinitAsync
     *
     * Returns the initial information required to show the quick panels
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function quickpanelinitAsync($token)
    {
        return $this->quickpanelinitAsyncWithHttpInfo($token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation quickpanelinitAsyncWithHttpInfo
     *
     * Returns the initial information required to show the quick panels
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function quickpanelinitAsyncWithHttpInfo($token)
    {
        $returnType = '';
        $request = $this->quickpanelinitRequest($token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'quickpanelinit'
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function quickpanelinitRequest($token)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling quickpanelinit'
            );
        }

        $resourcePath = '/quickpanelinit';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation quickpanellistwidgets
     *
     * Lists all the widgets that are added in the Quick Panel
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function quickpanellistwidgets($token)
    {
        $this->quickpanellistwidgetsWithHttpInfo($token);
    }

    /**
     * Operation quickpanellistwidgetsWithHttpInfo
     *
     * Lists all the widgets that are added in the Quick Panel
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function quickpanellistwidgetsWithHttpInfo($token)
    {
        $request = $this->quickpanellistwidgetsRequest($token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation quickpanellistwidgetsAsync
     *
     * Lists all the widgets that are added in the Quick Panel
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function quickpanellistwidgetsAsync($token)
    {
        return $this->quickpanellistwidgetsAsyncWithHttpInfo($token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation quickpanellistwidgetsAsyncWithHttpInfo
     *
     * Lists all the widgets that are added in the Quick Panel
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function quickpanellistwidgetsAsyncWithHttpInfo($token)
    {
        $returnType = '';
        $request = $this->quickpanellistwidgetsRequest($token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'quickpanellistwidgets'
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function quickpanellistwidgetsRequest($token)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling quickpanellistwidgets'
            );
        }

        $resourcePath = '/quickpanellistwidgets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation quickpanellistwidgettypes
     *
     * Lists all the widget types available in the system
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function quickpanellistwidgettypes($token)
    {
        $this->quickpanellistwidgettypesWithHttpInfo($token);
    }

    /**
     * Operation quickpanellistwidgettypesWithHttpInfo
     *
     * Lists all the widget types available in the system
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function quickpanellistwidgettypesWithHttpInfo($token)
    {
        $request = $this->quickpanellistwidgettypesRequest($token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation quickpanellistwidgettypesAsync
     *
     * Lists all the widget types available in the system
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function quickpanellistwidgettypesAsync($token)
    {
        return $this->quickpanellistwidgettypesAsyncWithHttpInfo($token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation quickpanellistwidgettypesAsyncWithHttpInfo
     *
     * Lists all the widget types available in the system
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function quickpanellistwidgettypesAsyncWithHttpInfo($token)
    {
        $returnType = '';
        $request = $this->quickpanellistwidgettypesRequest($token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'quickpanellistwidgettypes'
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function quickpanellistwidgettypesRequest($token)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling quickpanellistwidgettypes'
            );
        }

        $resourcePath = '/quickpanellistwidgettypes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation quickpanelreorderwidgets
     *
     * Reorders the widgets and moves them to a specific column
     *
     * @param  string $token The authentication token. (required)
     * @param  string $sectionname The section name where to sort the widgets. (required)
     * @param  string $orderids CSV list of the widgets to reorder. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function quickpanelreorderwidgets($token, $sectionname, $orderids)
    {
        $this->quickpanelreorderwidgetsWithHttpInfo($token, $sectionname, $orderids);
    }

    /**
     * Operation quickpanelreorderwidgetsWithHttpInfo
     *
     * Reorders the widgets and moves them to a specific column
     *
     * @param  string $token The authentication token. (required)
     * @param  string $sectionname The section name where to sort the widgets. (required)
     * @param  string $orderids CSV list of the widgets to reorder. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function quickpanelreorderwidgetsWithHttpInfo($token, $sectionname, $orderids)
    {
        $request = $this->quickpanelreorderwidgetsRequest($token, $sectionname, $orderids);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation quickpanelreorderwidgetsAsync
     *
     * Reorders the widgets and moves them to a specific column
     *
     * @param  string $token The authentication token. (required)
     * @param  string $sectionname The section name where to sort the widgets. (required)
     * @param  string $orderids CSV list of the widgets to reorder. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function quickpanelreorderwidgetsAsync($token, $sectionname, $orderids)
    {
        return $this->quickpanelreorderwidgetsAsyncWithHttpInfo($token, $sectionname, $orderids)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation quickpanelreorderwidgetsAsyncWithHttpInfo
     *
     * Reorders the widgets and moves them to a specific column
     *
     * @param  string $token The authentication token. (required)
     * @param  string $sectionname The section name where to sort the widgets. (required)
     * @param  string $orderids CSV list of the widgets to reorder. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function quickpanelreorderwidgetsAsyncWithHttpInfo($token, $sectionname, $orderids)
    {
        $returnType = '';
        $request = $this->quickpanelreorderwidgetsRequest($token, $sectionname, $orderids);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'quickpanelreorderwidgets'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $sectionname The section name where to sort the widgets. (required)
     * @param  string $orderids CSV list of the widgets to reorder. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function quickpanelreorderwidgetsRequest($token, $sectionname, $orderids)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling quickpanelreorderwidgets'
            );
        }
        // verify the required parameter 'sectionname' is set
        if ($sectionname === null || (is_array($sectionname) && count($sectionname) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sectionname when calling quickpanelreorderwidgets'
            );
        }
        // verify the required parameter 'orderids' is set
        if ($orderids === null || (is_array($orderids) && count($orderids) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $orderids when calling quickpanelreorderwidgets'
            );
        }

        $resourcePath = '/quickpanelreorderwidgets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($sectionname !== null) {
            if('form' === 'form' && is_array($sectionname)) {
                foreach($sectionname as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['sectionname'] = $sectionname;
            }
        }
        // query params
        if ($orderids !== null) {
            if('form' === 'form' && is_array($orderids)) {
                foreach($orderids as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['orderids'] = $orderids;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation quickpanelsavewidget
     *
     * Saves a widget for the Quick Panel
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function quickpanelsavewidget($unknown_base_type = null)
    {
        $this->quickpanelsavewidgetWithHttpInfo($unknown_base_type);
    }

    /**
     * Operation quickpanelsavewidgetWithHttpInfo
     *
     * Saves a widget for the Quick Panel
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function quickpanelsavewidgetWithHttpInfo($unknown_base_type = null)
    {
        $request = $this->quickpanelsavewidgetRequest($unknown_base_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation quickpanelsavewidgetAsync
     *
     * Saves a widget for the Quick Panel
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function quickpanelsavewidgetAsync($unknown_base_type = null)
    {
        return $this->quickpanelsavewidgetAsyncWithHttpInfo($unknown_base_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation quickpanelsavewidgetAsyncWithHttpInfo
     *
     * Saves a widget for the Quick Panel
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function quickpanelsavewidgetAsyncWithHttpInfo($unknown_base_type = null)
    {
        $returnType = '';
        $request = $this->quickpanelsavewidgetRequest($unknown_base_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'quickpanelsavewidget'
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function quickpanelsavewidgetRequest($unknown_base_type = null)
    {

        $resourcePath = '/quickpanelsavewidget';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($unknown_base_type)) {
            $_tempBody = $unknown_base_type;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reportlist
     *
     * View a list of available reports
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function reportlist($token)
    {
        $this->reportlistWithHttpInfo($token);
    }

    /**
     * Operation reportlistWithHttpInfo
     *
     * View a list of available reports
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function reportlistWithHttpInfo($token)
    {
        $request = $this->reportlistRequest($token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation reportlistAsync
     *
     * View a list of available reports
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportlistAsync($token)
    {
        return $this->reportlistAsyncWithHttpInfo($token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reportlistAsyncWithHttpInfo
     *
     * View a list of available reports
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportlistAsyncWithHttpInfo($token)
    {
        $returnType = '';
        $request = $this->reportlistRequest($token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reportlist'
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function reportlistRequest($token)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling reportlist'
            );
        }

        $resourcePath = '/reportlist';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reportpermissionsbyuser
     *
     * Permissions by user report
     *
     * @param  string $token The authentication token. (required)
     * @param  string $params A pipe separated list of the parameters. Example: key1&#x3D;value1|key2&#x3D;value2|key3&#x3D;value3 (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function reportpermissionsbyuser($token, $params = null)
    {
        $this->reportpermissionsbyuserWithHttpInfo($token, $params);
    }

    /**
     * Operation reportpermissionsbyuserWithHttpInfo
     *
     * Permissions by user report
     *
     * @param  string $token The authentication token. (required)
     * @param  string $params A pipe separated list of the parameters. Example: key1&#x3D;value1|key2&#x3D;value2|key3&#x3D;value3 (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function reportpermissionsbyuserWithHttpInfo($token, $params = null)
    {
        $request = $this->reportpermissionsbyuserRequest($token, $params);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation reportpermissionsbyuserAsync
     *
     * Permissions by user report
     *
     * @param  string $token The authentication token. (required)
     * @param  string $params A pipe separated list of the parameters. Example: key1&#x3D;value1|key2&#x3D;value2|key3&#x3D;value3 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportpermissionsbyuserAsync($token, $params = null)
    {
        return $this->reportpermissionsbyuserAsyncWithHttpInfo($token, $params)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reportpermissionsbyuserAsyncWithHttpInfo
     *
     * Permissions by user report
     *
     * @param  string $token The authentication token. (required)
     * @param  string $params A pipe separated list of the parameters. Example: key1&#x3D;value1|key2&#x3D;value2|key3&#x3D;value3 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportpermissionsbyuserAsyncWithHttpInfo($token, $params = null)
    {
        $returnType = '';
        $request = $this->reportpermissionsbyuserRequest($token, $params);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reportpermissionsbyuser'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $params A pipe separated list of the parameters. Example: key1&#x3D;value1|key2&#x3D;value2|key3&#x3D;value3 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function reportpermissionsbyuserRequest($token, $params = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling reportpermissionsbyuser'
            );
        }

        $resourcePath = '/reportpermissionsbyuser';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($params !== null) {
            if('form' === 'form' && is_array($params)) {
                foreach($params as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['params'] = $params;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reportprepare
     *
     * Queries and loads the specified report, in background.
     *
     * @param  string $token The authentication token. (required)
     * @param  string $reportname The name of the report to execute (required)
     * @param  string $params A pipe separated list of the parameters. Example: key1&#x3D;value1|key2&#x3D;value2|key3&#x3D;value3 (optional)
     * @param  string $repformat The format of the resulting report. Json, pdf, csv, ... (optional)
     * @param  string $fillgroupid If specified, the result is used to fill the group with the given ID (optional)
     * @param  string $groupby How to group the records. In the format &#39;col1+col2|col3+col4 (optional)
     * @param  string $refreshgroup The ID of the group to check (and refresh) before processing the report. (optional)
     * @param  string $filtertext The user friendly text of the applied filters. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function reportprepare($token, $reportname, $params = null, $repformat = null, $fillgroupid = null, $groupby = null, $refreshgroup = null, $filtertext = null)
    {
        $this->reportprepareWithHttpInfo($token, $reportname, $params, $repformat, $fillgroupid, $groupby, $refreshgroup, $filtertext);
    }

    /**
     * Operation reportprepareWithHttpInfo
     *
     * Queries and loads the specified report, in background.
     *
     * @param  string $token The authentication token. (required)
     * @param  string $reportname The name of the report to execute (required)
     * @param  string $params A pipe separated list of the parameters. Example: key1&#x3D;value1|key2&#x3D;value2|key3&#x3D;value3 (optional)
     * @param  string $repformat The format of the resulting report. Json, pdf, csv, ... (optional)
     * @param  string $fillgroupid If specified, the result is used to fill the group with the given ID (optional)
     * @param  string $groupby How to group the records. In the format &#39;col1+col2|col3+col4 (optional)
     * @param  string $refreshgroup The ID of the group to check (and refresh) before processing the report. (optional)
     * @param  string $filtertext The user friendly text of the applied filters. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function reportprepareWithHttpInfo($token, $reportname, $params = null, $repformat = null, $fillgroupid = null, $groupby = null, $refreshgroup = null, $filtertext = null)
    {
        $request = $this->reportprepareRequest($token, $reportname, $params, $repformat, $fillgroupid, $groupby, $refreshgroup, $filtertext);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation reportprepareAsync
     *
     * Queries and loads the specified report, in background.
     *
     * @param  string $token The authentication token. (required)
     * @param  string $reportname The name of the report to execute (required)
     * @param  string $params A pipe separated list of the parameters. Example: key1&#x3D;value1|key2&#x3D;value2|key3&#x3D;value3 (optional)
     * @param  string $repformat The format of the resulting report. Json, pdf, csv, ... (optional)
     * @param  string $fillgroupid If specified, the result is used to fill the group with the given ID (optional)
     * @param  string $groupby How to group the records. In the format &#39;col1+col2|col3+col4 (optional)
     * @param  string $refreshgroup The ID of the group to check (and refresh) before processing the report. (optional)
     * @param  string $filtertext The user friendly text of the applied filters. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportprepareAsync($token, $reportname, $params = null, $repformat = null, $fillgroupid = null, $groupby = null, $refreshgroup = null, $filtertext = null)
    {
        return $this->reportprepareAsyncWithHttpInfo($token, $reportname, $params, $repformat, $fillgroupid, $groupby, $refreshgroup, $filtertext)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reportprepareAsyncWithHttpInfo
     *
     * Queries and loads the specified report, in background.
     *
     * @param  string $token The authentication token. (required)
     * @param  string $reportname The name of the report to execute (required)
     * @param  string $params A pipe separated list of the parameters. Example: key1&#x3D;value1|key2&#x3D;value2|key3&#x3D;value3 (optional)
     * @param  string $repformat The format of the resulting report. Json, pdf, csv, ... (optional)
     * @param  string $fillgroupid If specified, the result is used to fill the group with the given ID (optional)
     * @param  string $groupby How to group the records. In the format &#39;col1+col2|col3+col4 (optional)
     * @param  string $refreshgroup The ID of the group to check (and refresh) before processing the report. (optional)
     * @param  string $filtertext The user friendly text of the applied filters. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportprepareAsyncWithHttpInfo($token, $reportname, $params = null, $repformat = null, $fillgroupid = null, $groupby = null, $refreshgroup = null, $filtertext = null)
    {
        $returnType = '';
        $request = $this->reportprepareRequest($token, $reportname, $params, $repformat, $fillgroupid, $groupby, $refreshgroup, $filtertext);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reportprepare'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $reportname The name of the report to execute (required)
     * @param  string $params A pipe separated list of the parameters. Example: key1&#x3D;value1|key2&#x3D;value2|key3&#x3D;value3 (optional)
     * @param  string $repformat The format of the resulting report. Json, pdf, csv, ... (optional)
     * @param  string $fillgroupid If specified, the result is used to fill the group with the given ID (optional)
     * @param  string $groupby How to group the records. In the format &#39;col1+col2|col3+col4 (optional)
     * @param  string $refreshgroup The ID of the group to check (and refresh) before processing the report. (optional)
     * @param  string $filtertext The user friendly text of the applied filters. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function reportprepareRequest($token, $reportname, $params = null, $repformat = null, $fillgroupid = null, $groupby = null, $refreshgroup = null, $filtertext = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling reportprepare'
            );
        }
        // verify the required parameter 'reportname' is set
        if ($reportname === null || (is_array($reportname) && count($reportname) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $reportname when calling reportprepare'
            );
        }

        $resourcePath = '/reportprepare';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($reportname !== null) {
            if('form' === 'form' && is_array($reportname)) {
                foreach($reportname as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['reportname'] = $reportname;
            }
        }
        // query params
        if ($params !== null) {
            if('form' === 'form' && is_array($params)) {
                foreach($params as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['params'] = $params;
            }
        }
        // query params
        if ($repformat !== null) {
            if('form' === 'form' && is_array($repformat)) {
                foreach($repformat as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['repformat'] = $repformat;
            }
        }
        // query params
        if ($fillgroupid !== null) {
            if('form' === 'form' && is_array($fillgroupid)) {
                foreach($fillgroupid as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['fillgroupid'] = $fillgroupid;
            }
        }
        // query params
        if ($groupby !== null) {
            if('form' === 'form' && is_array($groupby)) {
                foreach($groupby as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['groupby'] = $groupby;
            }
        }
        // query params
        if ($refreshgroup !== null) {
            if('form' === 'form' && is_array($refreshgroup)) {
                foreach($refreshgroup as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['refreshgroup'] = $refreshgroup;
            }
        }
        // query params
        if ($filtertext !== null) {
            if('form' === 'form' && is_array($filtertext)) {
                foreach($filtertext as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['filtertext'] = $filtertext;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reportquery
     *
     * Query and load a specified report
     *
     * @param  string $token The authentication token. (required)
     * @param  string $reportname The name of the report to execute (required)
     * @param  string $params A pipe separated list of the parameters. Example: key1&#x3D;value1|key2&#x3D;value2|key3&#x3D;value3 (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function reportquery($token, $reportname, $params = null)
    {
        $this->reportqueryWithHttpInfo($token, $reportname, $params);
    }

    /**
     * Operation reportqueryWithHttpInfo
     *
     * Query and load a specified report
     *
     * @param  string $token The authentication token. (required)
     * @param  string $reportname The name of the report to execute (required)
     * @param  string $params A pipe separated list of the parameters. Example: key1&#x3D;value1|key2&#x3D;value2|key3&#x3D;value3 (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function reportqueryWithHttpInfo($token, $reportname, $params = null)
    {
        $request = $this->reportqueryRequest($token, $reportname, $params);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation reportqueryAsync
     *
     * Query and load a specified report
     *
     * @param  string $token The authentication token. (required)
     * @param  string $reportname The name of the report to execute (required)
     * @param  string $params A pipe separated list of the parameters. Example: key1&#x3D;value1|key2&#x3D;value2|key3&#x3D;value3 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportqueryAsync($token, $reportname, $params = null)
    {
        return $this->reportqueryAsyncWithHttpInfo($token, $reportname, $params)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reportqueryAsyncWithHttpInfo
     *
     * Query and load a specified report
     *
     * @param  string $token The authentication token. (required)
     * @param  string $reportname The name of the report to execute (required)
     * @param  string $params A pipe separated list of the parameters. Example: key1&#x3D;value1|key2&#x3D;value2|key3&#x3D;value3 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportqueryAsyncWithHttpInfo($token, $reportname, $params = null)
    {
        $returnType = '';
        $request = $this->reportqueryRequest($token, $reportname, $params);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reportquery'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $reportname The name of the report to execute (required)
     * @param  string $params A pipe separated list of the parameters. Example: key1&#x3D;value1|key2&#x3D;value2|key3&#x3D;value3 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function reportqueryRequest($token, $reportname, $params = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling reportquery'
            );
        }
        // verify the required parameter 'reportname' is set
        if ($reportname === null || (is_array($reportname) && count($reportname) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $reportname when calling reportquery'
            );
        }

        $resourcePath = '/reportquery';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($reportname !== null) {
            if('form' === 'form' && is_array($reportname)) {
                foreach($reportname as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['reportname'] = $reportname;
            }
        }
        // query params
        if ($params !== null) {
            if('form' === 'form' && is_array($params)) {
                foreach($params as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['params'] = $params;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation rolelist
     *
     * Show a list of roles
     *
     * @param  string $token The authentication token. (required)
     * @param  string $name Filter by name of the role. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function rolelist($token, $name = null)
    {
        $this->rolelistWithHttpInfo($token, $name);
    }

    /**
     * Operation rolelistWithHttpInfo
     *
     * Show a list of roles
     *
     * @param  string $token The authentication token. (required)
     * @param  string $name Filter by name of the role. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function rolelistWithHttpInfo($token, $name = null)
    {
        $request = $this->rolelistRequest($token, $name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation rolelistAsync
     *
     * Show a list of roles
     *
     * @param  string $token The authentication token. (required)
     * @param  string $name Filter by name of the role. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rolelistAsync($token, $name = null)
    {
        return $this->rolelistAsyncWithHttpInfo($token, $name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation rolelistAsyncWithHttpInfo
     *
     * Show a list of roles
     *
     * @param  string $token The authentication token. (required)
     * @param  string $name Filter by name of the role. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rolelistAsyncWithHttpInfo($token, $name = null)
    {
        $returnType = '';
        $request = $this->rolelistRequest($token, $name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'rolelist'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $name Filter by name of the role. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function rolelistRequest($token, $name = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling rolelist'
            );
        }

        $resourcePath = '/rolelist';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($name !== null) {
            if('form' === 'form' && is_array($name)) {
                foreach($name as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['name'] = $name;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ruledelete
     *
     * Delete a rule
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the rule to delete. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function ruledelete($token, $id)
    {
        $this->ruledeleteWithHttpInfo($token, $id);
    }

    /**
     * Operation ruledeleteWithHttpInfo
     *
     * Delete a rule
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the rule to delete. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function ruledeleteWithHttpInfo($token, $id)
    {
        $request = $this->ruledeleteRequest($token, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation ruledeleteAsync
     *
     * Delete a rule
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the rule to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ruledeleteAsync($token, $id)
    {
        return $this->ruledeleteAsyncWithHttpInfo($token, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ruledeleteAsyncWithHttpInfo
     *
     * Delete a rule
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the rule to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ruledeleteAsyncWithHttpInfo($token, $id)
    {
        $returnType = '';
        $request = $this->ruledeleteRequest($token, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ruledelete'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the rule to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function ruledeleteRequest($token, $id)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling ruledelete'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ruledelete'
            );
        }

        $resourcePath = '/ruledelete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($id !== null) {
            if('form' === 'form' && is_array($id)) {
                foreach($id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['id'] = $id;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ruleget
     *
     * View details of a rule
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the rule to get. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function ruleget($token, $id)
    {
        $this->rulegetWithHttpInfo($token, $id);
    }

    /**
     * Operation rulegetWithHttpInfo
     *
     * View details of a rule
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the rule to get. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function rulegetWithHttpInfo($token, $id)
    {
        $request = $this->rulegetRequest($token, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation rulegetAsync
     *
     * View details of a rule
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the rule to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rulegetAsync($token, $id)
    {
        return $this->rulegetAsyncWithHttpInfo($token, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation rulegetAsyncWithHttpInfo
     *
     * View details of a rule
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the rule to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rulegetAsyncWithHttpInfo($token, $id)
    {
        $returnType = '';
        $request = $this->rulegetRequest($token, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ruleget'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the rule to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function rulegetRequest($token, $id)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling ruleget'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ruleget'
            );
        }

        $resourcePath = '/ruleget';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($id !== null) {
            if('form' === 'form' && is_array($id)) {
                foreach($id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['id'] = $id;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation rulegeteventtype
     *
     * View details of a rule event type
     *
     * @param  string $token The authentication token. (required)
     * @param  string $event The name of the event to refresh. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function rulegeteventtype($token, $event)
    {
        $this->rulegeteventtypeWithHttpInfo($token, $event);
    }

    /**
     * Operation rulegeteventtypeWithHttpInfo
     *
     * View details of a rule event type
     *
     * @param  string $token The authentication token. (required)
     * @param  string $event The name of the event to refresh. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function rulegeteventtypeWithHttpInfo($token, $event)
    {
        $request = $this->rulegeteventtypeRequest($token, $event);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation rulegeteventtypeAsync
     *
     * View details of a rule event type
     *
     * @param  string $token The authentication token. (required)
     * @param  string $event The name of the event to refresh. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rulegeteventtypeAsync($token, $event)
    {
        return $this->rulegeteventtypeAsyncWithHttpInfo($token, $event)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation rulegeteventtypeAsyncWithHttpInfo
     *
     * View details of a rule event type
     *
     * @param  string $token The authentication token. (required)
     * @param  string $event The name of the event to refresh. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rulegeteventtypeAsyncWithHttpInfo($token, $event)
    {
        $returnType = '';
        $request = $this->rulegeteventtypeRequest($token, $event);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'rulegeteventtype'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $event The name of the event to refresh. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function rulegeteventtypeRequest($token, $event)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling rulegeteventtype'
            );
        }
        // verify the required parameter 'event' is set
        if ($event === null || (is_array($event) && count($event) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $event when calling rulegeteventtype'
            );
        }

        $resourcePath = '/rulegeteventtype';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($event !== null) {
            if('form' === 'form' && is_array($event)) {
                foreach($event as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['event'] = $event;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation rulelist
     *
     * View a list of user rules
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function rulelist($token, $from, $count)
    {
        $this->rulelistWithHttpInfo($token, $from, $count);
    }

    /**
     * Operation rulelistWithHttpInfo
     *
     * View a list of user rules
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function rulelistWithHttpInfo($token, $from, $count)
    {
        $request = $this->rulelistRequest($token, $from, $count);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation rulelistAsync
     *
     * View a list of user rules
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rulelistAsync($token, $from, $count)
    {
        return $this->rulelistAsyncWithHttpInfo($token, $from, $count)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation rulelistAsyncWithHttpInfo
     *
     * View a list of user rules
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rulelistAsyncWithHttpInfo($token, $from, $count)
    {
        $returnType = '';
        $request = $this->rulelistRequest($token, $from, $count);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'rulelist'
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function rulelistRequest($token, $from, $count)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling rulelist'
            );
        }
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling rulelist'
            );
        }
        // verify the required parameter 'count' is set
        if ($count === null || (is_array($count) && count($count) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $count when calling rulelist'
            );
        }

        $resourcePath = '/rulelist';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }
        // query params
        if ($count !== null) {
            if('form' === 'form' && is_array($count)) {
                foreach($count as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['count'] = $count;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation rulelistactions
     *
     * View a list of rule actions available
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function rulelistactions($token)
    {
        $this->rulelistactionsWithHttpInfo($token);
    }

    /**
     * Operation rulelistactionsWithHttpInfo
     *
     * View a list of rule actions available
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function rulelistactionsWithHttpInfo($token)
    {
        $request = $this->rulelistactionsRequest($token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation rulelistactionsAsync
     *
     * View a list of rule actions available
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rulelistactionsAsync($token)
    {
        return $this->rulelistactionsAsyncWithHttpInfo($token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation rulelistactionsAsyncWithHttpInfo
     *
     * View a list of rule actions available
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rulelistactionsAsyncWithHttpInfo($token)
    {
        $returnType = '';
        $request = $this->rulelistactionsRequest($token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'rulelistactions'
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function rulelistactionsRequest($token)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling rulelistactions'
            );
        }

        $resourcePath = '/rulelistactions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation rulelisteventtypes
     *
     * View a list of rule event types
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function rulelisteventtypes($token)
    {
        $this->rulelisteventtypesWithHttpInfo($token);
    }

    /**
     * Operation rulelisteventtypesWithHttpInfo
     *
     * View a list of rule event types
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function rulelisteventtypesWithHttpInfo($token)
    {
        $request = $this->rulelisteventtypesRequest($token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation rulelisteventtypesAsync
     *
     * View a list of rule event types
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rulelisteventtypesAsync($token)
    {
        return $this->rulelisteventtypesAsyncWithHttpInfo($token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation rulelisteventtypesAsyncWithHttpInfo
     *
     * View a list of rule event types
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rulelisteventtypesAsyncWithHttpInfo($token)
    {
        $returnType = '';
        $request = $this->rulelisteventtypesRequest($token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'rulelisteventtypes'
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function rulelisteventtypesRequest($token)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling rulelisteventtypes'
            );
        }

        $resourcePath = '/rulelisteventtypes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation rulelisthttprequests
     *
     * View all the http requests sent as a result of a rule
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  bool $failed If true only failed requests will be returned (optional)
     * @param  int $status The http status to filter the requests (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function rulelisthttprequests($token, $from, $count, $failed = null, $status = null)
    {
        $this->rulelisthttprequestsWithHttpInfo($token, $from, $count, $failed, $status);
    }

    /**
     * Operation rulelisthttprequestsWithHttpInfo
     *
     * View all the http requests sent as a result of a rule
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  bool $failed If true only failed requests will be returned (optional)
     * @param  int $status The http status to filter the requests (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function rulelisthttprequestsWithHttpInfo($token, $from, $count, $failed = null, $status = null)
    {
        $request = $this->rulelisthttprequestsRequest($token, $from, $count, $failed, $status);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation rulelisthttprequestsAsync
     *
     * View all the http requests sent as a result of a rule
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  bool $failed If true only failed requests will be returned (optional)
     * @param  int $status The http status to filter the requests (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rulelisthttprequestsAsync($token, $from, $count, $failed = null, $status = null)
    {
        return $this->rulelisthttprequestsAsyncWithHttpInfo($token, $from, $count, $failed, $status)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation rulelisthttprequestsAsyncWithHttpInfo
     *
     * View all the http requests sent as a result of a rule
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  bool $failed If true only failed requests will be returned (optional)
     * @param  int $status The http status to filter the requests (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rulelisthttprequestsAsyncWithHttpInfo($token, $from, $count, $failed = null, $status = null)
    {
        $returnType = '';
        $request = $this->rulelisthttprequestsRequest($token, $from, $count, $failed, $status);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'rulelisthttprequests'
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  bool $failed If true only failed requests will be returned (optional)
     * @param  int $status The http status to filter the requests (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function rulelisthttprequestsRequest($token, $from, $count, $failed = null, $status = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling rulelisthttprequests'
            );
        }
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling rulelisthttprequests'
            );
        }
        // verify the required parameter 'count' is set
        if ($count === null || (is_array($count) && count($count) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $count when calling rulelisthttprequests'
            );
        }

        $resourcePath = '/rulelisthttprequests';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($failed !== null) {
            if('form' === 'form' && is_array($failed)) {
                foreach($failed as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['failed'] = $failed;
            }
        }
        // query params
        if ($status !== null) {
            if('form' === 'form' && is_array($status)) {
                foreach($status as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['status'] = $status;
            }
        }
        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }
        // query params
        if ($count !== null) {
            if('form' === 'form' && is_array($count)) {
                foreach($count as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['count'] = $count;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation rulesave
     *
     * Create or edit a rule
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function rulesave($unknown_base_type = null)
    {
        $this->rulesaveWithHttpInfo($unknown_base_type);
    }

    /**
     * Operation rulesaveWithHttpInfo
     *
     * Create or edit a rule
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function rulesaveWithHttpInfo($unknown_base_type = null)
    {
        $request = $this->rulesaveRequest($unknown_base_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation rulesaveAsync
     *
     * Create or edit a rule
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rulesaveAsync($unknown_base_type = null)
    {
        return $this->rulesaveAsyncWithHttpInfo($unknown_base_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation rulesaveAsyncWithHttpInfo
     *
     * Create or edit a rule
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rulesaveAsyncWithHttpInfo($unknown_base_type = null)
    {
        $returnType = '';
        $request = $this->rulesaveRequest($unknown_base_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'rulesave'
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function rulesaveRequest($unknown_base_type = null)
    {

        $resourcePath = '/rulesave';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($unknown_base_type)) {
            $_tempBody = $unknown_base_type;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation search
     *
     * Search
     *
     * @param  string $token The authentication token. (required)
     * @param  string $query The query to search for. (required)
     * @param  int $page Current page to show, zero-based. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function search($token, $query, $page = null)
    {
        $this->searchWithHttpInfo($token, $query, $page);
    }

    /**
     * Operation searchWithHttpInfo
     *
     * Search
     *
     * @param  string $token The authentication token. (required)
     * @param  string $query The query to search for. (required)
     * @param  int $page Current page to show, zero-based. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchWithHttpInfo($token, $query, $page = null)
    {
        $request = $this->searchRequest($token, $query, $page);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation searchAsync
     *
     * Search
     *
     * @param  string $token The authentication token. (required)
     * @param  string $query The query to search for. (required)
     * @param  int $page Current page to show, zero-based. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchAsync($token, $query, $page = null)
    {
        return $this->searchAsyncWithHttpInfo($token, $query, $page)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchAsyncWithHttpInfo
     *
     * Search
     *
     * @param  string $token The authentication token. (required)
     * @param  string $query The query to search for. (required)
     * @param  int $page Current page to show, zero-based. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchAsyncWithHttpInfo($token, $query, $page = null)
    {
        $returnType = '';
        $request = $this->searchRequest($token, $query, $page);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'search'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $query The query to search for. (required)
     * @param  int $page Current page to show, zero-based. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchRequest($token, $query, $page = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling search'
            );
        }
        // verify the required parameter 'query' is set
        if ($query === null || (is_array($query) && count($query) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query when calling search'
            );
        }

        $resourcePath = '/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($query !== null) {
            if('form' === 'form' && is_array($query)) {
                foreach($query as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['query'] = $query;
            }
        }
        // query params
        if ($page !== null) {
            if('form' === 'form' && is_array($page)) {
                foreach($page as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['page'] = $page;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchgetentities
     *
     * Get the information of the entities that can be searched
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function searchgetentities($token)
    {
        $this->searchgetentitiesWithHttpInfo($token);
    }

    /**
     * Operation searchgetentitiesWithHttpInfo
     *
     * Get the information of the entities that can be searched
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchgetentitiesWithHttpInfo($token)
    {
        $request = $this->searchgetentitiesRequest($token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation searchgetentitiesAsync
     *
     * Get the information of the entities that can be searched
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchgetentitiesAsync($token)
    {
        return $this->searchgetentitiesAsyncWithHttpInfo($token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchgetentitiesAsyncWithHttpInfo
     *
     * Get the information of the entities that can be searched
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchgetentitiesAsyncWithHttpInfo($token)
    {
        $returnType = '';
        $request = $this->searchgetentitiesRequest($token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchgetentities'
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchgetentitiesRequest($token)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling searchgetentities'
            );
        }

        $resourcePath = '/searchgetentities';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation securityassesspermission
     *
     * Returns the list of users for a specific permission
     *
     * @param  string $token The authentication token. (required)
     * @param  string $commandname Name of the action or command to get the roles. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function securityassesspermission($token, $commandname)
    {
        $this->securityassesspermissionWithHttpInfo($token, $commandname);
    }

    /**
     * Operation securityassesspermissionWithHttpInfo
     *
     * Returns the list of users for a specific permission
     *
     * @param  string $token The authentication token. (required)
     * @param  string $commandname Name of the action or command to get the roles. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function securityassesspermissionWithHttpInfo($token, $commandname)
    {
        $request = $this->securityassesspermissionRequest($token, $commandname);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation securityassesspermissionAsync
     *
     * Returns the list of users for a specific permission
     *
     * @param  string $token The authentication token. (required)
     * @param  string $commandname Name of the action or command to get the roles. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function securityassesspermissionAsync($token, $commandname)
    {
        return $this->securityassesspermissionAsyncWithHttpInfo($token, $commandname)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation securityassesspermissionAsyncWithHttpInfo
     *
     * Returns the list of users for a specific permission
     *
     * @param  string $token The authentication token. (required)
     * @param  string $commandname Name of the action or command to get the roles. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function securityassesspermissionAsyncWithHttpInfo($token, $commandname)
    {
        $returnType = '';
        $request = $this->securityassesspermissionRequest($token, $commandname);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'securityassesspermission'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $commandname Name of the action or command to get the roles. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function securityassesspermissionRequest($token, $commandname)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling securityassesspermission'
            );
        }
        // verify the required parameter 'commandname' is set
        if ($commandname === null || (is_array($commandname) && count($commandname) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $commandname when calling securityassesspermission'
            );
        }

        $resourcePath = '/securityassesspermission';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($commandname !== null) {
            if('form' === 'form' && is_array($commandname)) {
                foreach($commandname as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['commandname'] = $commandname;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation securityassessrole
     *
     * Returns the list of permissions for a specific role
     *
     * @param  string $token The authentication token. (required)
     * @param  string $roleid Role ID to list the effective permissions. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function securityassessrole($token, $roleid)
    {
        $this->securityassessroleWithHttpInfo($token, $roleid);
    }

    /**
     * Operation securityassessroleWithHttpInfo
     *
     * Returns the list of permissions for a specific role
     *
     * @param  string $token The authentication token. (required)
     * @param  string $roleid Role ID to list the effective permissions. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function securityassessroleWithHttpInfo($token, $roleid)
    {
        $request = $this->securityassessroleRequest($token, $roleid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation securityassessroleAsync
     *
     * Returns the list of permissions for a specific role
     *
     * @param  string $token The authentication token. (required)
     * @param  string $roleid Role ID to list the effective permissions. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function securityassessroleAsync($token, $roleid)
    {
        return $this->securityassessroleAsyncWithHttpInfo($token, $roleid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation securityassessroleAsyncWithHttpInfo
     *
     * Returns the list of permissions for a specific role
     *
     * @param  string $token The authentication token. (required)
     * @param  string $roleid Role ID to list the effective permissions. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function securityassessroleAsyncWithHttpInfo($token, $roleid)
    {
        $returnType = '';
        $request = $this->securityassessroleRequest($token, $roleid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'securityassessrole'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $roleid Role ID to list the effective permissions. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function securityassessroleRequest($token, $roleid)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling securityassessrole'
            );
        }
        // verify the required parameter 'roleid' is set
        if ($roleid === null || (is_array($roleid) && count($roleid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $roleid when calling securityassessrole'
            );
        }

        $resourcePath = '/securityassessrole';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($roleid !== null) {
            if('form' === 'form' && is_array($roleid)) {
                foreach($roleid as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['roleid'] = $roleid;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation securityassessscope
     *
     * Returns the list of users for a specific user
     *
     * @param  string $token The authentication token. (required)
     * @param  string $locationid Location ID to list the users with that scope. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function securityassessscope($token, $locationid = null)
    {
        $this->securityassessscopeWithHttpInfo($token, $locationid);
    }

    /**
     * Operation securityassessscopeWithHttpInfo
     *
     * Returns the list of users for a specific user
     *
     * @param  string $token The authentication token. (required)
     * @param  string $locationid Location ID to list the users with that scope. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function securityassessscopeWithHttpInfo($token, $locationid = null)
    {
        $request = $this->securityassessscopeRequest($token, $locationid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation securityassessscopeAsync
     *
     * Returns the list of users for a specific user
     *
     * @param  string $token The authentication token. (required)
     * @param  string $locationid Location ID to list the users with that scope. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function securityassessscopeAsync($token, $locationid = null)
    {
        return $this->securityassessscopeAsyncWithHttpInfo($token, $locationid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation securityassessscopeAsyncWithHttpInfo
     *
     * Returns the list of users for a specific user
     *
     * @param  string $token The authentication token. (required)
     * @param  string $locationid Location ID to list the users with that scope. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function securityassessscopeAsyncWithHttpInfo($token, $locationid = null)
    {
        $returnType = '';
        $request = $this->securityassessscopeRequest($token, $locationid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'securityassessscope'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $locationid Location ID to list the users with that scope. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function securityassessscopeRequest($token, $locationid = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling securityassessscope'
            );
        }

        $resourcePath = '/securityassessscope';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($locationid !== null) {
            if('form' === 'form' && is_array($locationid)) {
                foreach($locationid as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['locationid'] = $locationid;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation securityassessuser
     *
     * Returns the list of permissions for a specific user
     *
     * @param  string $token The authentication token. (required)
     * @param  string $userid User ID to list the effective permissions. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function securityassessuser($token, $userid)
    {
        $this->securityassessuserWithHttpInfo($token, $userid);
    }

    /**
     * Operation securityassessuserWithHttpInfo
     *
     * Returns the list of permissions for a specific user
     *
     * @param  string $token The authentication token. (required)
     * @param  string $userid User ID to list the effective permissions. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function securityassessuserWithHttpInfo($token, $userid)
    {
        $request = $this->securityassessuserRequest($token, $userid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation securityassessuserAsync
     *
     * Returns the list of permissions for a specific user
     *
     * @param  string $token The authentication token. (required)
     * @param  string $userid User ID to list the effective permissions. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function securityassessuserAsync($token, $userid)
    {
        return $this->securityassessuserAsyncWithHttpInfo($token, $userid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation securityassessuserAsyncWithHttpInfo
     *
     * Returns the list of permissions for a specific user
     *
     * @param  string $token The authentication token. (required)
     * @param  string $userid User ID to list the effective permissions. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function securityassessuserAsyncWithHttpInfo($token, $userid)
    {
        $returnType = '';
        $request = $this->securityassessuserRequest($token, $userid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'securityassessuser'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $userid User ID to list the effective permissions. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function securityassessuserRequest($token, $userid)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling securityassessuser'
            );
        }
        // verify the required parameter 'userid' is set
        if ($userid === null || (is_array($userid) && count($userid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userid when calling securityassessuser'
            );
        }

        $resourcePath = '/securityassessuser';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($userid !== null) {
            if('form' === 'form' && is_array($userid)) {
                foreach($userid as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['userid'] = $userid;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation sessionregaddcurrentuser
     *
     * Register current user to an event session
     *
     * @param  string $token The authentication token. (required)
     * @param  string $eventid The id of the event. (required)
     * @param  \DateTime $sessiondate The date and time when the session starts. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function sessionregaddcurrentuser($token, $eventid, $sessiondate)
    {
        $this->sessionregaddcurrentuserWithHttpInfo($token, $eventid, $sessiondate);
    }

    /**
     * Operation sessionregaddcurrentuserWithHttpInfo
     *
     * Register current user to an event session
     *
     * @param  string $token The authentication token. (required)
     * @param  string $eventid The id of the event. (required)
     * @param  \DateTime $sessiondate The date and time when the session starts. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function sessionregaddcurrentuserWithHttpInfo($token, $eventid, $sessiondate)
    {
        $request = $this->sessionregaddcurrentuserRequest($token, $eventid, $sessiondate);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation sessionregaddcurrentuserAsync
     *
     * Register current user to an event session
     *
     * @param  string $token The authentication token. (required)
     * @param  string $eventid The id of the event. (required)
     * @param  \DateTime $sessiondate The date and time when the session starts. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sessionregaddcurrentuserAsync($token, $eventid, $sessiondate)
    {
        return $this->sessionregaddcurrentuserAsyncWithHttpInfo($token, $eventid, $sessiondate)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation sessionregaddcurrentuserAsyncWithHttpInfo
     *
     * Register current user to an event session
     *
     * @param  string $token The authentication token. (required)
     * @param  string $eventid The id of the event. (required)
     * @param  \DateTime $sessiondate The date and time when the session starts. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sessionregaddcurrentuserAsyncWithHttpInfo($token, $eventid, $sessiondate)
    {
        $returnType = '';
        $request = $this->sessionregaddcurrentuserRequest($token, $eventid, $sessiondate);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'sessionregaddcurrentuser'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $eventid The id of the event. (required)
     * @param  \DateTime $sessiondate The date and time when the session starts. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function sessionregaddcurrentuserRequest($token, $eventid, $sessiondate)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling sessionregaddcurrentuser'
            );
        }
        // verify the required parameter 'eventid' is set
        if ($eventid === null || (is_array($eventid) && count($eventid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $eventid when calling sessionregaddcurrentuser'
            );
        }
        // verify the required parameter 'sessiondate' is set
        if ($sessiondate === null || (is_array($sessiondate) && count($sessiondate) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sessiondate when calling sessionregaddcurrentuser'
            );
        }

        $resourcePath = '/sessionregaddcurrentuser';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($eventid !== null) {
            if('form' === 'form' && is_array($eventid)) {
                foreach($eventid as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['eventid'] = $eventid;
            }
        }
        // query params
        if ($sessiondate !== null) {
            if('form' === 'form' && is_array($sessiondate)) {
                foreach($sessiondate as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['sessiondate'] = $sessiondate;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation sessionregadduser
     *
     * Register users for events
     *
     * @param  string $token The authentication token. (required)
     * @param  string $userid The id of the user to add. (required)
     * @param  string $eventid The id of the event. (required)
     * @param  \DateTime $sessiondate The date and time when the session starts. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function sessionregadduser($token, $userid, $eventid, $sessiondate)
    {
        $this->sessionregadduserWithHttpInfo($token, $userid, $eventid, $sessiondate);
    }

    /**
     * Operation sessionregadduserWithHttpInfo
     *
     * Register users for events
     *
     * @param  string $token The authentication token. (required)
     * @param  string $userid The id of the user to add. (required)
     * @param  string $eventid The id of the event. (required)
     * @param  \DateTime $sessiondate The date and time when the session starts. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function sessionregadduserWithHttpInfo($token, $userid, $eventid, $sessiondate)
    {
        $request = $this->sessionregadduserRequest($token, $userid, $eventid, $sessiondate);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation sessionregadduserAsync
     *
     * Register users for events
     *
     * @param  string $token The authentication token. (required)
     * @param  string $userid The id of the user to add. (required)
     * @param  string $eventid The id of the event. (required)
     * @param  \DateTime $sessiondate The date and time when the session starts. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sessionregadduserAsync($token, $userid, $eventid, $sessiondate)
    {
        return $this->sessionregadduserAsyncWithHttpInfo($token, $userid, $eventid, $sessiondate)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation sessionregadduserAsyncWithHttpInfo
     *
     * Register users for events
     *
     * @param  string $token The authentication token. (required)
     * @param  string $userid The id of the user to add. (required)
     * @param  string $eventid The id of the event. (required)
     * @param  \DateTime $sessiondate The date and time when the session starts. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sessionregadduserAsyncWithHttpInfo($token, $userid, $eventid, $sessiondate)
    {
        $returnType = '';
        $request = $this->sessionregadduserRequest($token, $userid, $eventid, $sessiondate);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'sessionregadduser'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $userid The id of the user to add. (required)
     * @param  string $eventid The id of the event. (required)
     * @param  \DateTime $sessiondate The date and time when the session starts. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function sessionregadduserRequest($token, $userid, $eventid, $sessiondate)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling sessionregadduser'
            );
        }
        // verify the required parameter 'userid' is set
        if ($userid === null || (is_array($userid) && count($userid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userid when calling sessionregadduser'
            );
        }
        // verify the required parameter 'eventid' is set
        if ($eventid === null || (is_array($eventid) && count($eventid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $eventid when calling sessionregadduser'
            );
        }
        // verify the required parameter 'sessiondate' is set
        if ($sessiondate === null || (is_array($sessiondate) && count($sessiondate) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sessiondate when calling sessionregadduser'
            );
        }

        $resourcePath = '/sessionregadduser';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($userid !== null) {
            if('form' === 'form' && is_array($userid)) {
                foreach($userid as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['userid'] = $userid;
            }
        }
        // query params
        if ($eventid !== null) {
            if('form' === 'form' && is_array($eventid)) {
                foreach($eventid as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['eventid'] = $eventid;
            }
        }
        // query params
        if ($sessiondate !== null) {
            if('form' === 'form' && is_array($sessiondate)) {
                foreach($sessiondate as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['sessiondate'] = $sessiondate;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation sessionreggetmysessions
     *
     * View all the sessions the logged user is registered to
     *
     * @param  string $token The authentication token. (required)
     * @param  \DateTime $date Start date to filter the sessions. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function sessionreggetmysessions($token, $date = null)
    {
        $this->sessionreggetmysessionsWithHttpInfo($token, $date);
    }

    /**
     * Operation sessionreggetmysessionsWithHttpInfo
     *
     * View all the sessions the logged user is registered to
     *
     * @param  string $token The authentication token. (required)
     * @param  \DateTime $date Start date to filter the sessions. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function sessionreggetmysessionsWithHttpInfo($token, $date = null)
    {
        $request = $this->sessionreggetmysessionsRequest($token, $date);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation sessionreggetmysessionsAsync
     *
     * View all the sessions the logged user is registered to
     *
     * @param  string $token The authentication token. (required)
     * @param  \DateTime $date Start date to filter the sessions. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sessionreggetmysessionsAsync($token, $date = null)
    {
        return $this->sessionreggetmysessionsAsyncWithHttpInfo($token, $date)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation sessionreggetmysessionsAsyncWithHttpInfo
     *
     * View all the sessions the logged user is registered to
     *
     * @param  string $token The authentication token. (required)
     * @param  \DateTime $date Start date to filter the sessions. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sessionreggetmysessionsAsyncWithHttpInfo($token, $date = null)
    {
        $returnType = '';
        $request = $this->sessionreggetmysessionsRequest($token, $date);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'sessionreggetmysessions'
     *
     * @param  string $token The authentication token. (required)
     * @param  \DateTime $date Start date to filter the sessions. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function sessionreggetmysessionsRequest($token, $date = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling sessionreggetmysessions'
            );
        }

        $resourcePath = '/sessionreggetmysessions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($date !== null) {
            if('form' === 'form' && is_array($date)) {
                foreach($date as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['date'] = $date;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation sessionreggetsessions
     *
     * Lists the registrations for a specific user
     *
     * @param  string $token The authentication token. (required)
     * @param  string $userid The user id to list sessions. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function sessionreggetsessions($token, $userid)
    {
        $this->sessionreggetsessionsWithHttpInfo($token, $userid);
    }

    /**
     * Operation sessionreggetsessionsWithHttpInfo
     *
     * Lists the registrations for a specific user
     *
     * @param  string $token The authentication token. (required)
     * @param  string $userid The user id to list sessions. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function sessionreggetsessionsWithHttpInfo($token, $userid)
    {
        $request = $this->sessionreggetsessionsRequest($token, $userid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation sessionreggetsessionsAsync
     *
     * Lists the registrations for a specific user
     *
     * @param  string $token The authentication token. (required)
     * @param  string $userid The user id to list sessions. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sessionreggetsessionsAsync($token, $userid)
    {
        return $this->sessionreggetsessionsAsyncWithHttpInfo($token, $userid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation sessionreggetsessionsAsyncWithHttpInfo
     *
     * Lists the registrations for a specific user
     *
     * @param  string $token The authentication token. (required)
     * @param  string $userid The user id to list sessions. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sessionreggetsessionsAsyncWithHttpInfo($token, $userid)
    {
        $returnType = '';
        $request = $this->sessionreggetsessionsRequest($token, $userid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'sessionreggetsessions'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $userid The user id to list sessions. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function sessionreggetsessionsRequest($token, $userid)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling sessionreggetsessions'
            );
        }
        // verify the required parameter 'userid' is set
        if ($userid === null || (is_array($userid) && count($userid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userid when calling sessionreggetsessions'
            );
        }

        $resourcePath = '/sessionreggetsessions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($userid !== null) {
            if('form' === 'form' && is_array($userid)) {
                foreach($userid as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['userid'] = $userid;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation sessionreggetsettings
     *
     * Get the settings for session registration
     *
     * @param  string $token The authentication token. (required)
     * @param  string $locationid The id of the location to save settings. (optional)
     * @param  string $eventid The id of the event to save settings. (optional)
     * @param  \DateTime $sessiondate The date and time when the session starts. (optional)
     * @param  bool $noinherit True to get the location/event/session specific settings without looking for the more global settings. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function sessionreggetsettings($token, $locationid = null, $eventid = null, $sessiondate = null, $noinherit = null)
    {
        $this->sessionreggetsettingsWithHttpInfo($token, $locationid, $eventid, $sessiondate, $noinherit);
    }

    /**
     * Operation sessionreggetsettingsWithHttpInfo
     *
     * Get the settings for session registration
     *
     * @param  string $token The authentication token. (required)
     * @param  string $locationid The id of the location to save settings. (optional)
     * @param  string $eventid The id of the event to save settings. (optional)
     * @param  \DateTime $sessiondate The date and time when the session starts. (optional)
     * @param  bool $noinherit True to get the location/event/session specific settings without looking for the more global settings. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function sessionreggetsettingsWithHttpInfo($token, $locationid = null, $eventid = null, $sessiondate = null, $noinherit = null)
    {
        $request = $this->sessionreggetsettingsRequest($token, $locationid, $eventid, $sessiondate, $noinherit);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation sessionreggetsettingsAsync
     *
     * Get the settings for session registration
     *
     * @param  string $token The authentication token. (required)
     * @param  string $locationid The id of the location to save settings. (optional)
     * @param  string $eventid The id of the event to save settings. (optional)
     * @param  \DateTime $sessiondate The date and time when the session starts. (optional)
     * @param  bool $noinherit True to get the location/event/session specific settings without looking for the more global settings. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sessionreggetsettingsAsync($token, $locationid = null, $eventid = null, $sessiondate = null, $noinherit = null)
    {
        return $this->sessionreggetsettingsAsyncWithHttpInfo($token, $locationid, $eventid, $sessiondate, $noinherit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation sessionreggetsettingsAsyncWithHttpInfo
     *
     * Get the settings for session registration
     *
     * @param  string $token The authentication token. (required)
     * @param  string $locationid The id of the location to save settings. (optional)
     * @param  string $eventid The id of the event to save settings. (optional)
     * @param  \DateTime $sessiondate The date and time when the session starts. (optional)
     * @param  bool $noinherit True to get the location/event/session specific settings without looking for the more global settings. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sessionreggetsettingsAsyncWithHttpInfo($token, $locationid = null, $eventid = null, $sessiondate = null, $noinherit = null)
    {
        $returnType = '';
        $request = $this->sessionreggetsettingsRequest($token, $locationid, $eventid, $sessiondate, $noinherit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'sessionreggetsettings'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $locationid The id of the location to save settings. (optional)
     * @param  string $eventid The id of the event to save settings. (optional)
     * @param  \DateTime $sessiondate The date and time when the session starts. (optional)
     * @param  bool $noinherit True to get the location/event/session specific settings without looking for the more global settings. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function sessionreggetsettingsRequest($token, $locationid = null, $eventid = null, $sessiondate = null, $noinherit = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling sessionreggetsettings'
            );
        }

        $resourcePath = '/sessionreggetsettings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($locationid !== null) {
            if('form' === 'form' && is_array($locationid)) {
                foreach($locationid as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['locationid'] = $locationid;
            }
        }
        // query params
        if ($eventid !== null) {
            if('form' === 'form' && is_array($eventid)) {
                foreach($eventid as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['eventid'] = $eventid;
            }
        }
        // query params
        if ($sessiondate !== null) {
            if('form' === 'form' && is_array($sessiondate)) {
                foreach($sessiondate as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['sessiondate'] = $sessiondate;
            }
        }
        // query params
        if ($noinherit !== null) {
            if('form' === 'form' && is_array($noinherit)) {
                foreach($noinherit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['noinherit'] = $noinherit;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation sessionreggetusers
     *
     * Lists the registrations for a specific session
     *
     * @param  string $token The authentication token. (required)
     * @param  string $eventid The event id to list sessions. (required)
     * @param  \DateTime $sessiondate The date of the session to find. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function sessionreggetusers($token, $eventid, $sessiondate)
    {
        $this->sessionreggetusersWithHttpInfo($token, $eventid, $sessiondate);
    }

    /**
     * Operation sessionreggetusersWithHttpInfo
     *
     * Lists the registrations for a specific session
     *
     * @param  string $token The authentication token. (required)
     * @param  string $eventid The event id to list sessions. (required)
     * @param  \DateTime $sessiondate The date of the session to find. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function sessionreggetusersWithHttpInfo($token, $eventid, $sessiondate)
    {
        $request = $this->sessionreggetusersRequest($token, $eventid, $sessiondate);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation sessionreggetusersAsync
     *
     * Lists the registrations for a specific session
     *
     * @param  string $token The authentication token. (required)
     * @param  string $eventid The event id to list sessions. (required)
     * @param  \DateTime $sessiondate The date of the session to find. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sessionreggetusersAsync($token, $eventid, $sessiondate)
    {
        return $this->sessionreggetusersAsyncWithHttpInfo($token, $eventid, $sessiondate)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation sessionreggetusersAsyncWithHttpInfo
     *
     * Lists the registrations for a specific session
     *
     * @param  string $token The authentication token. (required)
     * @param  string $eventid The event id to list sessions. (required)
     * @param  \DateTime $sessiondate The date of the session to find. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sessionreggetusersAsyncWithHttpInfo($token, $eventid, $sessiondate)
    {
        $returnType = '';
        $request = $this->sessionreggetusersRequest($token, $eventid, $sessiondate);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'sessionreggetusers'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $eventid The event id to list sessions. (required)
     * @param  \DateTime $sessiondate The date of the session to find. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function sessionreggetusersRequest($token, $eventid, $sessiondate)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling sessionreggetusers'
            );
        }
        // verify the required parameter 'eventid' is set
        if ($eventid === null || (is_array($eventid) && count($eventid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $eventid when calling sessionreggetusers'
            );
        }
        // verify the required parameter 'sessiondate' is set
        if ($sessiondate === null || (is_array($sessiondate) && count($sessiondate) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sessiondate when calling sessionreggetusers'
            );
        }

        $resourcePath = '/sessionreggetusers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($eventid !== null) {
            if('form' === 'form' && is_array($eventid)) {
                foreach($eventid as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['eventid'] = $eventid;
            }
        }
        // query params
        if ($sessiondate !== null) {
            if('form' === 'form' && is_array($sessiondate)) {
                foreach($sessiondate as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['sessiondate'] = $sessiondate;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation sessionreglistsessions
     *
     * List the sessions available for a specific event
     *
     * @param  string $token The authentication token. (required)
     * @param  string $eventid The event id to list sessions. (required)
     * @param  \DateTime $sessiondate The date of the session to find. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function sessionreglistsessions($token, $eventid, $sessiondate = null)
    {
        $this->sessionreglistsessionsWithHttpInfo($token, $eventid, $sessiondate);
    }

    /**
     * Operation sessionreglistsessionsWithHttpInfo
     *
     * List the sessions available for a specific event
     *
     * @param  string $token The authentication token. (required)
     * @param  string $eventid The event id to list sessions. (required)
     * @param  \DateTime $sessiondate The date of the session to find. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function sessionreglistsessionsWithHttpInfo($token, $eventid, $sessiondate = null)
    {
        $request = $this->sessionreglistsessionsRequest($token, $eventid, $sessiondate);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation sessionreglistsessionsAsync
     *
     * List the sessions available for a specific event
     *
     * @param  string $token The authentication token. (required)
     * @param  string $eventid The event id to list sessions. (required)
     * @param  \DateTime $sessiondate The date of the session to find. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sessionreglistsessionsAsync($token, $eventid, $sessiondate = null)
    {
        return $this->sessionreglistsessionsAsyncWithHttpInfo($token, $eventid, $sessiondate)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation sessionreglistsessionsAsyncWithHttpInfo
     *
     * List the sessions available for a specific event
     *
     * @param  string $token The authentication token. (required)
     * @param  string $eventid The event id to list sessions. (required)
     * @param  \DateTime $sessiondate The date of the session to find. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sessionreglistsessionsAsyncWithHttpInfo($token, $eventid, $sessiondate = null)
    {
        $returnType = '';
        $request = $this->sessionreglistsessionsRequest($token, $eventid, $sessiondate);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'sessionreglistsessions'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $eventid The event id to list sessions. (required)
     * @param  \DateTime $sessiondate The date of the session to find. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function sessionreglistsessionsRequest($token, $eventid, $sessiondate = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling sessionreglistsessions'
            );
        }
        // verify the required parameter 'eventid' is set
        if ($eventid === null || (is_array($eventid) && count($eventid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $eventid when calling sessionreglistsessions'
            );
        }

        $resourcePath = '/sessionreglistsessions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($eventid !== null) {
            if('form' === 'form' && is_array($eventid)) {
                foreach($eventid as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['eventid'] = $eventid;
            }
        }
        // query params
        if ($sessiondate !== null) {
            if('form' === 'form' && is_array($sessiondate)) {
                foreach($sessiondate as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['sessiondate'] = $sessiondate;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation sessionreglistupcoming
     *
     * View a list of upcoming event sessions
     *
     * @param  string $token The authentication token. (required)
     * @param  \DateTime $date Only sessions in the week of the specified date will be returned. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function sessionreglistupcoming($token, $date)
    {
        $this->sessionreglistupcomingWithHttpInfo($token, $date);
    }

    /**
     * Operation sessionreglistupcomingWithHttpInfo
     *
     * View a list of upcoming event sessions
     *
     * @param  string $token The authentication token. (required)
     * @param  \DateTime $date Only sessions in the week of the specified date will be returned. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function sessionreglistupcomingWithHttpInfo($token, $date)
    {
        $request = $this->sessionreglistupcomingRequest($token, $date);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation sessionreglistupcomingAsync
     *
     * View a list of upcoming event sessions
     *
     * @param  string $token The authentication token. (required)
     * @param  \DateTime $date Only sessions in the week of the specified date will be returned. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sessionreglistupcomingAsync($token, $date)
    {
        return $this->sessionreglistupcomingAsyncWithHttpInfo($token, $date)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation sessionreglistupcomingAsyncWithHttpInfo
     *
     * View a list of upcoming event sessions
     *
     * @param  string $token The authentication token. (required)
     * @param  \DateTime $date Only sessions in the week of the specified date will be returned. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sessionreglistupcomingAsyncWithHttpInfo($token, $date)
    {
        $returnType = '';
        $request = $this->sessionreglistupcomingRequest($token, $date);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'sessionreglistupcoming'
     *
     * @param  string $token The authentication token. (required)
     * @param  \DateTime $date Only sessions in the week of the specified date will be returned. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function sessionreglistupcomingRequest($token, $date)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling sessionreglistupcoming'
            );
        }
        // verify the required parameter 'date' is set
        if ($date === null || (is_array($date) && count($date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $date when calling sessionreglistupcoming'
            );
        }

        $resourcePath = '/sessionreglistupcoming';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($date !== null) {
            if('form' === 'form' && is_array($date)) {
                foreach($date as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['date'] = $date;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation sessionreglistupcomingevent
     *
     * View a list of upcoming sessions of a particular event
     *
     * @param  string $token The authentication token. (required)
     * @param  \DateTime $date Start date to filter the returned sessions. (required)
     * @param  string $event The id of the event whose sessions will be returned (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function sessionreglistupcomingevent($token, $date, $event)
    {
        $this->sessionreglistupcomingeventWithHttpInfo($token, $date, $event);
    }

    /**
     * Operation sessionreglistupcomingeventWithHttpInfo
     *
     * View a list of upcoming sessions of a particular event
     *
     * @param  string $token The authentication token. (required)
     * @param  \DateTime $date Start date to filter the returned sessions. (required)
     * @param  string $event The id of the event whose sessions will be returned (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function sessionreglistupcomingeventWithHttpInfo($token, $date, $event)
    {
        $request = $this->sessionreglistupcomingeventRequest($token, $date, $event);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation sessionreglistupcomingeventAsync
     *
     * View a list of upcoming sessions of a particular event
     *
     * @param  string $token The authentication token. (required)
     * @param  \DateTime $date Start date to filter the returned sessions. (required)
     * @param  string $event The id of the event whose sessions will be returned (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sessionreglistupcomingeventAsync($token, $date, $event)
    {
        return $this->sessionreglistupcomingeventAsyncWithHttpInfo($token, $date, $event)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation sessionreglistupcomingeventAsyncWithHttpInfo
     *
     * View a list of upcoming sessions of a particular event
     *
     * @param  string $token The authentication token. (required)
     * @param  \DateTime $date Start date to filter the returned sessions. (required)
     * @param  string $event The id of the event whose sessions will be returned (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sessionreglistupcomingeventAsyncWithHttpInfo($token, $date, $event)
    {
        $returnType = '';
        $request = $this->sessionreglistupcomingeventRequest($token, $date, $event);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'sessionreglistupcomingevent'
     *
     * @param  string $token The authentication token. (required)
     * @param  \DateTime $date Start date to filter the returned sessions. (required)
     * @param  string $event The id of the event whose sessions will be returned (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function sessionreglistupcomingeventRequest($token, $date, $event)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling sessionreglistupcomingevent'
            );
        }
        // verify the required parameter 'date' is set
        if ($date === null || (is_array($date) && count($date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $date when calling sessionreglistupcomingevent'
            );
        }
        // verify the required parameter 'event' is set
        if ($event === null || (is_array($event) && count($event) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $event when calling sessionreglistupcomingevent'
            );
        }

        $resourcePath = '/sessionreglistupcomingevent';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($date !== null) {
            if('form' === 'form' && is_array($date)) {
                foreach($date as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['date'] = $date;
            }
        }
        // query params
        if ($event !== null) {
            if('form' === 'form' && is_array($event)) {
                foreach($event as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['event'] = $event;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation sessionregremovecurrentuser
     *
     * Unregister current user from an event session
     *
     * @param  string $token The authentication token. (required)
     * @param  string $eventid The id of the event. (required)
     * @param  \DateTime $sessiondate The date and time when the session starts. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function sessionregremovecurrentuser($token, $eventid, $sessiondate)
    {
        $this->sessionregremovecurrentuserWithHttpInfo($token, $eventid, $sessiondate);
    }

    /**
     * Operation sessionregremovecurrentuserWithHttpInfo
     *
     * Unregister current user from an event session
     *
     * @param  string $token The authentication token. (required)
     * @param  string $eventid The id of the event. (required)
     * @param  \DateTime $sessiondate The date and time when the session starts. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function sessionregremovecurrentuserWithHttpInfo($token, $eventid, $sessiondate)
    {
        $request = $this->sessionregremovecurrentuserRequest($token, $eventid, $sessiondate);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation sessionregremovecurrentuserAsync
     *
     * Unregister current user from an event session
     *
     * @param  string $token The authentication token. (required)
     * @param  string $eventid The id of the event. (required)
     * @param  \DateTime $sessiondate The date and time when the session starts. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sessionregremovecurrentuserAsync($token, $eventid, $sessiondate)
    {
        return $this->sessionregremovecurrentuserAsyncWithHttpInfo($token, $eventid, $sessiondate)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation sessionregremovecurrentuserAsyncWithHttpInfo
     *
     * Unregister current user from an event session
     *
     * @param  string $token The authentication token. (required)
     * @param  string $eventid The id of the event. (required)
     * @param  \DateTime $sessiondate The date and time when the session starts. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sessionregremovecurrentuserAsyncWithHttpInfo($token, $eventid, $sessiondate)
    {
        $returnType = '';
        $request = $this->sessionregremovecurrentuserRequest($token, $eventid, $sessiondate);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'sessionregremovecurrentuser'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $eventid The id of the event. (required)
     * @param  \DateTime $sessiondate The date and time when the session starts. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function sessionregremovecurrentuserRequest($token, $eventid, $sessiondate)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling sessionregremovecurrentuser'
            );
        }
        // verify the required parameter 'eventid' is set
        if ($eventid === null || (is_array($eventid) && count($eventid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $eventid when calling sessionregremovecurrentuser'
            );
        }
        // verify the required parameter 'sessiondate' is set
        if ($sessiondate === null || (is_array($sessiondate) && count($sessiondate) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sessiondate when calling sessionregremovecurrentuser'
            );
        }

        $resourcePath = '/sessionregremovecurrentuser';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($eventid !== null) {
            if('form' === 'form' && is_array($eventid)) {
                foreach($eventid as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['eventid'] = $eventid;
            }
        }
        // query params
        if ($sessiondate !== null) {
            if('form' === 'form' && is_array($sessiondate)) {
                foreach($sessiondate as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['sessiondate'] = $sessiondate;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation sessionregremoveuser
     *
     * Removes a user from an event session
     *
     * @param  string $token The authentication token. (required)
     * @param  string $userid The id of the user to remove. (required)
     * @param  string $eventid The id of the event. (required)
     * @param  \DateTime $sessiondate The date and time when the session starts. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function sessionregremoveuser($token, $userid, $eventid, $sessiondate)
    {
        $this->sessionregremoveuserWithHttpInfo($token, $userid, $eventid, $sessiondate);
    }

    /**
     * Operation sessionregremoveuserWithHttpInfo
     *
     * Removes a user from an event session
     *
     * @param  string $token The authentication token. (required)
     * @param  string $userid The id of the user to remove. (required)
     * @param  string $eventid The id of the event. (required)
     * @param  \DateTime $sessiondate The date and time when the session starts. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function sessionregremoveuserWithHttpInfo($token, $userid, $eventid, $sessiondate)
    {
        $request = $this->sessionregremoveuserRequest($token, $userid, $eventid, $sessiondate);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation sessionregremoveuserAsync
     *
     * Removes a user from an event session
     *
     * @param  string $token The authentication token. (required)
     * @param  string $userid The id of the user to remove. (required)
     * @param  string $eventid The id of the event. (required)
     * @param  \DateTime $sessiondate The date and time when the session starts. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sessionregremoveuserAsync($token, $userid, $eventid, $sessiondate)
    {
        return $this->sessionregremoveuserAsyncWithHttpInfo($token, $userid, $eventid, $sessiondate)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation sessionregremoveuserAsyncWithHttpInfo
     *
     * Removes a user from an event session
     *
     * @param  string $token The authentication token. (required)
     * @param  string $userid The id of the user to remove. (required)
     * @param  string $eventid The id of the event. (required)
     * @param  \DateTime $sessiondate The date and time when the session starts. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sessionregremoveuserAsyncWithHttpInfo($token, $userid, $eventid, $sessiondate)
    {
        $returnType = '';
        $request = $this->sessionregremoveuserRequest($token, $userid, $eventid, $sessiondate);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'sessionregremoveuser'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $userid The id of the user to remove. (required)
     * @param  string $eventid The id of the event. (required)
     * @param  \DateTime $sessiondate The date and time when the session starts. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function sessionregremoveuserRequest($token, $userid, $eventid, $sessiondate)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling sessionregremoveuser'
            );
        }
        // verify the required parameter 'userid' is set
        if ($userid === null || (is_array($userid) && count($userid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userid when calling sessionregremoveuser'
            );
        }
        // verify the required parameter 'eventid' is set
        if ($eventid === null || (is_array($eventid) && count($eventid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $eventid when calling sessionregremoveuser'
            );
        }
        // verify the required parameter 'sessiondate' is set
        if ($sessiondate === null || (is_array($sessiondate) && count($sessiondate) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sessiondate when calling sessionregremoveuser'
            );
        }

        $resourcePath = '/sessionregremoveuser';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($userid !== null) {
            if('form' === 'form' && is_array($userid)) {
                foreach($userid as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['userid'] = $userid;
            }
        }
        // query params
        if ($eventid !== null) {
            if('form' === 'form' && is_array($eventid)) {
                foreach($eventid as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['eventid'] = $eventid;
            }
        }
        // query params
        if ($sessiondate !== null) {
            if('form' === 'form' && is_array($sessiondate)) {
                foreach($sessiondate as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['sessiondate'] = $sessiondate;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation sessionregsavesettings
     *
     * Save the settings for an event's session registration
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function sessionregsavesettings($unknown_base_type = null)
    {
        $this->sessionregsavesettingsWithHttpInfo($unknown_base_type);
    }

    /**
     * Operation sessionregsavesettingsWithHttpInfo
     *
     * Save the settings for an event's session registration
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function sessionregsavesettingsWithHttpInfo($unknown_base_type = null)
    {
        $request = $this->sessionregsavesettingsRequest($unknown_base_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation sessionregsavesettingsAsync
     *
     * Save the settings for an event's session registration
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sessionregsavesettingsAsync($unknown_base_type = null)
    {
        return $this->sessionregsavesettingsAsyncWithHttpInfo($unknown_base_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation sessionregsavesettingsAsyncWithHttpInfo
     *
     * Save the settings for an event's session registration
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sessionregsavesettingsAsyncWithHttpInfo($unknown_base_type = null)
    {
        $returnType = '';
        $request = $this->sessionregsavesettingsRequest($unknown_base_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'sessionregsavesettings'
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function sessionregsavesettingsRequest($unknown_base_type = null)
    {

        $resourcePath = '/sessionregsavesettings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($unknown_base_type)) {
            $_tempBody = $unknown_base_type;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation settingaddlogo
     *
     * Add a logo to the account
     *
     * @param  string $token The authentication token. (required)
     * @param  string $upload Set &#39;file&#39; as value to indicate that a file is being submitted in the body (instead of a JSON object). (required)
     * @param  string $filename The original filename, needed to process the file. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function settingaddlogo($token, $upload, $filename)
    {
        $this->settingaddlogoWithHttpInfo($token, $upload, $filename);
    }

    /**
     * Operation settingaddlogoWithHttpInfo
     *
     * Add a logo to the account
     *
     * @param  string $token The authentication token. (required)
     * @param  string $upload Set &#39;file&#39; as value to indicate that a file is being submitted in the body (instead of a JSON object). (required)
     * @param  string $filename The original filename, needed to process the file. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function settingaddlogoWithHttpInfo($token, $upload, $filename)
    {
        $request = $this->settingaddlogoRequest($token, $upload, $filename);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation settingaddlogoAsync
     *
     * Add a logo to the account
     *
     * @param  string $token The authentication token. (required)
     * @param  string $upload Set &#39;file&#39; as value to indicate that a file is being submitted in the body (instead of a JSON object). (required)
     * @param  string $filename The original filename, needed to process the file. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function settingaddlogoAsync($token, $upload, $filename)
    {
        return $this->settingaddlogoAsyncWithHttpInfo($token, $upload, $filename)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation settingaddlogoAsyncWithHttpInfo
     *
     * Add a logo to the account
     *
     * @param  string $token The authentication token. (required)
     * @param  string $upload Set &#39;file&#39; as value to indicate that a file is being submitted in the body (instead of a JSON object). (required)
     * @param  string $filename The original filename, needed to process the file. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function settingaddlogoAsyncWithHttpInfo($token, $upload, $filename)
    {
        $returnType = '';
        $request = $this->settingaddlogoRequest($token, $upload, $filename);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'settingaddlogo'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $upload Set &#39;file&#39; as value to indicate that a file is being submitted in the body (instead of a JSON object). (required)
     * @param  string $filename The original filename, needed to process the file. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function settingaddlogoRequest($token, $upload, $filename)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling settingaddlogo'
            );
        }
        // verify the required parameter 'upload' is set
        if ($upload === null || (is_array($upload) && count($upload) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $upload when calling settingaddlogo'
            );
        }
        // verify the required parameter 'filename' is set
        if ($filename === null || (is_array($filename) && count($filename) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $filename when calling settingaddlogo'
            );
        }

        $resourcePath = '/settingaddlogo';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($upload !== null) {
            if('form' === 'form' && is_array($upload)) {
                foreach($upload as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['upload'] = $upload;
            }
        }
        // query params
        if ($filename !== null) {
            if('form' === 'form' && is_array($filename)) {
                foreach($filename as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['filename'] = $filename;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation settingget
     *
     * Get settings for the account or the specified scope
     *
     * @param  string $keys The option keys to get values for. Enter multiple separated by comma. (required)
     * @param  string $token The authentication token. (optional)
     * @param  string $domain The account domain, in case of reading settings annonymously. (optional)
     * @param  string $scope The scope of the settings to get. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function settingget($keys, $token = null, $domain = null, $scope = null)
    {
        $this->settinggetWithHttpInfo($keys, $token, $domain, $scope);
    }

    /**
     * Operation settinggetWithHttpInfo
     *
     * Get settings for the account or the specified scope
     *
     * @param  string $keys The option keys to get values for. Enter multiple separated by comma. (required)
     * @param  string $token The authentication token. (optional)
     * @param  string $domain The account domain, in case of reading settings annonymously. (optional)
     * @param  string $scope The scope of the settings to get. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function settinggetWithHttpInfo($keys, $token = null, $domain = null, $scope = null)
    {
        $request = $this->settinggetRequest($keys, $token, $domain, $scope);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation settinggetAsync
     *
     * Get settings for the account or the specified scope
     *
     * @param  string $keys The option keys to get values for. Enter multiple separated by comma. (required)
     * @param  string $token The authentication token. (optional)
     * @param  string $domain The account domain, in case of reading settings annonymously. (optional)
     * @param  string $scope The scope of the settings to get. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function settinggetAsync($keys, $token = null, $domain = null, $scope = null)
    {
        return $this->settinggetAsyncWithHttpInfo($keys, $token, $domain, $scope)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation settinggetAsyncWithHttpInfo
     *
     * Get settings for the account or the specified scope
     *
     * @param  string $keys The option keys to get values for. Enter multiple separated by comma. (required)
     * @param  string $token The authentication token. (optional)
     * @param  string $domain The account domain, in case of reading settings annonymously. (optional)
     * @param  string $scope The scope of the settings to get. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function settinggetAsyncWithHttpInfo($keys, $token = null, $domain = null, $scope = null)
    {
        $returnType = '';
        $request = $this->settinggetRequest($keys, $token, $domain, $scope);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'settingget'
     *
     * @param  string $keys The option keys to get values for. Enter multiple separated by comma. (required)
     * @param  string $token The authentication token. (optional)
     * @param  string $domain The account domain, in case of reading settings annonymously. (optional)
     * @param  string $scope The scope of the settings to get. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function settinggetRequest($keys, $token = null, $domain = null, $scope = null)
    {
        // verify the required parameter 'keys' is set
        if ($keys === null || (is_array($keys) && count($keys) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $keys when calling settingget'
            );
        }

        $resourcePath = '/settingget';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($domain !== null) {
            if('form' === 'form' && is_array($domain)) {
                foreach($domain as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['domain'] = $domain;
            }
        }
        // query params
        if ($keys !== null) {
            if('form' === 'form' && is_array($keys)) {
                foreach($keys as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['keys'] = $keys;
            }
        }
        // query params
        if ($scope !== null) {
            if('form' === 'form' && is_array($scope)) {
                foreach($scope as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['scope'] = $scope;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation settingsave
     *
     * Save settings for the account or the specified scope
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function settingsave($unknown_base_type = null)
    {
        $this->settingsaveWithHttpInfo($unknown_base_type);
    }

    /**
     * Operation settingsaveWithHttpInfo
     *
     * Save settings for the account or the specified scope
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function settingsaveWithHttpInfo($unknown_base_type = null)
    {
        $request = $this->settingsaveRequest($unknown_base_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation settingsaveAsync
     *
     * Save settings for the account or the specified scope
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function settingsaveAsync($unknown_base_type = null)
    {
        return $this->settingsaveAsyncWithHttpInfo($unknown_base_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation settingsaveAsyncWithHttpInfo
     *
     * Save settings for the account or the specified scope
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function settingsaveAsyncWithHttpInfo($unknown_base_type = null)
    {
        $returnType = '';
        $request = $this->settingsaveRequest($unknown_base_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'settingsave'
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function settingsaveRequest($unknown_base_type = null)
    {

        $resourcePath = '/settingsave';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($unknown_base_type)) {
            $_tempBody = $unknown_base_type;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation settingviewgeneral
     *
     * View general settings for the account
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function settingviewgeneral($token)
    {
        $this->settingviewgeneralWithHttpInfo($token);
    }

    /**
     * Operation settingviewgeneralWithHttpInfo
     *
     * View general settings for the account
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function settingviewgeneralWithHttpInfo($token)
    {
        $request = $this->settingviewgeneralRequest($token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation settingviewgeneralAsync
     *
     * View general settings for the account
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function settingviewgeneralAsync($token)
    {
        return $this->settingviewgeneralAsyncWithHttpInfo($token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation settingviewgeneralAsyncWithHttpInfo
     *
     * View general settings for the account
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function settingviewgeneralAsyncWithHttpInfo($token)
    {
        $returnType = '';
        $request = $this->settingviewgeneralRequest($token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'settingviewgeneral'
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function settingviewgeneralRequest($token)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling settingviewgeneral'
            );
        }

        $resourcePath = '/settingviewgeneral';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ssogeneratekey
     *
     * Generate/reset single sign on access key.
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function ssogeneratekey($token)
    {
        $this->ssogeneratekeyWithHttpInfo($token);
    }

    /**
     * Operation ssogeneratekeyWithHttpInfo
     *
     * Generate/reset single sign on access key.
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function ssogeneratekeyWithHttpInfo($token)
    {
        $request = $this->ssogeneratekeyRequest($token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation ssogeneratekeyAsync
     *
     * Generate/reset single sign on access key.
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ssogeneratekeyAsync($token)
    {
        return $this->ssogeneratekeyAsyncWithHttpInfo($token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ssogeneratekeyAsyncWithHttpInfo
     *
     * Generate/reset single sign on access key.
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ssogeneratekeyAsyncWithHttpInfo($token)
    {
        $returnType = '';
        $request = $this->ssogeneratekeyRequest($token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ssogeneratekey'
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function ssogeneratekeyRequest($token)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling ssogeneratekey'
            );
        }

        $resourcePath = '/ssogeneratekey';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ssogetsettings
     *
     * View single sign on settings.
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function ssogetsettings($token)
    {
        $this->ssogetsettingsWithHttpInfo($token);
    }

    /**
     * Operation ssogetsettingsWithHttpInfo
     *
     * View single sign on settings.
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function ssogetsettingsWithHttpInfo($token)
    {
        $request = $this->ssogetsettingsRequest($token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation ssogetsettingsAsync
     *
     * View single sign on settings.
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ssogetsettingsAsync($token)
    {
        return $this->ssogetsettingsAsyncWithHttpInfo($token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ssogetsettingsAsyncWithHttpInfo
     *
     * View single sign on settings.
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ssogetsettingsAsyncWithHttpInfo($token)
    {
        $returnType = '';
        $request = $this->ssogetsettingsRequest($token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ssogetsettings'
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function ssogetsettingsRequest($token)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling ssogetsettings'
            );
        }

        $resourcePath = '/ssogetsettings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ssoissuetoken
     *
     * Issue single sign-on token
     *
     * @param  string $key The single sign-on key of the account. (required)
     * @param  string $username The email of the user to sign-on. (required)
     * @param  bool $expires Specifies whether the session should expire when inactive. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function ssoissuetoken($key, $username, $expires = null)
    {
        $this->ssoissuetokenWithHttpInfo($key, $username, $expires);
    }

    /**
     * Operation ssoissuetokenWithHttpInfo
     *
     * Issue single sign-on token
     *
     * @param  string $key The single sign-on key of the account. (required)
     * @param  string $username The email of the user to sign-on. (required)
     * @param  bool $expires Specifies whether the session should expire when inactive. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function ssoissuetokenWithHttpInfo($key, $username, $expires = null)
    {
        $request = $this->ssoissuetokenRequest($key, $username, $expires);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation ssoissuetokenAsync
     *
     * Issue single sign-on token
     *
     * @param  string $key The single sign-on key of the account. (required)
     * @param  string $username The email of the user to sign-on. (required)
     * @param  bool $expires Specifies whether the session should expire when inactive. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ssoissuetokenAsync($key, $username, $expires = null)
    {
        return $this->ssoissuetokenAsyncWithHttpInfo($key, $username, $expires)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ssoissuetokenAsyncWithHttpInfo
     *
     * Issue single sign-on token
     *
     * @param  string $key The single sign-on key of the account. (required)
     * @param  string $username The email of the user to sign-on. (required)
     * @param  bool $expires Specifies whether the session should expire when inactive. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ssoissuetokenAsyncWithHttpInfo($key, $username, $expires = null)
    {
        $returnType = '';
        $request = $this->ssoissuetokenRequest($key, $username, $expires);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ssoissuetoken'
     *
     * @param  string $key The single sign-on key of the account. (required)
     * @param  string $username The email of the user to sign-on. (required)
     * @param  bool $expires Specifies whether the session should expire when inactive. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function ssoissuetokenRequest($key, $username, $expires = null)
    {
        // verify the required parameter 'key' is set
        if ($key === null || (is_array($key) && count($key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $key when calling ssoissuetoken'
            );
        }
        // verify the required parameter 'username' is set
        if ($username === null || (is_array($username) && count($username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $username when calling ssoissuetoken'
            );
        }

        $resourcePath = '/ssoissuetoken';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($key !== null) {
            if('form' === 'form' && is_array($key)) {
                foreach($key as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['key'] = $key;
            }
        }
        // query params
        if ($username !== null) {
            if('form' === 'form' && is_array($username)) {
                foreach($username as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['username'] = $username;
            }
        }
        // query params
        if ($expires !== null) {
            if('form' === 'form' && is_array($expires)) {
                foreach($expires as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['expires'] = $expires;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ssosavesettings
     *
     * Edit single sign-on settings.
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function ssosavesettings($unknown_base_type = null)
    {
        $this->ssosavesettingsWithHttpInfo($unknown_base_type);
    }

    /**
     * Operation ssosavesettingsWithHttpInfo
     *
     * Edit single sign-on settings.
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function ssosavesettingsWithHttpInfo($unknown_base_type = null)
    {
        $request = $this->ssosavesettingsRequest($unknown_base_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation ssosavesettingsAsync
     *
     * Edit single sign-on settings.
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ssosavesettingsAsync($unknown_base_type = null)
    {
        return $this->ssosavesettingsAsyncWithHttpInfo($unknown_base_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ssosavesettingsAsyncWithHttpInfo
     *
     * Edit single sign-on settings.
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ssosavesettingsAsyncWithHttpInfo($unknown_base_type = null)
    {
        $returnType = '';
        $request = $this->ssosavesettingsRequest($unknown_base_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ssosavesettings'
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function ssosavesettingsRequest($unknown_base_type = null)
    {

        $resourcePath = '/ssosavesettings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($unknown_base_type)) {
            $_tempBody = $unknown_base_type;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation stationdelete
     *
     * Delete a sign-in station
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the sign-in station to delete. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function stationdelete($token, $id)
    {
        $this->stationdeleteWithHttpInfo($token, $id);
    }

    /**
     * Operation stationdeleteWithHttpInfo
     *
     * Delete a sign-in station
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the sign-in station to delete. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function stationdeleteWithHttpInfo($token, $id)
    {
        $request = $this->stationdeleteRequest($token, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation stationdeleteAsync
     *
     * Delete a sign-in station
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the sign-in station to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stationdeleteAsync($token, $id)
    {
        return $this->stationdeleteAsyncWithHttpInfo($token, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation stationdeleteAsyncWithHttpInfo
     *
     * Delete a sign-in station
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the sign-in station to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stationdeleteAsyncWithHttpInfo($token, $id)
    {
        $returnType = '';
        $request = $this->stationdeleteRequest($token, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'stationdelete'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the sign-in station to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function stationdeleteRequest($token, $id)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling stationdelete'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling stationdelete'
            );
        }

        $resourcePath = '/stationdelete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($id !== null) {
            if('form' === 'form' && is_array($id)) {
                foreach($id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['id'] = $id;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation stationget
     *
     * View details of a sign-in station
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the sign-in station to get. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function stationget($token, $id)
    {
        $this->stationgetWithHttpInfo($token, $id);
    }

    /**
     * Operation stationgetWithHttpInfo
     *
     * View details of a sign-in station
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the sign-in station to get. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function stationgetWithHttpInfo($token, $id)
    {
        $request = $this->stationgetRequest($token, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation stationgetAsync
     *
     * View details of a sign-in station
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the sign-in station to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stationgetAsync($token, $id)
    {
        return $this->stationgetAsyncWithHttpInfo($token, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation stationgetAsyncWithHttpInfo
     *
     * View details of a sign-in station
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the sign-in station to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stationgetAsyncWithHttpInfo($token, $id)
    {
        $returnType = '';
        $request = $this->stationgetRequest($token, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'stationget'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the sign-in station to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function stationgetRequest($token, $id)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling stationget'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling stationget'
            );
        }

        $resourcePath = '/stationget';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($id !== null) {
            if('form' === 'form' && is_array($id)) {
                foreach($id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['id'] = $id;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation stationgetcurrentterms
     *
     * Get all the current terms
     *
     * @param  string $station The id of the sign-in station whose account&#39;s current terms have to be retrieved. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function stationgetcurrentterms($station)
    {
        $this->stationgetcurrenttermsWithHttpInfo($station);
    }

    /**
     * Operation stationgetcurrenttermsWithHttpInfo
     *
     * Get all the current terms
     *
     * @param  string $station The id of the sign-in station whose account&#39;s current terms have to be retrieved. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function stationgetcurrenttermsWithHttpInfo($station)
    {
        $request = $this->stationgetcurrenttermsRequest($station);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation stationgetcurrenttermsAsync
     *
     * Get all the current terms
     *
     * @param  string $station The id of the sign-in station whose account&#39;s current terms have to be retrieved. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stationgetcurrenttermsAsync($station)
    {
        return $this->stationgetcurrenttermsAsyncWithHttpInfo($station)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation stationgetcurrenttermsAsyncWithHttpInfo
     *
     * Get all the current terms
     *
     * @param  string $station The id of the sign-in station whose account&#39;s current terms have to be retrieved. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stationgetcurrenttermsAsyncWithHttpInfo($station)
    {
        $returnType = '';
        $request = $this->stationgetcurrenttermsRequest($station);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'stationgetcurrentterms'
     *
     * @param  string $station The id of the sign-in station whose account&#39;s current terms have to be retrieved. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function stationgetcurrenttermsRequest($station)
    {
        // verify the required parameter 'station' is set
        if ($station === null || (is_array($station) && count($station) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $station when calling stationgetcurrentterms'
            );
        }

        $resourcePath = '/stationgetcurrentterms';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($station !== null) {
            if('form' === 'form' && is_array($station)) {
                foreach($station as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['station'] = $station;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation stationgetinfo
     *
     * Gets a the info to display in the sign-in station by it's ID.
     *
     * @param  string $id The id of the sign-in station to get. (required)
     * @param  string $event The id of the event, to override the one by schedule. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function stationgetinfo($id, $event = null)
    {
        $this->stationgetinfoWithHttpInfo($id, $event);
    }

    /**
     * Operation stationgetinfoWithHttpInfo
     *
     * Gets a the info to display in the sign-in station by it's ID.
     *
     * @param  string $id The id of the sign-in station to get. (required)
     * @param  string $event The id of the event, to override the one by schedule. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function stationgetinfoWithHttpInfo($id, $event = null)
    {
        $request = $this->stationgetinfoRequest($id, $event);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation stationgetinfoAsync
     *
     * Gets a the info to display in the sign-in station by it's ID.
     *
     * @param  string $id The id of the sign-in station to get. (required)
     * @param  string $event The id of the event, to override the one by schedule. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stationgetinfoAsync($id, $event = null)
    {
        return $this->stationgetinfoAsyncWithHttpInfo($id, $event)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation stationgetinfoAsyncWithHttpInfo
     *
     * Gets a the info to display in the sign-in station by it's ID.
     *
     * @param  string $id The id of the sign-in station to get. (required)
     * @param  string $event The id of the event, to override the one by schedule. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stationgetinfoAsyncWithHttpInfo($id, $event = null)
    {
        $returnType = '';
        $request = $this->stationgetinfoRequest($id, $event);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'stationgetinfo'
     *
     * @param  string $id The id of the sign-in station to get. (required)
     * @param  string $event The id of the event, to override the one by schedule. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function stationgetinfoRequest($id, $event = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling stationgetinfo'
            );
        }

        $resourcePath = '/stationgetinfo';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($id !== null) {
            if('form' === 'form' && is_array($id)) {
                foreach($id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['id'] = $id;
            }
        }
        // query params
        if ($event !== null) {
            if('form' === 'form' && is_array($event)) {
                foreach($event as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['event'] = $event;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation stationgetlicense
     *
     * Gets the current license information
     *
     * @param  string $station The id of the sign-in station whose account&#39;s license has to be retrieved. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function stationgetlicense($station)
    {
        $this->stationgetlicenseWithHttpInfo($station);
    }

    /**
     * Operation stationgetlicenseWithHttpInfo
     *
     * Gets the current license information
     *
     * @param  string $station The id of the sign-in station whose account&#39;s license has to be retrieved. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function stationgetlicenseWithHttpInfo($station)
    {
        $request = $this->stationgetlicenseRequest($station);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation stationgetlicenseAsync
     *
     * Gets the current license information
     *
     * @param  string $station The id of the sign-in station whose account&#39;s license has to be retrieved. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stationgetlicenseAsync($station)
    {
        return $this->stationgetlicenseAsyncWithHttpInfo($station)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation stationgetlicenseAsyncWithHttpInfo
     *
     * Gets the current license information
     *
     * @param  string $station The id of the sign-in station whose account&#39;s license has to be retrieved. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stationgetlicenseAsyncWithHttpInfo($station)
    {
        $returnType = '';
        $request = $this->stationgetlicenseRequest($station);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'stationgetlicense'
     *
     * @param  string $station The id of the sign-in station whose account&#39;s license has to be retrieved. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function stationgetlicenseRequest($station)
    {
        // verify the required parameter 'station' is set
        if ($station === null || (is_array($station) && count($station) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $station when calling stationgetlicense'
            );
        }

        $resourcePath = '/stationgetlicense';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($station !== null) {
            if('form' === 'form' && is_array($station)) {
                foreach($station as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['station'] = $station;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation stationlist
     *
     * View a list of sign-in stations
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function stationlist($token, $from, $count)
    {
        $this->stationlistWithHttpInfo($token, $from, $count);
    }

    /**
     * Operation stationlistWithHttpInfo
     *
     * View a list of sign-in stations
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function stationlistWithHttpInfo($token, $from, $count)
    {
        $request = $this->stationlistRequest($token, $from, $count);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation stationlistAsync
     *
     * View a list of sign-in stations
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stationlistAsync($token, $from, $count)
    {
        return $this->stationlistAsyncWithHttpInfo($token, $from, $count)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation stationlistAsyncWithHttpInfo
     *
     * View a list of sign-in stations
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stationlistAsyncWithHttpInfo($token, $from, $count)
    {
        $returnType = '';
        $request = $this->stationlistRequest($token, $from, $count);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'stationlist'
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function stationlistRequest($token, $from, $count)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling stationlist'
            );
        }
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling stationlist'
            );
        }
        // verify the required parameter 'count' is set
        if ($count === null || (is_array($count) && count($count) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $count when calling stationlist'
            );
        }

        $resourcePath = '/stationlist';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }
        // query params
        if ($count !== null) {
            if('form' === 'form' && is_array($count)) {
                foreach($count as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['count'] = $count;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation stationsave
     *
     * Create or edit a sign-in station
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function stationsave($unknown_base_type = null)
    {
        $this->stationsaveWithHttpInfo($unknown_base_type);
    }

    /**
     * Operation stationsaveWithHttpInfo
     *
     * Create or edit a sign-in station
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function stationsaveWithHttpInfo($unknown_base_type = null)
    {
        $request = $this->stationsaveRequest($unknown_base_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation stationsaveAsync
     *
     * Create or edit a sign-in station
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stationsaveAsync($unknown_base_type = null)
    {
        return $this->stationsaveAsyncWithHttpInfo($unknown_base_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation stationsaveAsyncWithHttpInfo
     *
     * Create or edit a sign-in station
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stationsaveAsyncWithHttpInfo($unknown_base_type = null)
    {
        $returnType = '';
        $request = $this->stationsaveRequest($unknown_base_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'stationsave'
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function stationsaveRequest($unknown_base_type = null)
    {

        $resourcePath = '/stationsave';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($unknown_base_type)) {
            $_tempBody = $unknown_base_type;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation stationunlock
     *
     * Unlocks the sign-in station.
     *
     * @param  string $id The id of the sign-in station to unlock. (required)
     * @param  string $passcode The passcode to unlock the station. (required)
     * @param  string $method The authentication method. Valid values are &#39;token&#39; and &#39;cookie&#39;. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function stationunlock($id, $passcode, $method)
    {
        $this->stationunlockWithHttpInfo($id, $passcode, $method);
    }

    /**
     * Operation stationunlockWithHttpInfo
     *
     * Unlocks the sign-in station.
     *
     * @param  string $id The id of the sign-in station to unlock. (required)
     * @param  string $passcode The passcode to unlock the station. (required)
     * @param  string $method The authentication method. Valid values are &#39;token&#39; and &#39;cookie&#39;. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function stationunlockWithHttpInfo($id, $passcode, $method)
    {
        $request = $this->stationunlockRequest($id, $passcode, $method);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation stationunlockAsync
     *
     * Unlocks the sign-in station.
     *
     * @param  string $id The id of the sign-in station to unlock. (required)
     * @param  string $passcode The passcode to unlock the station. (required)
     * @param  string $method The authentication method. Valid values are &#39;token&#39; and &#39;cookie&#39;. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stationunlockAsync($id, $passcode, $method)
    {
        return $this->stationunlockAsyncWithHttpInfo($id, $passcode, $method)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation stationunlockAsyncWithHttpInfo
     *
     * Unlocks the sign-in station.
     *
     * @param  string $id The id of the sign-in station to unlock. (required)
     * @param  string $passcode The passcode to unlock the station. (required)
     * @param  string $method The authentication method. Valid values are &#39;token&#39; and &#39;cookie&#39;. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stationunlockAsyncWithHttpInfo($id, $passcode, $method)
    {
        $returnType = '';
        $request = $this->stationunlockRequest($id, $passcode, $method);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'stationunlock'
     *
     * @param  string $id The id of the sign-in station to unlock. (required)
     * @param  string $passcode The passcode to unlock the station. (required)
     * @param  string $method The authentication method. Valid values are &#39;token&#39; and &#39;cookie&#39;. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function stationunlockRequest($id, $passcode, $method)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling stationunlock'
            );
        }
        // verify the required parameter 'passcode' is set
        if ($passcode === null || (is_array($passcode) && count($passcode) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $passcode when calling stationunlock'
            );
        }
        // verify the required parameter 'method' is set
        if ($method === null || (is_array($method) && count($method) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $method when calling stationunlock'
            );
        }

        $resourcePath = '/stationunlock';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($id !== null) {
            if('form' === 'form' && is_array($id)) {
                foreach($id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['id'] = $id;
            }
        }
        // query params
        if ($passcode !== null) {
            if('form' === 'form' && is_array($passcode)) {
                foreach($passcode as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['passcode'] = $passcode;
            }
        }
        // query params
        if ($method !== null) {
            if('form' === 'form' && is_array($method)) {
                foreach($method as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['method'] = $method;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation swipedelete
     *
     * Delete a swipe
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the swipe to delete. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function swipedelete($token, $id)
    {
        $this->swipedeleteWithHttpInfo($token, $id);
    }

    /**
     * Operation swipedeleteWithHttpInfo
     *
     * Delete a swipe
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the swipe to delete. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function swipedeleteWithHttpInfo($token, $id)
    {
        $request = $this->swipedeleteRequest($token, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation swipedeleteAsync
     *
     * Delete a swipe
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the swipe to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function swipedeleteAsync($token, $id)
    {
        return $this->swipedeleteAsyncWithHttpInfo($token, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation swipedeleteAsyncWithHttpInfo
     *
     * Delete a swipe
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the swipe to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function swipedeleteAsyncWithHttpInfo($token, $id)
    {
        $returnType = '';
        $request = $this->swipedeleteRequest($token, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'swipedelete'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the swipe to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function swipedeleteRequest($token, $id)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling swipedelete'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling swipedelete'
            );
        }

        $resourcePath = '/swipedelete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($id !== null) {
            if('form' === 'form' && is_array($id)) {
                foreach($id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['id'] = $id;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation swipeget
     *
     * Search and view details of a swipe
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the swipe to get. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function swipeget($token, $id)
    {
        $this->swipegetWithHttpInfo($token, $id);
    }

    /**
     * Operation swipegetWithHttpInfo
     *
     * Search and view details of a swipe
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the swipe to get. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function swipegetWithHttpInfo($token, $id)
    {
        $request = $this->swipegetRequest($token, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation swipegetAsync
     *
     * Search and view details of a swipe
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the swipe to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function swipegetAsync($token, $id)
    {
        return $this->swipegetAsyncWithHttpInfo($token, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation swipegetAsyncWithHttpInfo
     *
     * Search and view details of a swipe
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the swipe to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function swipegetAsyncWithHttpInfo($token, $id)
    {
        $returnType = '';
        $request = $this->swipegetRequest($token, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'swipeget'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the swipe to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function swipegetRequest($token, $id)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling swipeget'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling swipeget'
            );
        }

        $resourcePath = '/swipeget';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($id !== null) {
            if('form' === 'form' && is_array($id)) {
                foreach($id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['id'] = $id;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation swipelist
     *
     * View a list of swipes
     *
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $token The authentication token. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function swipelist($from, $count, $token = null)
    {
        $this->swipelistWithHttpInfo($from, $count, $token);
    }

    /**
     * Operation swipelistWithHttpInfo
     *
     * View a list of swipes
     *
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $token The authentication token. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function swipelistWithHttpInfo($from, $count, $token = null)
    {
        $request = $this->swipelistRequest($from, $count, $token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation swipelistAsync
     *
     * View a list of swipes
     *
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $token The authentication token. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function swipelistAsync($from, $count, $token = null)
    {
        return $this->swipelistAsyncWithHttpInfo($from, $count, $token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation swipelistAsyncWithHttpInfo
     *
     * View a list of swipes
     *
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $token The authentication token. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function swipelistAsyncWithHttpInfo($from, $count, $token = null)
    {
        $returnType = '';
        $request = $this->swipelistRequest($from, $count, $token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'swipelist'
     *
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $token The authentication token. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function swipelistRequest($from, $count, $token = null)
    {
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling swipelist'
            );
        }
        // verify the required parameter 'count' is set
        if ($count === null || (is_array($count) && count($count) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $count when calling swipelist'
            );
        }

        $resourcePath = '/swipelist';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }
        // query params
        if ($count !== null) {
            if('form' === 'form' && is_array($count)) {
                foreach($count as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['count'] = $count;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation swipesave
     *
     * Create or edit a swipe, and if possible, save the related attendance log
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function swipesave($unknown_base_type = null)
    {
        $this->swipesaveWithHttpInfo($unknown_base_type);
    }

    /**
     * Operation swipesaveWithHttpInfo
     *
     * Create or edit a swipe, and if possible, save the related attendance log
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function swipesaveWithHttpInfo($unknown_base_type = null)
    {
        $request = $this->swipesaveRequest($unknown_base_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation swipesaveAsync
     *
     * Create or edit a swipe, and if possible, save the related attendance log
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function swipesaveAsync($unknown_base_type = null)
    {
        return $this->swipesaveAsyncWithHttpInfo($unknown_base_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation swipesaveAsyncWithHttpInfo
     *
     * Create or edit a swipe, and if possible, save the related attendance log
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function swipesaveAsyncWithHttpInfo($unknown_base_type = null)
    {
        $returnType = '';
        $request = $this->swipesaveRequest($unknown_base_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'swipesave'
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function swipesaveRequest($unknown_base_type = null)
    {

        $resourcePath = '/swipesave';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($unknown_base_type)) {
            $_tempBody = $unknown_base_type;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation swipesaveanonym
     *
     * Creates a new swipe from a sign-in station, and if possible, creates the attendance log
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function swipesaveanonym($unknown_base_type = null)
    {
        $this->swipesaveanonymWithHttpInfo($unknown_base_type);
    }

    /**
     * Operation swipesaveanonymWithHttpInfo
     *
     * Creates a new swipe from a sign-in station, and if possible, creates the attendance log
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function swipesaveanonymWithHttpInfo($unknown_base_type = null)
    {
        $request = $this->swipesaveanonymRequest($unknown_base_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation swipesaveanonymAsync
     *
     * Creates a new swipe from a sign-in station, and if possible, creates the attendance log
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function swipesaveanonymAsync($unknown_base_type = null)
    {
        return $this->swipesaveanonymAsyncWithHttpInfo($unknown_base_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation swipesaveanonymAsyncWithHttpInfo
     *
     * Creates a new swipe from a sign-in station, and if possible, creates the attendance log
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function swipesaveanonymAsyncWithHttpInfo($unknown_base_type = null)
    {
        $returnType = '';
        $request = $this->swipesaveanonymRequest($unknown_base_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'swipesaveanonym'
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function swipesaveanonymRequest($unknown_base_type = null)
    {

        $resourcePath = '/swipesaveanonym';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($unknown_base_type)) {
            $_tempBody = $unknown_base_type;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation tagdelete
     *
     * Delete a tag
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the tag to delete. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function tagdelete($token, $id)
    {
        $this->tagdeleteWithHttpInfo($token, $id);
    }

    /**
     * Operation tagdeleteWithHttpInfo
     *
     * Delete a tag
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the tag to delete. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function tagdeleteWithHttpInfo($token, $id)
    {
        $request = $this->tagdeleteRequest($token, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation tagdeleteAsync
     *
     * Delete a tag
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the tag to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tagdeleteAsync($token, $id)
    {
        return $this->tagdeleteAsyncWithHttpInfo($token, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation tagdeleteAsyncWithHttpInfo
     *
     * Delete a tag
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the tag to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tagdeleteAsyncWithHttpInfo($token, $id)
    {
        $returnType = '';
        $request = $this->tagdeleteRequest($token, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'tagdelete'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the tag to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function tagdeleteRequest($token, $id)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling tagdelete'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling tagdelete'
            );
        }

        $resourcePath = '/tagdelete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($id !== null) {
            if('form' === 'form' && is_array($id)) {
                foreach($id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['id'] = $id;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation tagget
     *
     * View details of a specified tag
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the tag to get. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function tagget($token, $id)
    {
        $this->taggetWithHttpInfo($token, $id);
    }

    /**
     * Operation taggetWithHttpInfo
     *
     * View details of a specified tag
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the tag to get. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function taggetWithHttpInfo($token, $id)
    {
        $request = $this->taggetRequest($token, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation taggetAsync
     *
     * View details of a specified tag
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the tag to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taggetAsync($token, $id)
    {
        return $this->taggetAsyncWithHttpInfo($token, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taggetAsyncWithHttpInfo
     *
     * View details of a specified tag
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the tag to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taggetAsyncWithHttpInfo($token, $id)
    {
        $returnType = '';
        $request = $this->taggetRequest($token, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'tagget'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the tag to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taggetRequest($token, $id)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling tagget'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling tagget'
            );
        }

        $resourcePath = '/tagget';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($id !== null) {
            if('form' === 'form' && is_array($id)) {
                foreach($id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['id'] = $id;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation taglist
     *
     * View a list of tags
     *
     * @param  string $token The authentication token. (required)
     * @param  string $group The group of the tags to return. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function taglist($token, $group, $from, $count)
    {
        $this->taglistWithHttpInfo($token, $group, $from, $count);
    }

    /**
     * Operation taglistWithHttpInfo
     *
     * View a list of tags
     *
     * @param  string $token The authentication token. (required)
     * @param  string $group The group of the tags to return. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function taglistWithHttpInfo($token, $group, $from, $count)
    {
        $request = $this->taglistRequest($token, $group, $from, $count);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation taglistAsync
     *
     * View a list of tags
     *
     * @param  string $token The authentication token. (required)
     * @param  string $group The group of the tags to return. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taglistAsync($token, $group, $from, $count)
    {
        return $this->taglistAsyncWithHttpInfo($token, $group, $from, $count)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taglistAsyncWithHttpInfo
     *
     * View a list of tags
     *
     * @param  string $token The authentication token. (required)
     * @param  string $group The group of the tags to return. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taglistAsyncWithHttpInfo($token, $group, $from, $count)
    {
        $returnType = '';
        $request = $this->taglistRequest($token, $group, $from, $count);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'taglist'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $group The group of the tags to return. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taglistRequest($token, $group, $from, $count)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling taglist'
            );
        }
        // verify the required parameter 'group' is set
        if ($group === null || (is_array($group) && count($group) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group when calling taglist'
            );
        }
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling taglist'
            );
        }
        // verify the required parameter 'count' is set
        if ($count === null || (is_array($count) && count($count) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $count when calling taglist'
            );
        }

        $resourcePath = '/taglist';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($group !== null) {
            if('form' === 'form' && is_array($group)) {
                foreach($group as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['group'] = $group;
            }
        }
        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }
        // query params
        if ($count !== null) {
            if('form' === 'form' && is_array($count)) {
                foreach($count as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['count'] = $count;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation taglistgroups
     *
     * View a list of entities that can be tagged
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function taglistgroups($token)
    {
        $this->taglistgroupsWithHttpInfo($token);
    }

    /**
     * Operation taglistgroupsWithHttpInfo
     *
     * View a list of entities that can be tagged
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function taglistgroupsWithHttpInfo($token)
    {
        $request = $this->taglistgroupsRequest($token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation taglistgroupsAsync
     *
     * View a list of entities that can be tagged
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taglistgroupsAsync($token)
    {
        return $this->taglistgroupsAsyncWithHttpInfo($token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation taglistgroupsAsyncWithHttpInfo
     *
     * View a list of entities that can be tagged
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function taglistgroupsAsyncWithHttpInfo($token)
    {
        $returnType = '';
        $request = $this->taglistgroupsRequest($token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'taglistgroups'
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function taglistgroupsRequest($token)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling taglistgroups'
            );
        }

        $resourcePath = '/taglistgroups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation tagsave
     *
     * Create or edit a tag
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function tagsave($unknown_base_type = null)
    {
        $this->tagsaveWithHttpInfo($unknown_base_type);
    }

    /**
     * Operation tagsaveWithHttpInfo
     *
     * Create or edit a tag
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function tagsaveWithHttpInfo($unknown_base_type = null)
    {
        $request = $this->tagsaveRequest($unknown_base_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation tagsaveAsync
     *
     * Create or edit a tag
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tagsaveAsync($unknown_base_type = null)
    {
        return $this->tagsaveAsyncWithHttpInfo($unknown_base_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation tagsaveAsyncWithHttpInfo
     *
     * Create or edit a tag
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tagsaveAsyncWithHttpInfo($unknown_base_type = null)
    {
        $returnType = '';
        $request = $this->tagsaveRequest($unknown_base_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'tagsave'
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function tagsaveRequest($unknown_base_type = null)
    {

        $resourcePath = '/tagsave';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($unknown_base_type)) {
            $_tempBody = $unknown_base_type;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation tagsearch
     *
     * Search for tags in the account
     *
     * @param  string $token The authentication token. (required)
     * @param  string $query The query to search tags. Use group:&lt;group&gt; to search in a specific group (mandatory). (required)
     * @param  bool $allowcreatingnew Specifies whether an option to create a new tag should be retrieved. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function tagsearch($token, $query, $allowcreatingnew = null)
    {
        $this->tagsearchWithHttpInfo($token, $query, $allowcreatingnew);
    }

    /**
     * Operation tagsearchWithHttpInfo
     *
     * Search for tags in the account
     *
     * @param  string $token The authentication token. (required)
     * @param  string $query The query to search tags. Use group:&lt;group&gt; to search in a specific group (mandatory). (required)
     * @param  bool $allowcreatingnew Specifies whether an option to create a new tag should be retrieved. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function tagsearchWithHttpInfo($token, $query, $allowcreatingnew = null)
    {
        $request = $this->tagsearchRequest($token, $query, $allowcreatingnew);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation tagsearchAsync
     *
     * Search for tags in the account
     *
     * @param  string $token The authentication token. (required)
     * @param  string $query The query to search tags. Use group:&lt;group&gt; to search in a specific group (mandatory). (required)
     * @param  bool $allowcreatingnew Specifies whether an option to create a new tag should be retrieved. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tagsearchAsync($token, $query, $allowcreatingnew = null)
    {
        return $this->tagsearchAsyncWithHttpInfo($token, $query, $allowcreatingnew)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation tagsearchAsyncWithHttpInfo
     *
     * Search for tags in the account
     *
     * @param  string $token The authentication token. (required)
     * @param  string $query The query to search tags. Use group:&lt;group&gt; to search in a specific group (mandatory). (required)
     * @param  bool $allowcreatingnew Specifies whether an option to create a new tag should be retrieved. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tagsearchAsyncWithHttpInfo($token, $query, $allowcreatingnew = null)
    {
        $returnType = '';
        $request = $this->tagsearchRequest($token, $query, $allowcreatingnew);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'tagsearch'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $query The query to search tags. Use group:&lt;group&gt; to search in a specific group (mandatory). (required)
     * @param  bool $allowcreatingnew Specifies whether an option to create a new tag should be retrieved. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function tagsearchRequest($token, $query, $allowcreatingnew = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling tagsearch'
            );
        }
        // verify the required parameter 'query' is set
        if ($query === null || (is_array($query) && count($query) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query when calling tagsearch'
            );
        }

        $resourcePath = '/tagsearch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($query !== null) {
            if('form' === 'form' && is_array($query)) {
                foreach($query as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['query'] = $query;
            }
        }
        // query params
        if ($allowcreatingnew !== null) {
            if('form' === 'form' && is_array($allowcreatingnew)) {
                foreach($allowcreatingnew as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['allowcreatingnew'] = $allowcreatingnew;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation templateaddimage
     *
     * Add an image to a template
     *
     * @param  string $token The authentication token. (required)
     * @param  string $template The id of the template where the image has to be added (required)
     * @param  string $upload Set &#39;file&#39; as value to indicate that a file is being submitted in the body (instead of a JSON object). (required)
     * @param  string $filename The local name of the uploaded file. For later reference. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function templateaddimage($token, $template, $upload, $filename = null)
    {
        $this->templateaddimageWithHttpInfo($token, $template, $upload, $filename);
    }

    /**
     * Operation templateaddimageWithHttpInfo
     *
     * Add an image to a template
     *
     * @param  string $token The authentication token. (required)
     * @param  string $template The id of the template where the image has to be added (required)
     * @param  string $upload Set &#39;file&#39; as value to indicate that a file is being submitted in the body (instead of a JSON object). (required)
     * @param  string $filename The local name of the uploaded file. For later reference. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function templateaddimageWithHttpInfo($token, $template, $upload, $filename = null)
    {
        $request = $this->templateaddimageRequest($token, $template, $upload, $filename);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation templateaddimageAsync
     *
     * Add an image to a template
     *
     * @param  string $token The authentication token. (required)
     * @param  string $template The id of the template where the image has to be added (required)
     * @param  string $upload Set &#39;file&#39; as value to indicate that a file is being submitted in the body (instead of a JSON object). (required)
     * @param  string $filename The local name of the uploaded file. For later reference. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function templateaddimageAsync($token, $template, $upload, $filename = null)
    {
        return $this->templateaddimageAsyncWithHttpInfo($token, $template, $upload, $filename)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation templateaddimageAsyncWithHttpInfo
     *
     * Add an image to a template
     *
     * @param  string $token The authentication token. (required)
     * @param  string $template The id of the template where the image has to be added (required)
     * @param  string $upload Set &#39;file&#39; as value to indicate that a file is being submitted in the body (instead of a JSON object). (required)
     * @param  string $filename The local name of the uploaded file. For later reference. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function templateaddimageAsyncWithHttpInfo($token, $template, $upload, $filename = null)
    {
        $returnType = '';
        $request = $this->templateaddimageRequest($token, $template, $upload, $filename);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'templateaddimage'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $template The id of the template where the image has to be added (required)
     * @param  string $upload Set &#39;file&#39; as value to indicate that a file is being submitted in the body (instead of a JSON object). (required)
     * @param  string $filename The local name of the uploaded file. For later reference. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function templateaddimageRequest($token, $template, $upload, $filename = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling templateaddimage'
            );
        }
        // verify the required parameter 'template' is set
        if ($template === null || (is_array($template) && count($template) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template when calling templateaddimage'
            );
        }
        // verify the required parameter 'upload' is set
        if ($upload === null || (is_array($upload) && count($upload) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $upload when calling templateaddimage'
            );
        }

        $resourcePath = '/templateaddimage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($template !== null) {
            if('form' === 'form' && is_array($template)) {
                foreach($template as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['template'] = $template;
            }
        }
        // query params
        if ($upload !== null) {
            if('form' === 'form' && is_array($upload)) {
                foreach($upload as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['upload'] = $upload;
            }
        }
        // query params
        if ($filename !== null) {
            if('form' === 'form' && is_array($filename)) {
                foreach($filename as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['filename'] = $filename;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation templatedelete
     *
     * Delete a template
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the template to delete. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function templatedelete($token, $id)
    {
        $this->templatedeleteWithHttpInfo($token, $id);
    }

    /**
     * Operation templatedeleteWithHttpInfo
     *
     * Delete a template
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the template to delete. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function templatedeleteWithHttpInfo($token, $id)
    {
        $request = $this->templatedeleteRequest($token, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation templatedeleteAsync
     *
     * Delete a template
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the template to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function templatedeleteAsync($token, $id)
    {
        return $this->templatedeleteAsyncWithHttpInfo($token, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation templatedeleteAsyncWithHttpInfo
     *
     * Delete a template
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the template to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function templatedeleteAsyncWithHttpInfo($token, $id)
    {
        $returnType = '';
        $request = $this->templatedeleteRequest($token, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'templatedelete'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the template to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function templatedeleteRequest($token, $id)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling templatedelete'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling templatedelete'
            );
        }

        $resourcePath = '/templatedelete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($id !== null) {
            if('form' === 'form' && is_array($id)) {
                foreach($id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['id'] = $id;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation templateemail
     *
     * Send generated templates by email
     *
     * @param  string $token The authentication token. (required)
     * @param  string $jobid The id of the job that is creating the templates. (required)
     * @param  string $emailsubject Args depending on the send-to flag. (required)
     * @param  string $emailbody Args depending on the send-to flag. (required)
     * @param  string $templatekind The kind of the template you&#39;re sending. It must be included in (badge, certificate). (optional)
     * @param  string $emailfrom The name of the sender to be displayed in the receipients inbox (optional)
     * @param  string $emailreplyto The reply-to field for the emails. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function templateemail($token, $jobid, $emailsubject, $emailbody, $templatekind = null, $emailfrom = null, $emailreplyto = null)
    {
        $this->templateemailWithHttpInfo($token, $jobid, $emailsubject, $emailbody, $templatekind, $emailfrom, $emailreplyto);
    }

    /**
     * Operation templateemailWithHttpInfo
     *
     * Send generated templates by email
     *
     * @param  string $token The authentication token. (required)
     * @param  string $jobid The id of the job that is creating the templates. (required)
     * @param  string $emailsubject Args depending on the send-to flag. (required)
     * @param  string $emailbody Args depending on the send-to flag. (required)
     * @param  string $templatekind The kind of the template you&#39;re sending. It must be included in (badge, certificate). (optional)
     * @param  string $emailfrom The name of the sender to be displayed in the receipients inbox (optional)
     * @param  string $emailreplyto The reply-to field for the emails. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function templateemailWithHttpInfo($token, $jobid, $emailsubject, $emailbody, $templatekind = null, $emailfrom = null, $emailreplyto = null)
    {
        $request = $this->templateemailRequest($token, $jobid, $emailsubject, $emailbody, $templatekind, $emailfrom, $emailreplyto);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation templateemailAsync
     *
     * Send generated templates by email
     *
     * @param  string $token The authentication token. (required)
     * @param  string $jobid The id of the job that is creating the templates. (required)
     * @param  string $emailsubject Args depending on the send-to flag. (required)
     * @param  string $emailbody Args depending on the send-to flag. (required)
     * @param  string $templatekind The kind of the template you&#39;re sending. It must be included in (badge, certificate). (optional)
     * @param  string $emailfrom The name of the sender to be displayed in the receipients inbox (optional)
     * @param  string $emailreplyto The reply-to field for the emails. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function templateemailAsync($token, $jobid, $emailsubject, $emailbody, $templatekind = null, $emailfrom = null, $emailreplyto = null)
    {
        return $this->templateemailAsyncWithHttpInfo($token, $jobid, $emailsubject, $emailbody, $templatekind, $emailfrom, $emailreplyto)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation templateemailAsyncWithHttpInfo
     *
     * Send generated templates by email
     *
     * @param  string $token The authentication token. (required)
     * @param  string $jobid The id of the job that is creating the templates. (required)
     * @param  string $emailsubject Args depending on the send-to flag. (required)
     * @param  string $emailbody Args depending on the send-to flag. (required)
     * @param  string $templatekind The kind of the template you&#39;re sending. It must be included in (badge, certificate). (optional)
     * @param  string $emailfrom The name of the sender to be displayed in the receipients inbox (optional)
     * @param  string $emailreplyto The reply-to field for the emails. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function templateemailAsyncWithHttpInfo($token, $jobid, $emailsubject, $emailbody, $templatekind = null, $emailfrom = null, $emailreplyto = null)
    {
        $returnType = '';
        $request = $this->templateemailRequest($token, $jobid, $emailsubject, $emailbody, $templatekind, $emailfrom, $emailreplyto);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'templateemail'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $jobid The id of the job that is creating the templates. (required)
     * @param  string $emailsubject Args depending on the send-to flag. (required)
     * @param  string $emailbody Args depending on the send-to flag. (required)
     * @param  string $templatekind The kind of the template you&#39;re sending. It must be included in (badge, certificate). (optional)
     * @param  string $emailfrom The name of the sender to be displayed in the receipients inbox (optional)
     * @param  string $emailreplyto The reply-to field for the emails. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function templateemailRequest($token, $jobid, $emailsubject, $emailbody, $templatekind = null, $emailfrom = null, $emailreplyto = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling templateemail'
            );
        }
        // verify the required parameter 'jobid' is set
        if ($jobid === null || (is_array($jobid) && count($jobid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $jobid when calling templateemail'
            );
        }
        // verify the required parameter 'emailsubject' is set
        if ($emailsubject === null || (is_array($emailsubject) && count($emailsubject) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $emailsubject when calling templateemail'
            );
        }
        // verify the required parameter 'emailbody' is set
        if ($emailbody === null || (is_array($emailbody) && count($emailbody) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $emailbody when calling templateemail'
            );
        }

        $resourcePath = '/templateemail';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($jobid !== null) {
            if('form' === 'form' && is_array($jobid)) {
                foreach($jobid as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['jobid'] = $jobid;
            }
        }
        // query params
        if ($templatekind !== null) {
            if('form' === 'form' && is_array($templatekind)) {
                foreach($templatekind as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['templatekind'] = $templatekind;
            }
        }
        // query params
        if ($emailfrom !== null) {
            if('form' === 'form' && is_array($emailfrom)) {
                foreach($emailfrom as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['emailfrom'] = $emailfrom;
            }
        }
        // query params
        if ($emailreplyto !== null) {
            if('form' === 'form' && is_array($emailreplyto)) {
                foreach($emailreplyto as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['emailreplyto'] = $emailreplyto;
            }
        }
        // query params
        if ($emailsubject !== null) {
            if('form' === 'form' && is_array($emailsubject)) {
                foreach($emailsubject as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['emailsubject'] = $emailsubject;
            }
        }
        // query params
        if ($emailbody !== null) {
            if('form' === 'form' && is_array($emailbody)) {
                foreach($emailbody as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['emailbody'] = $emailbody;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation templategenerate
     *
     * Generate specified templates
     *
     * @param  string $token The authentication token. (required)
     * @param  string $template The id of the template to generate. (required)
     * @param  string $source The source key of the selected template data source. (required)
     * @param  bool $singlefile True if all the templates should be placed in the same file, false if each one shoud be in its own file. (required)
     * @param  string $userid Only the template for these users is created (and emailed if &#39;email&#39; is true), enter multiple separated by commas. (optional)
     * @param  bool $forsending It specifies the purpose of the creation of the templates. If true then is for sending via e-mail, otherwise is just for downloading (optional)
     * @param  string $role When printing all badges, filter by person type, can be either: attendee, presenter or exhibitor (optional)
     * @param  string $filters Pipe separated filters for the generation, eg: aaa&#x3D;val|bbb&#x3D;val|... (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function templategenerate($token, $template, $source, $singlefile, $userid = null, $forsending = null, $role = null, $filters = null)
    {
        $this->templategenerateWithHttpInfo($token, $template, $source, $singlefile, $userid, $forsending, $role, $filters);
    }

    /**
     * Operation templategenerateWithHttpInfo
     *
     * Generate specified templates
     *
     * @param  string $token The authentication token. (required)
     * @param  string $template The id of the template to generate. (required)
     * @param  string $source The source key of the selected template data source. (required)
     * @param  bool $singlefile True if all the templates should be placed in the same file, false if each one shoud be in its own file. (required)
     * @param  string $userid Only the template for these users is created (and emailed if &#39;email&#39; is true), enter multiple separated by commas. (optional)
     * @param  bool $forsending It specifies the purpose of the creation of the templates. If true then is for sending via e-mail, otherwise is just for downloading (optional)
     * @param  string $role When printing all badges, filter by person type, can be either: attendee, presenter or exhibitor (optional)
     * @param  string $filters Pipe separated filters for the generation, eg: aaa&#x3D;val|bbb&#x3D;val|... (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function templategenerateWithHttpInfo($token, $template, $source, $singlefile, $userid = null, $forsending = null, $role = null, $filters = null)
    {
        $request = $this->templategenerateRequest($token, $template, $source, $singlefile, $userid, $forsending, $role, $filters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation templategenerateAsync
     *
     * Generate specified templates
     *
     * @param  string $token The authentication token. (required)
     * @param  string $template The id of the template to generate. (required)
     * @param  string $source The source key of the selected template data source. (required)
     * @param  bool $singlefile True if all the templates should be placed in the same file, false if each one shoud be in its own file. (required)
     * @param  string $userid Only the template for these users is created (and emailed if &#39;email&#39; is true), enter multiple separated by commas. (optional)
     * @param  bool $forsending It specifies the purpose of the creation of the templates. If true then is for sending via e-mail, otherwise is just for downloading (optional)
     * @param  string $role When printing all badges, filter by person type, can be either: attendee, presenter or exhibitor (optional)
     * @param  string $filters Pipe separated filters for the generation, eg: aaa&#x3D;val|bbb&#x3D;val|... (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function templategenerateAsync($token, $template, $source, $singlefile, $userid = null, $forsending = null, $role = null, $filters = null)
    {
        return $this->templategenerateAsyncWithHttpInfo($token, $template, $source, $singlefile, $userid, $forsending, $role, $filters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation templategenerateAsyncWithHttpInfo
     *
     * Generate specified templates
     *
     * @param  string $token The authentication token. (required)
     * @param  string $template The id of the template to generate. (required)
     * @param  string $source The source key of the selected template data source. (required)
     * @param  bool $singlefile True if all the templates should be placed in the same file, false if each one shoud be in its own file. (required)
     * @param  string $userid Only the template for these users is created (and emailed if &#39;email&#39; is true), enter multiple separated by commas. (optional)
     * @param  bool $forsending It specifies the purpose of the creation of the templates. If true then is for sending via e-mail, otherwise is just for downloading (optional)
     * @param  string $role When printing all badges, filter by person type, can be either: attendee, presenter or exhibitor (optional)
     * @param  string $filters Pipe separated filters for the generation, eg: aaa&#x3D;val|bbb&#x3D;val|... (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function templategenerateAsyncWithHttpInfo($token, $template, $source, $singlefile, $userid = null, $forsending = null, $role = null, $filters = null)
    {
        $returnType = '';
        $request = $this->templategenerateRequest($token, $template, $source, $singlefile, $userid, $forsending, $role, $filters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'templategenerate'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $template The id of the template to generate. (required)
     * @param  string $source The source key of the selected template data source. (required)
     * @param  bool $singlefile True if all the templates should be placed in the same file, false if each one shoud be in its own file. (required)
     * @param  string $userid Only the template for these users is created (and emailed if &#39;email&#39; is true), enter multiple separated by commas. (optional)
     * @param  bool $forsending It specifies the purpose of the creation of the templates. If true then is for sending via e-mail, otherwise is just for downloading (optional)
     * @param  string $role When printing all badges, filter by person type, can be either: attendee, presenter or exhibitor (optional)
     * @param  string $filters Pipe separated filters for the generation, eg: aaa&#x3D;val|bbb&#x3D;val|... (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function templategenerateRequest($token, $template, $source, $singlefile, $userid = null, $forsending = null, $role = null, $filters = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling templategenerate'
            );
        }
        // verify the required parameter 'template' is set
        if ($template === null || (is_array($template) && count($template) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template when calling templategenerate'
            );
        }
        // verify the required parameter 'source' is set
        if ($source === null || (is_array($source) && count($source) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $source when calling templategenerate'
            );
        }
        // verify the required parameter 'singlefile' is set
        if ($singlefile === null || (is_array($singlefile) && count($singlefile) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $singlefile when calling templategenerate'
            );
        }

        $resourcePath = '/templategenerate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($template !== null) {
            if('form' === 'form' && is_array($template)) {
                foreach($template as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['template'] = $template;
            }
        }
        // query params
        if ($source !== null) {
            if('form' === 'form' && is_array($source)) {
                foreach($source as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['source'] = $source;
            }
        }
        // query params
        if ($singlefile !== null) {
            if('form' === 'form' && is_array($singlefile)) {
                foreach($singlefile as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['singlefile'] = $singlefile;
            }
        }
        // query params
        if ($userid !== null) {
            if('form' === 'form' && is_array($userid)) {
                foreach($userid as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['userid'] = $userid;
            }
        }
        // query params
        if ($forsending !== null) {
            if('form' === 'form' && is_array($forsending)) {
                foreach($forsending as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['forsending'] = $forsending;
            }
        }
        // query params
        if ($role !== null) {
            if('form' === 'form' && is_array($role)) {
                foreach($role as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['role'] = $role;
            }
        }
        // query params
        if ($filters !== null) {
            if('form' === 'form' && is_array($filters)) {
                foreach($filters as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['filters'] = $filters;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation templateget
     *
     * View details of a template
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the template to get. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function templateget($token, $id)
    {
        $this->templategetWithHttpInfo($token, $id);
    }

    /**
     * Operation templategetWithHttpInfo
     *
     * View details of a template
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the template to get. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function templategetWithHttpInfo($token, $id)
    {
        $request = $this->templategetRequest($token, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation templategetAsync
     *
     * View details of a template
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the template to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function templategetAsync($token, $id)
    {
        return $this->templategetAsyncWithHttpInfo($token, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation templategetAsyncWithHttpInfo
     *
     * View details of a template
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the template to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function templategetAsyncWithHttpInfo($token, $id)
    {
        $returnType = '';
        $request = $this->templategetRequest($token, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'templateget'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the template to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function templategetRequest($token, $id)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling templateget'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling templateget'
            );
        }

        $resourcePath = '/templateget';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($id !== null) {
            if('form' === 'form' && is_array($id)) {
                foreach($id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['id'] = $id;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation templategetgenerated
     *
     * View generated templates
     *
     * @param  string $token The authentication token. (required)
     * @param  string $jobid The id of the job that is creating the templates. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function templategetgenerated($token, $jobid)
    {
        $this->templategetgeneratedWithHttpInfo($token, $jobid);
    }

    /**
     * Operation templategetgeneratedWithHttpInfo
     *
     * View generated templates
     *
     * @param  string $token The authentication token. (required)
     * @param  string $jobid The id of the job that is creating the templates. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function templategetgeneratedWithHttpInfo($token, $jobid)
    {
        $request = $this->templategetgeneratedRequest($token, $jobid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation templategetgeneratedAsync
     *
     * View generated templates
     *
     * @param  string $token The authentication token. (required)
     * @param  string $jobid The id of the job that is creating the templates. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function templategetgeneratedAsync($token, $jobid)
    {
        return $this->templategetgeneratedAsyncWithHttpInfo($token, $jobid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation templategetgeneratedAsyncWithHttpInfo
     *
     * View generated templates
     *
     * @param  string $token The authentication token. (required)
     * @param  string $jobid The id of the job that is creating the templates. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function templategetgeneratedAsyncWithHttpInfo($token, $jobid)
    {
        $returnType = '';
        $request = $this->templategetgeneratedRequest($token, $jobid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'templategetgenerated'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $jobid The id of the job that is creating the templates. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function templategetgeneratedRequest($token, $jobid)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling templategetgenerated'
            );
        }
        // verify the required parameter 'jobid' is set
        if ($jobid === null || (is_array($jobid) && count($jobid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $jobid when calling templategetgenerated'
            );
        }

        $resourcePath = '/templategetgenerated';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($jobid !== null) {
            if('form' === 'form' && is_array($jobid)) {
                foreach($jobid as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['jobid'] = $jobid;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation templatelist
     *
     * View a list of defined templates
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $kind The kind of the templates to return. It must be included in (badge, certificate). (required)
     * @param  bool $designedonly If true then it only returns the templates that were designed. Otherwise, it returns all. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function templatelist($token, $from, $count, $kind, $designedonly = null)
    {
        $this->templatelistWithHttpInfo($token, $from, $count, $kind, $designedonly);
    }

    /**
     * Operation templatelistWithHttpInfo
     *
     * View a list of defined templates
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $kind The kind of the templates to return. It must be included in (badge, certificate). (required)
     * @param  bool $designedonly If true then it only returns the templates that were designed. Otherwise, it returns all. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function templatelistWithHttpInfo($token, $from, $count, $kind, $designedonly = null)
    {
        $request = $this->templatelistRequest($token, $from, $count, $kind, $designedonly);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation templatelistAsync
     *
     * View a list of defined templates
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $kind The kind of the templates to return. It must be included in (badge, certificate). (required)
     * @param  bool $designedonly If true then it only returns the templates that were designed. Otherwise, it returns all. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function templatelistAsync($token, $from, $count, $kind, $designedonly = null)
    {
        return $this->templatelistAsyncWithHttpInfo($token, $from, $count, $kind, $designedonly)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation templatelistAsyncWithHttpInfo
     *
     * View a list of defined templates
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $kind The kind of the templates to return. It must be included in (badge, certificate). (required)
     * @param  bool $designedonly If true then it only returns the templates that were designed. Otherwise, it returns all. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function templatelistAsyncWithHttpInfo($token, $from, $count, $kind, $designedonly = null)
    {
        $returnType = '';
        $request = $this->templatelistRequest($token, $from, $count, $kind, $designedonly);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'templatelist'
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $kind The kind of the templates to return. It must be included in (badge, certificate). (required)
     * @param  bool $designedonly If true then it only returns the templates that were designed. Otherwise, it returns all. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function templatelistRequest($token, $from, $count, $kind, $designedonly = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling templatelist'
            );
        }
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling templatelist'
            );
        }
        // verify the required parameter 'count' is set
        if ($count === null || (is_array($count) && count($count) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $count when calling templatelist'
            );
        }
        // verify the required parameter 'kind' is set
        if ($kind === null || (is_array($kind) && count($kind) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $kind when calling templatelist'
            );
        }

        $resourcePath = '/templatelist';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }
        // query params
        if ($count !== null) {
            if('form' === 'form' && is_array($count)) {
                foreach($count as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['count'] = $count;
            }
        }
        // query params
        if ($kind !== null) {
            if('form' === 'form' && is_array($kind)) {
                foreach($kind as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['kind'] = $kind;
            }
        }
        // query params
        if ($designedonly !== null) {
            if('form' === 'form' && is_array($designedonly)) {
                foreach($designedonly as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['designedonly'] = $designedonly;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation templatelistsources
     *
     * View a list of templates' data sources
     *
     * @param  string $token The authentication token. (required)
     * @param  string $kind The kind of the templates to return. It must be included in (badge, certificate). (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function templatelistsources($token, $kind)
    {
        $this->templatelistsourcesWithHttpInfo($token, $kind);
    }

    /**
     * Operation templatelistsourcesWithHttpInfo
     *
     * View a list of templates' data sources
     *
     * @param  string $token The authentication token. (required)
     * @param  string $kind The kind of the templates to return. It must be included in (badge, certificate). (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function templatelistsourcesWithHttpInfo($token, $kind)
    {
        $request = $this->templatelistsourcesRequest($token, $kind);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation templatelistsourcesAsync
     *
     * View a list of templates' data sources
     *
     * @param  string $token The authentication token. (required)
     * @param  string $kind The kind of the templates to return. It must be included in (badge, certificate). (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function templatelistsourcesAsync($token, $kind)
    {
        return $this->templatelistsourcesAsyncWithHttpInfo($token, $kind)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation templatelistsourcesAsyncWithHttpInfo
     *
     * View a list of templates' data sources
     *
     * @param  string $token The authentication token. (required)
     * @param  string $kind The kind of the templates to return. It must be included in (badge, certificate). (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function templatelistsourcesAsyncWithHttpInfo($token, $kind)
    {
        $returnType = '';
        $request = $this->templatelistsourcesRequest($token, $kind);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'templatelistsources'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $kind The kind of the templates to return. It must be included in (badge, certificate). (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function templatelistsourcesRequest($token, $kind)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling templatelistsources'
            );
        }
        // verify the required parameter 'kind' is set
        if ($kind === null || (is_array($kind) && count($kind) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $kind when calling templatelistsources'
            );
        }

        $resourcePath = '/templatelistsources';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($kind !== null) {
            if('form' === 'form' && is_array($kind)) {
                foreach($kind as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['kind'] = $kind;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation templatesave
     *
     * Create or edit a template
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function templatesave($unknown_base_type = null)
    {
        $this->templatesaveWithHttpInfo($unknown_base_type);
    }

    /**
     * Operation templatesaveWithHttpInfo
     *
     * Create or edit a template
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function templatesaveWithHttpInfo($unknown_base_type = null)
    {
        $request = $this->templatesaveRequest($unknown_base_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation templatesaveAsync
     *
     * Create or edit a template
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function templatesaveAsync($unknown_base_type = null)
    {
        return $this->templatesaveAsyncWithHttpInfo($unknown_base_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation templatesaveAsyncWithHttpInfo
     *
     * Create or edit a template
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function templatesaveAsyncWithHttpInfo($unknown_base_type = null)
    {
        $returnType = '';
        $request = $this->templatesaveRequest($unknown_base_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'templatesave'
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function templatesaveRequest($unknown_base_type = null)
    {

        $resourcePath = '/templatesave';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($unknown_base_type)) {
            $_tempBody = $unknown_base_type;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation templatesavelayout
     *
     * Save the layout of a template
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function templatesavelayout($unknown_base_type = null)
    {
        $this->templatesavelayoutWithHttpInfo($unknown_base_type);
    }

    /**
     * Operation templatesavelayoutWithHttpInfo
     *
     * Save the layout of a template
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function templatesavelayoutWithHttpInfo($unknown_base_type = null)
    {
        $request = $this->templatesavelayoutRequest($unknown_base_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation templatesavelayoutAsync
     *
     * Save the layout of a template
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function templatesavelayoutAsync($unknown_base_type = null)
    {
        return $this->templatesavelayoutAsyncWithHttpInfo($unknown_base_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation templatesavelayoutAsyncWithHttpInfo
     *
     * Save the layout of a template
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function templatesavelayoutAsyncWithHttpInfo($unknown_base_type = null)
    {
        $returnType = '';
        $request = $this->templatesavelayoutRequest($unknown_base_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'templatesavelayout'
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function templatesavelayoutRequest($unknown_base_type = null)
    {

        $resourcePath = '/templatesavelayout';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($unknown_base_type)) {
            $_tempBody = $unknown_base_type;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation termdelete
     *
     * Delete a term
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the term to delete. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function termdelete($token, $id)
    {
        $this->termdeleteWithHttpInfo($token, $id);
    }

    /**
     * Operation termdeleteWithHttpInfo
     *
     * Delete a term
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the term to delete. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function termdeleteWithHttpInfo($token, $id)
    {
        $request = $this->termdeleteRequest($token, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation termdeleteAsync
     *
     * Delete a term
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the term to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function termdeleteAsync($token, $id)
    {
        return $this->termdeleteAsyncWithHttpInfo($token, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation termdeleteAsyncWithHttpInfo
     *
     * Delete a term
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the term to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function termdeleteAsyncWithHttpInfo($token, $id)
    {
        $returnType = '';
        $request = $this->termdeleteRequest($token, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'termdelete'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the term to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function termdeleteRequest($token, $id)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling termdelete'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling termdelete'
            );
        }

        $resourcePath = '/termdelete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($id !== null) {
            if('form' === 'form' && is_array($id)) {
                foreach($id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['id'] = $id;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation termget
     *
     * Search and view details of a term
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the term to get. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function termget($token, $id)
    {
        $this->termgetWithHttpInfo($token, $id);
    }

    /**
     * Operation termgetWithHttpInfo
     *
     * Search and view details of a term
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the term to get. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function termgetWithHttpInfo($token, $id)
    {
        $request = $this->termgetRequest($token, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation termgetAsync
     *
     * Search and view details of a term
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the term to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function termgetAsync($token, $id)
    {
        return $this->termgetAsyncWithHttpInfo($token, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation termgetAsyncWithHttpInfo
     *
     * Search and view details of a term
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the term to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function termgetAsyncWithHttpInfo($token, $id)
    {
        $returnType = '';
        $request = $this->termgetRequest($token, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'termget'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the term to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function termgetRequest($token, $id)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling termget'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling termget'
            );
        }

        $resourcePath = '/termget';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($id !== null) {
            if('form' === 'form' && is_array($id)) {
                foreach($id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['id'] = $id;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation termlist
     *
     * Search and view details of all terms
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (optional)
     * @param  int $count The max number of records to return. (optional)
     * @param  bool $notpast Specifies whether the terms in the past should be returned or not. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function termlist($token, $from = null, $count = null, $notpast = null)
    {
        $this->termlistWithHttpInfo($token, $from, $count, $notpast);
    }

    /**
     * Operation termlistWithHttpInfo
     *
     * Search and view details of all terms
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (optional)
     * @param  int $count The max number of records to return. (optional)
     * @param  bool $notpast Specifies whether the terms in the past should be returned or not. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function termlistWithHttpInfo($token, $from = null, $count = null, $notpast = null)
    {
        $request = $this->termlistRequest($token, $from, $count, $notpast);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation termlistAsync
     *
     * Search and view details of all terms
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (optional)
     * @param  int $count The max number of records to return. (optional)
     * @param  bool $notpast Specifies whether the terms in the past should be returned or not. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function termlistAsync($token, $from = null, $count = null, $notpast = null)
    {
        return $this->termlistAsyncWithHttpInfo($token, $from, $count, $notpast)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation termlistAsyncWithHttpInfo
     *
     * Search and view details of all terms
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (optional)
     * @param  int $count The max number of records to return. (optional)
     * @param  bool $notpast Specifies whether the terms in the past should be returned or not. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function termlistAsyncWithHttpInfo($token, $from = null, $count = null, $notpast = null)
    {
        $returnType = '';
        $request = $this->termlistRequest($token, $from, $count, $notpast);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'termlist'
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (optional)
     * @param  int $count The max number of records to return. (optional)
     * @param  bool $notpast Specifies whether the terms in the past should be returned or not. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function termlistRequest($token, $from = null, $count = null, $notpast = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling termlist'
            );
        }

        $resourcePath = '/termlist';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }
        // query params
        if ($count !== null) {
            if('form' === 'form' && is_array($count)) {
                foreach($count as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['count'] = $count;
            }
        }
        // query params
        if ($notpast !== null) {
            if('form' === 'form' && is_array($notpast)) {
                foreach($notpast as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['notpast'] = $notpast;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation termsave
     *
     * Create and edit terms
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function termsave($unknown_base_type = null)
    {
        $this->termsaveWithHttpInfo($unknown_base_type);
    }

    /**
     * Operation termsaveWithHttpInfo
     *
     * Create and edit terms
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function termsaveWithHttpInfo($unknown_base_type = null)
    {
        $request = $this->termsaveRequest($unknown_base_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation termsaveAsync
     *
     * Create and edit terms
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function termsaveAsync($unknown_base_type = null)
    {
        return $this->termsaveAsyncWithHttpInfo($unknown_base_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation termsaveAsyncWithHttpInfo
     *
     * Create and edit terms
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function termsaveAsyncWithHttpInfo($unknown_base_type = null)
    {
        $returnType = '';
        $request = $this->termsaveRequest($unknown_base_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'termsave'
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function termsaveRequest($unknown_base_type = null)
    {

        $resourcePath = '/termsave';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($unknown_base_type)) {
            $_tempBody = $unknown_base_type;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation textcreditremaining
     *
     * Gets the remaining text credits for the account
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function textcreditremaining($token)
    {
        $this->textcreditremainingWithHttpInfo($token);
    }

    /**
     * Operation textcreditremainingWithHttpInfo
     *
     * Gets the remaining text credits for the account
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function textcreditremainingWithHttpInfo($token)
    {
        $request = $this->textcreditremainingRequest($token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation textcreditremainingAsync
     *
     * Gets the remaining text credits for the account
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function textcreditremainingAsync($token)
    {
        return $this->textcreditremainingAsyncWithHttpInfo($token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation textcreditremainingAsyncWithHttpInfo
     *
     * Gets the remaining text credits for the account
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function textcreditremainingAsyncWithHttpInfo($token)
    {
        $returnType = '';
        $request = $this->textcreditremainingRequest($token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'textcreditremaining'
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function textcreditremainingRequest($token)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling textcreditremaining'
            );
        }

        $resourcePath = '/textcreditremaining';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation texttoimage
     *
     * Generates a dynamic image from text
     *
     * @param  string $token The authentication token. (required)
     * @param  string $text The text to convert to an image, use double pipes (||) as a new line. (required)
     * @param  string $fontcolor The color of the text, in hex format, without the #. (optional)
     * @param  int $fontsize The size of the text, in points. (optional)
     * @param  string $direction Either vertical or horizontal, default horizontal. (optional)
     * @param  int $width The image width in pixels (or height if the direction is vertical). (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function texttoimage($token, $text, $fontcolor = null, $fontsize = null, $direction = null, $width = null)
    {
        $this->texttoimageWithHttpInfo($token, $text, $fontcolor, $fontsize, $direction, $width);
    }

    /**
     * Operation texttoimageWithHttpInfo
     *
     * Generates a dynamic image from text
     *
     * @param  string $token The authentication token. (required)
     * @param  string $text The text to convert to an image, use double pipes (||) as a new line. (required)
     * @param  string $fontcolor The color of the text, in hex format, without the #. (optional)
     * @param  int $fontsize The size of the text, in points. (optional)
     * @param  string $direction Either vertical or horizontal, default horizontal. (optional)
     * @param  int $width The image width in pixels (or height if the direction is vertical). (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function texttoimageWithHttpInfo($token, $text, $fontcolor = null, $fontsize = null, $direction = null, $width = null)
    {
        $request = $this->texttoimageRequest($token, $text, $fontcolor, $fontsize, $direction, $width);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation texttoimageAsync
     *
     * Generates a dynamic image from text
     *
     * @param  string $token The authentication token. (required)
     * @param  string $text The text to convert to an image, use double pipes (||) as a new line. (required)
     * @param  string $fontcolor The color of the text, in hex format, without the #. (optional)
     * @param  int $fontsize The size of the text, in points. (optional)
     * @param  string $direction Either vertical or horizontal, default horizontal. (optional)
     * @param  int $width The image width in pixels (or height if the direction is vertical). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function texttoimageAsync($token, $text, $fontcolor = null, $fontsize = null, $direction = null, $width = null)
    {
        return $this->texttoimageAsyncWithHttpInfo($token, $text, $fontcolor, $fontsize, $direction, $width)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation texttoimageAsyncWithHttpInfo
     *
     * Generates a dynamic image from text
     *
     * @param  string $token The authentication token. (required)
     * @param  string $text The text to convert to an image, use double pipes (||) as a new line. (required)
     * @param  string $fontcolor The color of the text, in hex format, without the #. (optional)
     * @param  int $fontsize The size of the text, in points. (optional)
     * @param  string $direction Either vertical or horizontal, default horizontal. (optional)
     * @param  int $width The image width in pixels (or height if the direction is vertical). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function texttoimageAsyncWithHttpInfo($token, $text, $fontcolor = null, $fontsize = null, $direction = null, $width = null)
    {
        $returnType = '';
        $request = $this->texttoimageRequest($token, $text, $fontcolor, $fontsize, $direction, $width);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'texttoimage'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $text The text to convert to an image, use double pipes (||) as a new line. (required)
     * @param  string $fontcolor The color of the text, in hex format, without the #. (optional)
     * @param  int $fontsize The size of the text, in points. (optional)
     * @param  string $direction Either vertical or horizontal, default horizontal. (optional)
     * @param  int $width The image width in pixels (or height if the direction is vertical). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function texttoimageRequest($token, $text, $fontcolor = null, $fontsize = null, $direction = null, $width = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling texttoimage'
            );
        }
        // verify the required parameter 'text' is set
        if ($text === null || (is_array($text) && count($text) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $text when calling texttoimage'
            );
        }

        $resourcePath = '/texttoimage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($text !== null) {
            if('form' === 'form' && is_array($text)) {
                foreach($text as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['text'] = $text;
            }
        }
        // query params
        if ($fontcolor !== null) {
            if('form' === 'form' && is_array($fontcolor)) {
                foreach($fontcolor as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['fontcolor'] = $fontcolor;
            }
        }
        // query params
        if ($fontsize !== null) {
            if('form' === 'form' && is_array($fontsize)) {
                foreach($fontsize as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['fontsize'] = $fontsize;
            }
        }
        // query params
        if ($direction !== null) {
            if('form' === 'form' && is_array($direction)) {
                foreach($direction as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['direction'] = $direction;
            }
        }
        // query params
        if ($width !== null) {
            if('form' === 'form' && is_array($width)) {
                foreach($width as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['width'] = $width;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation translationget
     *
     * Gets the translations of the specified values
     *
     * @param  string $token The authentication token. (required)
     * @param  string $universal Pipe separated list of universal text to be translated. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function translationget($token, $universal)
    {
        $this->translationgetWithHttpInfo($token, $universal);
    }

    /**
     * Operation translationgetWithHttpInfo
     *
     * Gets the translations of the specified values
     *
     * @param  string $token The authentication token. (required)
     * @param  string $universal Pipe separated list of universal text to be translated. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function translationgetWithHttpInfo($token, $universal)
    {
        $request = $this->translationgetRequest($token, $universal);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation translationgetAsync
     *
     * Gets the translations of the specified values
     *
     * @param  string $token The authentication token. (required)
     * @param  string $universal Pipe separated list of universal text to be translated. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function translationgetAsync($token, $universal)
    {
        return $this->translationgetAsyncWithHttpInfo($token, $universal)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation translationgetAsyncWithHttpInfo
     *
     * Gets the translations of the specified values
     *
     * @param  string $token The authentication token. (required)
     * @param  string $universal Pipe separated list of universal text to be translated. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function translationgetAsyncWithHttpInfo($token, $universal)
    {
        $returnType = '';
        $request = $this->translationgetRequest($token, $universal);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'translationget'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $universal Pipe separated list of universal text to be translated. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function translationgetRequest($token, $universal)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling translationget'
            );
        }
        // verify the required parameter 'universal' is set
        if ($universal === null || (is_array($universal) && count($universal) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $universal when calling translationget'
            );
        }

        $resourcePath = '/translationget';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($universal !== null) {
            if('form' === 'form' && is_array($universal)) {
                foreach($universal as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['universal'] = $universal;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation translationgetcachefile
     *
     * Get the file containing the translations
     *
     * @param  string $token The authentication token. (optional)
     * @param  string $account The id of the account whose translations file has to be retrieved. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function translationgetcachefile($token = null, $account = null)
    {
        $this->translationgetcachefileWithHttpInfo($token, $account);
    }

    /**
     * Operation translationgetcachefileWithHttpInfo
     *
     * Get the file containing the translations
     *
     * @param  string $token The authentication token. (optional)
     * @param  string $account The id of the account whose translations file has to be retrieved. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function translationgetcachefileWithHttpInfo($token = null, $account = null)
    {
        $request = $this->translationgetcachefileRequest($token, $account);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation translationgetcachefileAsync
     *
     * Get the file containing the translations
     *
     * @param  string $token The authentication token. (optional)
     * @param  string $account The id of the account whose translations file has to be retrieved. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function translationgetcachefileAsync($token = null, $account = null)
    {
        return $this->translationgetcachefileAsyncWithHttpInfo($token, $account)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation translationgetcachefileAsyncWithHttpInfo
     *
     * Get the file containing the translations
     *
     * @param  string $token The authentication token. (optional)
     * @param  string $account The id of the account whose translations file has to be retrieved. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function translationgetcachefileAsyncWithHttpInfo($token = null, $account = null)
    {
        $returnType = '';
        $request = $this->translationgetcachefileRequest($token, $account);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'translationgetcachefile'
     *
     * @param  string $token The authentication token. (optional)
     * @param  string $account The id of the account whose translations file has to be retrieved. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function translationgetcachefileRequest($token = null, $account = null)
    {

        $resourcePath = '/translationgetcachefile';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($account !== null) {
            if('form' === 'form' && is_array($account)) {
                foreach($account as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['account'] = $account;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation translationlist
     *
     * Lists all the available translations in the system
     *
     * @param  string $token The authentication token. (required)
     * @param  string $filter Text to search/filter translations. (optional)
     * @param  bool $nondefaultonly If true then it returns only the terms translated. Otherwise, it returns all. (optional)
     * @param  bool $appdefaultasuniversal If true then it uses the app default translation as the universal term. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function translationlist($token, $filter = null, $nondefaultonly = null, $appdefaultasuniversal = null)
    {
        $this->translationlistWithHttpInfo($token, $filter, $nondefaultonly, $appdefaultasuniversal);
    }

    /**
     * Operation translationlistWithHttpInfo
     *
     * Lists all the available translations in the system
     *
     * @param  string $token The authentication token. (required)
     * @param  string $filter Text to search/filter translations. (optional)
     * @param  bool $nondefaultonly If true then it returns only the terms translated. Otherwise, it returns all. (optional)
     * @param  bool $appdefaultasuniversal If true then it uses the app default translation as the universal term. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function translationlistWithHttpInfo($token, $filter = null, $nondefaultonly = null, $appdefaultasuniversal = null)
    {
        $request = $this->translationlistRequest($token, $filter, $nondefaultonly, $appdefaultasuniversal);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation translationlistAsync
     *
     * Lists all the available translations in the system
     *
     * @param  string $token The authentication token. (required)
     * @param  string $filter Text to search/filter translations. (optional)
     * @param  bool $nondefaultonly If true then it returns only the terms translated. Otherwise, it returns all. (optional)
     * @param  bool $appdefaultasuniversal If true then it uses the app default translation as the universal term. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function translationlistAsync($token, $filter = null, $nondefaultonly = null, $appdefaultasuniversal = null)
    {
        return $this->translationlistAsyncWithHttpInfo($token, $filter, $nondefaultonly, $appdefaultasuniversal)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation translationlistAsyncWithHttpInfo
     *
     * Lists all the available translations in the system
     *
     * @param  string $token The authentication token. (required)
     * @param  string $filter Text to search/filter translations. (optional)
     * @param  bool $nondefaultonly If true then it returns only the terms translated. Otherwise, it returns all. (optional)
     * @param  bool $appdefaultasuniversal If true then it uses the app default translation as the universal term. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function translationlistAsyncWithHttpInfo($token, $filter = null, $nondefaultonly = null, $appdefaultasuniversal = null)
    {
        $returnType = '';
        $request = $this->translationlistRequest($token, $filter, $nondefaultonly, $appdefaultasuniversal);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'translationlist'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $filter Text to search/filter translations. (optional)
     * @param  bool $nondefaultonly If true then it returns only the terms translated. Otherwise, it returns all. (optional)
     * @param  bool $appdefaultasuniversal If true then it uses the app default translation as the universal term. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function translationlistRequest($token, $filter = null, $nondefaultonly = null, $appdefaultasuniversal = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling translationlist'
            );
        }

        $resourcePath = '/translationlist';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($filter !== null) {
            if('form' === 'form' && is_array($filter)) {
                foreach($filter as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['filter'] = $filter;
            }
        }
        // query params
        if ($nondefaultonly !== null) {
            if('form' === 'form' && is_array($nondefaultonly)) {
                foreach($nondefaultonly as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['nondefaultonly'] = $nondefaultonly;
            }
        }
        // query params
        if ($appdefaultasuniversal !== null) {
            if('form' === 'form' && is_array($appdefaultasuniversal)) {
                foreach($appdefaultasuniversal as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['appdefaultasuniversal'] = $appdefaultasuniversal;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation translationsave
     *
     * Edit a translation
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function translationsave($unknown_base_type = null)
    {
        $this->translationsaveWithHttpInfo($unknown_base_type);
    }

    /**
     * Operation translationsaveWithHttpInfo
     *
     * Edit a translation
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function translationsaveWithHttpInfo($unknown_base_type = null)
    {
        $request = $this->translationsaveRequest($unknown_base_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation translationsaveAsync
     *
     * Edit a translation
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function translationsaveAsync($unknown_base_type = null)
    {
        return $this->translationsaveAsyncWithHttpInfo($unknown_base_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation translationsaveAsyncWithHttpInfo
     *
     * Edit a translation
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function translationsaveAsyncWithHttpInfo($unknown_base_type = null)
    {
        $returnType = '';
        $request = $this->translationsaveRequest($unknown_base_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'translationsave'
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function translationsaveRequest($unknown_base_type = null)
    {

        $resourcePath = '/translationsave';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($unknown_base_type)) {
            $_tempBody = $unknown_base_type;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation userchangepwd
     *
     * Change user's own password
     *
     * @param  string $token The authentication token. (required)
     * @param  string $oldpass The old password of the authenticated user. (required)
     * @param  string $newpass The new password of the authenticated user. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function userchangepwd($token, $oldpass, $newpass)
    {
        $this->userchangepwdWithHttpInfo($token, $oldpass, $newpass);
    }

    /**
     * Operation userchangepwdWithHttpInfo
     *
     * Change user's own password
     *
     * @param  string $token The authentication token. (required)
     * @param  string $oldpass The old password of the authenticated user. (required)
     * @param  string $newpass The new password of the authenticated user. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function userchangepwdWithHttpInfo($token, $oldpass, $newpass)
    {
        $request = $this->userchangepwdRequest($token, $oldpass, $newpass);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation userchangepwdAsync
     *
     * Change user's own password
     *
     * @param  string $token The authentication token. (required)
     * @param  string $oldpass The old password of the authenticated user. (required)
     * @param  string $newpass The new password of the authenticated user. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function userchangepwdAsync($token, $oldpass, $newpass)
    {
        return $this->userchangepwdAsyncWithHttpInfo($token, $oldpass, $newpass)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation userchangepwdAsyncWithHttpInfo
     *
     * Change user's own password
     *
     * @param  string $token The authentication token. (required)
     * @param  string $oldpass The old password of the authenticated user. (required)
     * @param  string $newpass The new password of the authenticated user. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function userchangepwdAsyncWithHttpInfo($token, $oldpass, $newpass)
    {
        $returnType = '';
        $request = $this->userchangepwdRequest($token, $oldpass, $newpass);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'userchangepwd'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $oldpass The old password of the authenticated user. (required)
     * @param  string $newpass The new password of the authenticated user. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function userchangepwdRequest($token, $oldpass, $newpass)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling userchangepwd'
            );
        }
        // verify the required parameter 'oldpass' is set
        if ($oldpass === null || (is_array($oldpass) && count($oldpass) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $oldpass when calling userchangepwd'
            );
        }
        // verify the required parameter 'newpass' is set
        if ($newpass === null || (is_array($newpass) && count($newpass) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $newpass when calling userchangepwd'
            );
        }

        $resourcePath = '/userchangepwd';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($oldpass !== null) {
            if('form' === 'form' && is_array($oldpass)) {
                foreach($oldpass as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['oldpass'] = $oldpass;
            }
        }
        // query params
        if ($newpass !== null) {
            if('form' === 'form' && is_array($newpass)) {
                foreach($newpass as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['newpass'] = $newpass;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation userchangepwdbyreq
     *
     * Changes the user password using a change password request id
     *
     * @param  string $changereq The change password request ID sent by email to the user. (required)
     * @param  string $newpass The new password of the user. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function userchangepwdbyreq($changereq, $newpass)
    {
        $this->userchangepwdbyreqWithHttpInfo($changereq, $newpass);
    }

    /**
     * Operation userchangepwdbyreqWithHttpInfo
     *
     * Changes the user password using a change password request id
     *
     * @param  string $changereq The change password request ID sent by email to the user. (required)
     * @param  string $newpass The new password of the user. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function userchangepwdbyreqWithHttpInfo($changereq, $newpass)
    {
        $request = $this->userchangepwdbyreqRequest($changereq, $newpass);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation userchangepwdbyreqAsync
     *
     * Changes the user password using a change password request id
     *
     * @param  string $changereq The change password request ID sent by email to the user. (required)
     * @param  string $newpass The new password of the user. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function userchangepwdbyreqAsync($changereq, $newpass)
    {
        return $this->userchangepwdbyreqAsyncWithHttpInfo($changereq, $newpass)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation userchangepwdbyreqAsyncWithHttpInfo
     *
     * Changes the user password using a change password request id
     *
     * @param  string $changereq The change password request ID sent by email to the user. (required)
     * @param  string $newpass The new password of the user. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function userchangepwdbyreqAsyncWithHttpInfo($changereq, $newpass)
    {
        $returnType = '';
        $request = $this->userchangepwdbyreqRequest($changereq, $newpass);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'userchangepwdbyreq'
     *
     * @param  string $changereq The change password request ID sent by email to the user. (required)
     * @param  string $newpass The new password of the user. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function userchangepwdbyreqRequest($changereq, $newpass)
    {
        // verify the required parameter 'changereq' is set
        if ($changereq === null || (is_array($changereq) && count($changereq) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $changereq when calling userchangepwdbyreq'
            );
        }
        // verify the required parameter 'newpass' is set
        if ($newpass === null || (is_array($newpass) && count($newpass) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $newpass when calling userchangepwdbyreq'
            );
        }

        $resourcePath = '/userchangepwdbyreq';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($changereq !== null) {
            if('form' === 'form' && is_array($changereq)) {
                foreach($changereq as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['changereq'] = $changereq;
            }
        }
        // query params
        if ($newpass !== null) {
            if('form' === 'form' && is_array($newpass)) {
                foreach($newpass as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['newpass'] = $newpass;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation userdelete
     *
     * Delete a user
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the user to delete. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function userdelete($token, $id)
    {
        $this->userdeleteWithHttpInfo($token, $id);
    }

    /**
     * Operation userdeleteWithHttpInfo
     *
     * Delete a user
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the user to delete. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function userdeleteWithHttpInfo($token, $id)
    {
        $request = $this->userdeleteRequest($token, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation userdeleteAsync
     *
     * Delete a user
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the user to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function userdeleteAsync($token, $id)
    {
        return $this->userdeleteAsyncWithHttpInfo($token, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation userdeleteAsyncWithHttpInfo
     *
     * Delete a user
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the user to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function userdeleteAsyncWithHttpInfo($token, $id)
    {
        $returnType = '';
        $request = $this->userdeleteRequest($token, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'userdelete'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the user to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function userdeleteRequest($token, $id)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling userdelete'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling userdelete'
            );
        }

        $resourcePath = '/userdelete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($id !== null) {
            if('form' === 'form' && is_array($id)) {
                foreach($id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['id'] = $id;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation userfindsimilar
     *
     * Finds similar users to prevent duplicates
     *
     * @param  string $token The authentication token. (required)
     * @param  string $currentid The id of the current user. (optional)
     * @param  string $phonenumber A phone number to search for similar users. (optional)
     * @param  string $cardnumber A card number to search for similar users. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function userfindsimilar($token, $currentid = null, $phonenumber = null, $cardnumber = null)
    {
        $this->userfindsimilarWithHttpInfo($token, $currentid, $phonenumber, $cardnumber);
    }

    /**
     * Operation userfindsimilarWithHttpInfo
     *
     * Finds similar users to prevent duplicates
     *
     * @param  string $token The authentication token. (required)
     * @param  string $currentid The id of the current user. (optional)
     * @param  string $phonenumber A phone number to search for similar users. (optional)
     * @param  string $cardnumber A card number to search for similar users. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function userfindsimilarWithHttpInfo($token, $currentid = null, $phonenumber = null, $cardnumber = null)
    {
        $request = $this->userfindsimilarRequest($token, $currentid, $phonenumber, $cardnumber);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation userfindsimilarAsync
     *
     * Finds similar users to prevent duplicates
     *
     * @param  string $token The authentication token. (required)
     * @param  string $currentid The id of the current user. (optional)
     * @param  string $phonenumber A phone number to search for similar users. (optional)
     * @param  string $cardnumber A card number to search for similar users. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function userfindsimilarAsync($token, $currentid = null, $phonenumber = null, $cardnumber = null)
    {
        return $this->userfindsimilarAsyncWithHttpInfo($token, $currentid, $phonenumber, $cardnumber)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation userfindsimilarAsyncWithHttpInfo
     *
     * Finds similar users to prevent duplicates
     *
     * @param  string $token The authentication token. (required)
     * @param  string $currentid The id of the current user. (optional)
     * @param  string $phonenumber A phone number to search for similar users. (optional)
     * @param  string $cardnumber A card number to search for similar users. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function userfindsimilarAsyncWithHttpInfo($token, $currentid = null, $phonenumber = null, $cardnumber = null)
    {
        $returnType = '';
        $request = $this->userfindsimilarRequest($token, $currentid, $phonenumber, $cardnumber);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'userfindsimilar'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $currentid The id of the current user. (optional)
     * @param  string $phonenumber A phone number to search for similar users. (optional)
     * @param  string $cardnumber A card number to search for similar users. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function userfindsimilarRequest($token, $currentid = null, $phonenumber = null, $cardnumber = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling userfindsimilar'
            );
        }

        $resourcePath = '/userfindsimilar';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($currentid !== null) {
            if('form' === 'form' && is_array($currentid)) {
                foreach($currentid as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['currentid'] = $currentid;
            }
        }
        // query params
        if ($phonenumber !== null) {
            if('form' === 'form' && is_array($phonenumber)) {
                foreach($phonenumber as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['phonenumber'] = $phonenumber;
            }
        }
        // query params
        if ($cardnumber !== null) {
            if('form' === 'form' && is_array($cardnumber)) {
                foreach($cardnumber as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['cardnumber'] = $cardnumber;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation userget
     *
     * Search and view details of a user
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the user to get. (required)
     * @param  int $photosize The size in pixels of the photo URLs returned. Defaults to 40. If the size specified is not available, a similar one will be returned. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function userget($token, $id, $photosize = null)
    {
        $this->usergetWithHttpInfo($token, $id, $photosize);
    }

    /**
     * Operation usergetWithHttpInfo
     *
     * Search and view details of a user
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the user to get. (required)
     * @param  int $photosize The size in pixels of the photo URLs returned. Defaults to 40. If the size specified is not available, a similar one will be returned. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function usergetWithHttpInfo($token, $id, $photosize = null)
    {
        $request = $this->usergetRequest($token, $id, $photosize);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation usergetAsync
     *
     * Search and view details of a user
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the user to get. (required)
     * @param  int $photosize The size in pixels of the photo URLs returned. Defaults to 40. If the size specified is not available, a similar one will be returned. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usergetAsync($token, $id, $photosize = null)
    {
        return $this->usergetAsyncWithHttpInfo($token, $id, $photosize)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usergetAsyncWithHttpInfo
     *
     * Search and view details of a user
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the user to get. (required)
     * @param  int $photosize The size in pixels of the photo URLs returned. Defaults to 40. If the size specified is not available, a similar one will be returned. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usergetAsyncWithHttpInfo($token, $id, $photosize = null)
    {
        $returnType = '';
        $request = $this->usergetRequest($token, $id, $photosize);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'userget'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the user to get. (required)
     * @param  int $photosize The size in pixels of the photo URLs returned. Defaults to 40. If the size specified is not available, a similar one will be returned. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function usergetRequest($token, $id, $photosize = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling userget'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling userget'
            );
        }

        $resourcePath = '/userget';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($id !== null) {
            if('form' === 'form' && is_array($id)) {
                foreach($id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['id'] = $id;
            }
        }
        // query params
        if ($photosize !== null) {
            if('form' === 'form' && is_array($photosize)) {
                foreach($photosize as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['photosize'] = $photosize;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usergetbycard
     *
     * Search user by card number
     *
     * @param  string $token The authentication token. (required)
     * @param  string $card The card number of the user to get. (required)
     * @param  int $photosize The size in pixels of the photo URLs returned. Defaults to 40. If the size specified is not available, a similar one will be returned. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function usergetbycard($token, $card, $photosize = null)
    {
        $this->usergetbycardWithHttpInfo($token, $card, $photosize);
    }

    /**
     * Operation usergetbycardWithHttpInfo
     *
     * Search user by card number
     *
     * @param  string $token The authentication token. (required)
     * @param  string $card The card number of the user to get. (required)
     * @param  int $photosize The size in pixels of the photo URLs returned. Defaults to 40. If the size specified is not available, a similar one will be returned. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function usergetbycardWithHttpInfo($token, $card, $photosize = null)
    {
        $request = $this->usergetbycardRequest($token, $card, $photosize);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation usergetbycardAsync
     *
     * Search user by card number
     *
     * @param  string $token The authentication token. (required)
     * @param  string $card The card number of the user to get. (required)
     * @param  int $photosize The size in pixels of the photo URLs returned. Defaults to 40. If the size specified is not available, a similar one will be returned. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usergetbycardAsync($token, $card, $photosize = null)
    {
        return $this->usergetbycardAsyncWithHttpInfo($token, $card, $photosize)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usergetbycardAsyncWithHttpInfo
     *
     * Search user by card number
     *
     * @param  string $token The authentication token. (required)
     * @param  string $card The card number of the user to get. (required)
     * @param  int $photosize The size in pixels of the photo URLs returned. Defaults to 40. If the size specified is not available, a similar one will be returned. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usergetbycardAsyncWithHttpInfo($token, $card, $photosize = null)
    {
        $returnType = '';
        $request = $this->usergetbycardRequest($token, $card, $photosize);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usergetbycard'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $card The card number of the user to get. (required)
     * @param  int $photosize The size in pixels of the photo URLs returned. Defaults to 40. If the size specified is not available, a similar one will be returned. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function usergetbycardRequest($token, $card, $photosize = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling usergetbycard'
            );
        }
        // verify the required parameter 'card' is set
        if ($card === null || (is_array($card) && count($card) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $card when calling usergetbycard'
            );
        }

        $resourcePath = '/usergetbycard';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($card !== null) {
            if('form' === 'form' && is_array($card)) {
                foreach($card as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['card'] = $card;
            }
        }
        // query params
        if ($photosize !== null) {
            if('form' === 'form' && is_array($photosize)) {
                foreach($photosize as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['photosize'] = $photosize;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usergroupaddmember
     *
     * Add a user to a group
     *
     * @param  string $token The authentication token. (required)
     * @param  string $userid The id of the user to add. (required)
     * @param  string $groupid The id of the group. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function usergroupaddmember($token, $userid, $groupid)
    {
        $this->usergroupaddmemberWithHttpInfo($token, $userid, $groupid);
    }

    /**
     * Operation usergroupaddmemberWithHttpInfo
     *
     * Add a user to a group
     *
     * @param  string $token The authentication token. (required)
     * @param  string $userid The id of the user to add. (required)
     * @param  string $groupid The id of the group. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function usergroupaddmemberWithHttpInfo($token, $userid, $groupid)
    {
        $request = $this->usergroupaddmemberRequest($token, $userid, $groupid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation usergroupaddmemberAsync
     *
     * Add a user to a group
     *
     * @param  string $token The authentication token. (required)
     * @param  string $userid The id of the user to add. (required)
     * @param  string $groupid The id of the group. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usergroupaddmemberAsync($token, $userid, $groupid)
    {
        return $this->usergroupaddmemberAsyncWithHttpInfo($token, $userid, $groupid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usergroupaddmemberAsyncWithHttpInfo
     *
     * Add a user to a group
     *
     * @param  string $token The authentication token. (required)
     * @param  string $userid The id of the user to add. (required)
     * @param  string $groupid The id of the group. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usergroupaddmemberAsyncWithHttpInfo($token, $userid, $groupid)
    {
        $returnType = '';
        $request = $this->usergroupaddmemberRequest($token, $userid, $groupid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usergroupaddmember'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $userid The id of the user to add. (required)
     * @param  string $groupid The id of the group. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function usergroupaddmemberRequest($token, $userid, $groupid)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling usergroupaddmember'
            );
        }
        // verify the required parameter 'userid' is set
        if ($userid === null || (is_array($userid) && count($userid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userid when calling usergroupaddmember'
            );
        }
        // verify the required parameter 'groupid' is set
        if ($groupid === null || (is_array($groupid) && count($groupid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $groupid when calling usergroupaddmember'
            );
        }

        $resourcePath = '/usergroupaddmember';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($userid !== null) {
            if('form' === 'form' && is_array($userid)) {
                foreach($userid as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['userid'] = $userid;
            }
        }
        // query params
        if ($groupid !== null) {
            if('form' === 'form' && is_array($groupid)) {
                foreach($groupid as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['groupid'] = $groupid;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usergroupdelete
     *
     * Delete a group
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the group to delete. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function usergroupdelete($token, $id)
    {
        $this->usergroupdeleteWithHttpInfo($token, $id);
    }

    /**
     * Operation usergroupdeleteWithHttpInfo
     *
     * Delete a group
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the group to delete. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function usergroupdeleteWithHttpInfo($token, $id)
    {
        $request = $this->usergroupdeleteRequest($token, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation usergroupdeleteAsync
     *
     * Delete a group
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the group to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usergroupdeleteAsync($token, $id)
    {
        return $this->usergroupdeleteAsyncWithHttpInfo($token, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usergroupdeleteAsyncWithHttpInfo
     *
     * Delete a group
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the group to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usergroupdeleteAsyncWithHttpInfo($token, $id)
    {
        $returnType = '';
        $request = $this->usergroupdeleteRequest($token, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usergroupdelete'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the group to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function usergroupdeleteRequest($token, $id)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling usergroupdelete'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling usergroupdelete'
            );
        }

        $resourcePath = '/usergroupdelete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($id !== null) {
            if('form' === 'form' && is_array($id)) {
                foreach($id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['id'] = $id;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usergroupget
     *
     * Search and view details of a user group
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the user group to get. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function usergroupget($token, $id)
    {
        $this->usergroupgetWithHttpInfo($token, $id);
    }

    /**
     * Operation usergroupgetWithHttpInfo
     *
     * Search and view details of a user group
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the user group to get. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function usergroupgetWithHttpInfo($token, $id)
    {
        $request = $this->usergroupgetRequest($token, $id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation usergroupgetAsync
     *
     * Search and view details of a user group
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the user group to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usergroupgetAsync($token, $id)
    {
        return $this->usergroupgetAsyncWithHttpInfo($token, $id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usergroupgetAsyncWithHttpInfo
     *
     * Search and view details of a user group
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the user group to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usergroupgetAsyncWithHttpInfo($token, $id)
    {
        $returnType = '';
        $request = $this->usergroupgetRequest($token, $id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usergroupget'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $id The id of the user group to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function usergroupgetRequest($token, $id)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling usergroupget'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling usergroupget'
            );
        }

        $resourcePath = '/usergroupget';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($id !== null) {
            if('form' === 'form' && is_array($id)) {
                foreach($id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['id'] = $id;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usergroupgetmembers
     *
     * View the members of a user group
     *
     * @param  string $token The authentication token. (required)
     * @param  string $groupid The id of the user group to get. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function usergroupgetmembers($token, $groupid)
    {
        $this->usergroupgetmembersWithHttpInfo($token, $groupid);
    }

    /**
     * Operation usergroupgetmembersWithHttpInfo
     *
     * View the members of a user group
     *
     * @param  string $token The authentication token. (required)
     * @param  string $groupid The id of the user group to get. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function usergroupgetmembersWithHttpInfo($token, $groupid)
    {
        $request = $this->usergroupgetmembersRequest($token, $groupid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation usergroupgetmembersAsync
     *
     * View the members of a user group
     *
     * @param  string $token The authentication token. (required)
     * @param  string $groupid The id of the user group to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usergroupgetmembersAsync($token, $groupid)
    {
        return $this->usergroupgetmembersAsyncWithHttpInfo($token, $groupid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usergroupgetmembersAsyncWithHttpInfo
     *
     * View the members of a user group
     *
     * @param  string $token The authentication token. (required)
     * @param  string $groupid The id of the user group to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usergroupgetmembersAsyncWithHttpInfo($token, $groupid)
    {
        $returnType = '';
        $request = $this->usergroupgetmembersRequest($token, $groupid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usergroupgetmembers'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $groupid The id of the user group to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function usergroupgetmembersRequest($token, $groupid)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling usergroupgetmembers'
            );
        }
        // verify the required parameter 'groupid' is set
        if ($groupid === null || (is_array($groupid) && count($groupid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $groupid when calling usergroupgetmembers'
            );
        }

        $resourcePath = '/usergroupgetmembers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($groupid !== null) {
            if('form' === 'form' && is_array($groupid)) {
                foreach($groupid as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['groupid'] = $groupid;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usergroupgetuser
     *
     * View the groups which a user is registered to
     *
     * @param  string $token The authentication token. (required)
     * @param  string $userid The id of the user to get his groups. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function usergroupgetuser($token, $userid)
    {
        $this->usergroupgetuserWithHttpInfo($token, $userid);
    }

    /**
     * Operation usergroupgetuserWithHttpInfo
     *
     * View the groups which a user is registered to
     *
     * @param  string $token The authentication token. (required)
     * @param  string $userid The id of the user to get his groups. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function usergroupgetuserWithHttpInfo($token, $userid)
    {
        $request = $this->usergroupgetuserRequest($token, $userid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation usergroupgetuserAsync
     *
     * View the groups which a user is registered to
     *
     * @param  string $token The authentication token. (required)
     * @param  string $userid The id of the user to get his groups. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usergroupgetuserAsync($token, $userid)
    {
        return $this->usergroupgetuserAsyncWithHttpInfo($token, $userid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usergroupgetuserAsyncWithHttpInfo
     *
     * View the groups which a user is registered to
     *
     * @param  string $token The authentication token. (required)
     * @param  string $userid The id of the user to get his groups. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usergroupgetuserAsyncWithHttpInfo($token, $userid)
    {
        $returnType = '';
        $request = $this->usergroupgetuserRequest($token, $userid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usergroupgetuser'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $userid The id of the user to get his groups. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function usergroupgetuserRequest($token, $userid)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling usergroupgetuser'
            );
        }
        // verify the required parameter 'userid' is set
        if ($userid === null || (is_array($userid) && count($userid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userid when calling usergroupgetuser'
            );
        }

        $resourcePath = '/usergroupgetuser';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($userid !== null) {
            if('form' === 'form' && is_array($userid)) {
                foreach($userid as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['userid'] = $userid;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usergrouplist
     *
     * View a list of user groups
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (optional)
     * @param  int $count The max number of records to return. (optional)
     * @param  string $type The type of the groups to return. Either &#39;user&#39;, &#39;dynamic&#39; or any other type of group. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function usergrouplist($token, $from = null, $count = null, $type = null)
    {
        $this->usergrouplistWithHttpInfo($token, $from, $count, $type);
    }

    /**
     * Operation usergrouplistWithHttpInfo
     *
     * View a list of user groups
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (optional)
     * @param  int $count The max number of records to return. (optional)
     * @param  string $type The type of the groups to return. Either &#39;user&#39;, &#39;dynamic&#39; or any other type of group. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function usergrouplistWithHttpInfo($token, $from = null, $count = null, $type = null)
    {
        $request = $this->usergrouplistRequest($token, $from, $count, $type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation usergrouplistAsync
     *
     * View a list of user groups
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (optional)
     * @param  int $count The max number of records to return. (optional)
     * @param  string $type The type of the groups to return. Either &#39;user&#39;, &#39;dynamic&#39; or any other type of group. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usergrouplistAsync($token, $from = null, $count = null, $type = null)
    {
        return $this->usergrouplistAsyncWithHttpInfo($token, $from, $count, $type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usergrouplistAsyncWithHttpInfo
     *
     * View a list of user groups
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (optional)
     * @param  int $count The max number of records to return. (optional)
     * @param  string $type The type of the groups to return. Either &#39;user&#39;, &#39;dynamic&#39; or any other type of group. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usergrouplistAsyncWithHttpInfo($token, $from = null, $count = null, $type = null)
    {
        $returnType = '';
        $request = $this->usergrouplistRequest($token, $from, $count, $type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usergrouplist'
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (optional)
     * @param  int $count The max number of records to return. (optional)
     * @param  string $type The type of the groups to return. Either &#39;user&#39;, &#39;dynamic&#39; or any other type of group. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function usergrouplistRequest($token, $from = null, $count = null, $type = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling usergrouplist'
            );
        }

        $resourcePath = '/usergrouplist';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }
        // query params
        if ($count !== null) {
            if('form' === 'form' && is_array($count)) {
                foreach($count as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['count'] = $count;
            }
        }
        // query params
        if ($type !== null) {
            if('form' === 'form' && is_array($type)) {
                foreach($type as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['type'] = $type;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usergrouprefresh
     *
     * Refresh the dynamic group
     *
     * @param  string $token The authentication token. (required)
     * @param  string $group The ID of the group to refresh. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function usergrouprefresh($token, $group)
    {
        $this->usergrouprefreshWithHttpInfo($token, $group);
    }

    /**
     * Operation usergrouprefreshWithHttpInfo
     *
     * Refresh the dynamic group
     *
     * @param  string $token The authentication token. (required)
     * @param  string $group The ID of the group to refresh. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function usergrouprefreshWithHttpInfo($token, $group)
    {
        $request = $this->usergrouprefreshRequest($token, $group);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation usergrouprefreshAsync
     *
     * Refresh the dynamic group
     *
     * @param  string $token The authentication token. (required)
     * @param  string $group The ID of the group to refresh. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usergrouprefreshAsync($token, $group)
    {
        return $this->usergrouprefreshAsyncWithHttpInfo($token, $group)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usergrouprefreshAsyncWithHttpInfo
     *
     * Refresh the dynamic group
     *
     * @param  string $token The authentication token. (required)
     * @param  string $group The ID of the group to refresh. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usergrouprefreshAsyncWithHttpInfo($token, $group)
    {
        $returnType = '';
        $request = $this->usergrouprefreshRequest($token, $group);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usergrouprefresh'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $group The ID of the group to refresh. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function usergrouprefreshRequest($token, $group)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling usergrouprefresh'
            );
        }
        // verify the required parameter 'group' is set
        if ($group === null || (is_array($group) && count($group) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group when calling usergrouprefresh'
            );
        }

        $resourcePath = '/usergrouprefresh';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($group !== null) {
            if('form' === 'form' && is_array($group)) {
                foreach($group as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['group'] = $group;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usergroupremovemember
     *
     * Remove a user from a group
     *
     * @param  string $token The authentication token. (required)
     * @param  string $userid The id of the user to remove. (required)
     * @param  string $groupid The id of the group. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function usergroupremovemember($token, $userid, $groupid)
    {
        $this->usergroupremovememberWithHttpInfo($token, $userid, $groupid);
    }

    /**
     * Operation usergroupremovememberWithHttpInfo
     *
     * Remove a user from a group
     *
     * @param  string $token The authentication token. (required)
     * @param  string $userid The id of the user to remove. (required)
     * @param  string $groupid The id of the group. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function usergroupremovememberWithHttpInfo($token, $userid, $groupid)
    {
        $request = $this->usergroupremovememberRequest($token, $userid, $groupid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation usergroupremovememberAsync
     *
     * Remove a user from a group
     *
     * @param  string $token The authentication token. (required)
     * @param  string $userid The id of the user to remove. (required)
     * @param  string $groupid The id of the group. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usergroupremovememberAsync($token, $userid, $groupid)
    {
        return $this->usergroupremovememberAsyncWithHttpInfo($token, $userid, $groupid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usergroupremovememberAsyncWithHttpInfo
     *
     * Remove a user from a group
     *
     * @param  string $token The authentication token. (required)
     * @param  string $userid The id of the user to remove. (required)
     * @param  string $groupid The id of the group. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usergroupremovememberAsyncWithHttpInfo($token, $userid, $groupid)
    {
        $returnType = '';
        $request = $this->usergroupremovememberRequest($token, $userid, $groupid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usergroupremovemember'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $userid The id of the user to remove. (required)
     * @param  string $groupid The id of the group. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function usergroupremovememberRequest($token, $userid, $groupid)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling usergroupremovemember'
            );
        }
        // verify the required parameter 'userid' is set
        if ($userid === null || (is_array($userid) && count($userid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userid when calling usergroupremovemember'
            );
        }
        // verify the required parameter 'groupid' is set
        if ($groupid === null || (is_array($groupid) && count($groupid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $groupid when calling usergroupremovemember'
            );
        }

        $resourcePath = '/usergroupremovemember';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($userid !== null) {
            if('form' === 'form' && is_array($userid)) {
                foreach($userid as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['userid'] = $userid;
            }
        }
        // query params
        if ($groupid !== null) {
            if('form' === 'form' && is_array($groupid)) {
                foreach($groupid as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['groupid'] = $groupid;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usergroupsave
     *
     * Create or edit a group
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function usergroupsave($unknown_base_type = null)
    {
        $this->usergroupsaveWithHttpInfo($unknown_base_type);
    }

    /**
     * Operation usergroupsaveWithHttpInfo
     *
     * Create or edit a group
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function usergroupsaveWithHttpInfo($unknown_base_type = null)
    {
        $request = $this->usergroupsaveRequest($unknown_base_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation usergroupsaveAsync
     *
     * Create or edit a group
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usergroupsaveAsync($unknown_base_type = null)
    {
        return $this->usergroupsaveAsyncWithHttpInfo($unknown_base_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usergroupsaveAsyncWithHttpInfo
     *
     * Create or edit a group
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usergroupsaveAsyncWithHttpInfo($unknown_base_type = null)
    {
        $returnType = '';
        $request = $this->usergroupsaveRequest($unknown_base_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usergroupsave'
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function usergroupsaveRequest($unknown_base_type = null)
    {

        $resourcePath = '/usergroupsave';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($unknown_base_type)) {
            $_tempBody = $unknown_base_type;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation userlist
     *
     * View a list of users
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $roleid The id of the role to filter users by, or empty to return all users. (optional)
     * @param  string $onlywithoutcard If is 1 then only the users without a card are returned, otherwise all users are returned. (optional)
     * @param  int $photosize The size in pixels of the photo URLs returned. Defaults to 40. If the size specified is not available, a similar one will be returned. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function userlist($token, $from, $count, $roleid = null, $onlywithoutcard = null, $photosize = null)
    {
        $this->userlistWithHttpInfo($token, $from, $count, $roleid, $onlywithoutcard, $photosize);
    }

    /**
     * Operation userlistWithHttpInfo
     *
     * View a list of users
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $roleid The id of the role to filter users by, or empty to return all users. (optional)
     * @param  string $onlywithoutcard If is 1 then only the users without a card are returned, otherwise all users are returned. (optional)
     * @param  int $photosize The size in pixels of the photo URLs returned. Defaults to 40. If the size specified is not available, a similar one will be returned. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function userlistWithHttpInfo($token, $from, $count, $roleid = null, $onlywithoutcard = null, $photosize = null)
    {
        $request = $this->userlistRequest($token, $from, $count, $roleid, $onlywithoutcard, $photosize);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation userlistAsync
     *
     * View a list of users
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $roleid The id of the role to filter users by, or empty to return all users. (optional)
     * @param  string $onlywithoutcard If is 1 then only the users without a card are returned, otherwise all users are returned. (optional)
     * @param  int $photosize The size in pixels of the photo URLs returned. Defaults to 40. If the size specified is not available, a similar one will be returned. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function userlistAsync($token, $from, $count, $roleid = null, $onlywithoutcard = null, $photosize = null)
    {
        return $this->userlistAsyncWithHttpInfo($token, $from, $count, $roleid, $onlywithoutcard, $photosize)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation userlistAsyncWithHttpInfo
     *
     * View a list of users
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $roleid The id of the role to filter users by, or empty to return all users. (optional)
     * @param  string $onlywithoutcard If is 1 then only the users without a card are returned, otherwise all users are returned. (optional)
     * @param  int $photosize The size in pixels of the photo URLs returned. Defaults to 40. If the size specified is not available, a similar one will be returned. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function userlistAsyncWithHttpInfo($token, $from, $count, $roleid = null, $onlywithoutcard = null, $photosize = null)
    {
        $returnType = '';
        $request = $this->userlistRequest($token, $from, $count, $roleid, $onlywithoutcard, $photosize);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'userlist'
     *
     * @param  string $token The authentication token. (required)
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $roleid The id of the role to filter users by, or empty to return all users. (optional)
     * @param  string $onlywithoutcard If is 1 then only the users without a card are returned, otherwise all users are returned. (optional)
     * @param  int $photosize The size in pixels of the photo URLs returned. Defaults to 40. If the size specified is not available, a similar one will be returned. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function userlistRequest($token, $from, $count, $roleid = null, $onlywithoutcard = null, $photosize = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling userlist'
            );
        }
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling userlist'
            );
        }
        // verify the required parameter 'count' is set
        if ($count === null || (is_array($count) && count($count) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $count when calling userlist'
            );
        }

        $resourcePath = '/userlist';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }
        // query params
        if ($count !== null) {
            if('form' === 'form' && is_array($count)) {
                foreach($count as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['count'] = $count;
            }
        }
        // query params
        if ($roleid !== null) {
            if('form' === 'form' && is_array($roleid)) {
                foreach($roleid as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['roleid'] = $roleid;
            }
        }
        // query params
        if ($onlywithoutcard !== null) {
            if('form' === 'form' && is_array($onlywithoutcard)) {
                foreach($onlywithoutcard as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['onlywithoutcard'] = $onlywithoutcard;
            }
        }
        // query params
        if ($photosize !== null) {
            if('form' === 'form' && is_array($photosize)) {
                foreach($photosize as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['photosize'] = $photosize;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation userloadphoto
     *
     * Upload a photo for a specific user
     *
     * @param  string $token The authentication token. (required)
     * @param  string $upload Set &#39;file&#39; as value to indicate that a file is being submitted in the body (instead of a JSON object). (required)
     * @param  string $filename The local name of the uploaded file. For later reference. (optional)
     * @param  string $userid The user ID to directly associate the upload photo. If not specified, a temp ID is returned that can be later specified in &#39;user.save&#39;. (optional)
     * @param  bool $automatch Set this to true to find the specific user based on the file name. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function userloadphoto($token, $upload, $filename = null, $userid = null, $automatch = null)
    {
        $this->userloadphotoWithHttpInfo($token, $upload, $filename, $userid, $automatch);
    }

    /**
     * Operation userloadphotoWithHttpInfo
     *
     * Upload a photo for a specific user
     *
     * @param  string $token The authentication token. (required)
     * @param  string $upload Set &#39;file&#39; as value to indicate that a file is being submitted in the body (instead of a JSON object). (required)
     * @param  string $filename The local name of the uploaded file. For later reference. (optional)
     * @param  string $userid The user ID to directly associate the upload photo. If not specified, a temp ID is returned that can be later specified in &#39;user.save&#39;. (optional)
     * @param  bool $automatch Set this to true to find the specific user based on the file name. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function userloadphotoWithHttpInfo($token, $upload, $filename = null, $userid = null, $automatch = null)
    {
        $request = $this->userloadphotoRequest($token, $upload, $filename, $userid, $automatch);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation userloadphotoAsync
     *
     * Upload a photo for a specific user
     *
     * @param  string $token The authentication token. (required)
     * @param  string $upload Set &#39;file&#39; as value to indicate that a file is being submitted in the body (instead of a JSON object). (required)
     * @param  string $filename The local name of the uploaded file. For later reference. (optional)
     * @param  string $userid The user ID to directly associate the upload photo. If not specified, a temp ID is returned that can be later specified in &#39;user.save&#39;. (optional)
     * @param  bool $automatch Set this to true to find the specific user based on the file name. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function userloadphotoAsync($token, $upload, $filename = null, $userid = null, $automatch = null)
    {
        return $this->userloadphotoAsyncWithHttpInfo($token, $upload, $filename, $userid, $automatch)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation userloadphotoAsyncWithHttpInfo
     *
     * Upload a photo for a specific user
     *
     * @param  string $token The authentication token. (required)
     * @param  string $upload Set &#39;file&#39; as value to indicate that a file is being submitted in the body (instead of a JSON object). (required)
     * @param  string $filename The local name of the uploaded file. For later reference. (optional)
     * @param  string $userid The user ID to directly associate the upload photo. If not specified, a temp ID is returned that can be later specified in &#39;user.save&#39;. (optional)
     * @param  bool $automatch Set this to true to find the specific user based on the file name. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function userloadphotoAsyncWithHttpInfo($token, $upload, $filename = null, $userid = null, $automatch = null)
    {
        $returnType = '';
        $request = $this->userloadphotoRequest($token, $upload, $filename, $userid, $automatch);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'userloadphoto'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $upload Set &#39;file&#39; as value to indicate that a file is being submitted in the body (instead of a JSON object). (required)
     * @param  string $filename The local name of the uploaded file. For later reference. (optional)
     * @param  string $userid The user ID to directly associate the upload photo. If not specified, a temp ID is returned that can be later specified in &#39;user.save&#39;. (optional)
     * @param  bool $automatch Set this to true to find the specific user based on the file name. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function userloadphotoRequest($token, $upload, $filename = null, $userid = null, $automatch = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling userloadphoto'
            );
        }
        // verify the required parameter 'upload' is set
        if ($upload === null || (is_array($upload) && count($upload) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $upload when calling userloadphoto'
            );
        }

        $resourcePath = '/userloadphoto';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($upload !== null) {
            if('form' === 'form' && is_array($upload)) {
                foreach($upload as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['upload'] = $upload;
            }
        }
        // query params
        if ($filename !== null) {
            if('form' === 'form' && is_array($filename)) {
                foreach($filename as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['filename'] = $filename;
            }
        }
        // query params
        if ($userid !== null) {
            if('form' === 'form' && is_array($userid)) {
                foreach($userid as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['userid'] = $userid;
            }
        }
        // query params
        if ($automatch !== null) {
            if('form' === 'form' && is_array($automatch)) {
                foreach($automatch as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['automatch'] = $automatch;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usermovedata
     *
     * Move data between users
     *
     * @param  string $token The authentication token. (required)
     * @param  string $source The id of the user that is the source of the data. (required)
     * @param  string $destination The id of the user that is the destination of the data. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function usermovedata($token, $source, $destination)
    {
        $this->usermovedataWithHttpInfo($token, $source, $destination);
    }

    /**
     * Operation usermovedataWithHttpInfo
     *
     * Move data between users
     *
     * @param  string $token The authentication token. (required)
     * @param  string $source The id of the user that is the source of the data. (required)
     * @param  string $destination The id of the user that is the destination of the data. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function usermovedataWithHttpInfo($token, $source, $destination)
    {
        $request = $this->usermovedataRequest($token, $source, $destination);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation usermovedataAsync
     *
     * Move data between users
     *
     * @param  string $token The authentication token. (required)
     * @param  string $source The id of the user that is the source of the data. (required)
     * @param  string $destination The id of the user that is the destination of the data. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usermovedataAsync($token, $source, $destination)
    {
        return $this->usermovedataAsyncWithHttpInfo($token, $source, $destination)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usermovedataAsyncWithHttpInfo
     *
     * Move data between users
     *
     * @param  string $token The authentication token. (required)
     * @param  string $source The id of the user that is the source of the data. (required)
     * @param  string $destination The id of the user that is the destination of the data. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usermovedataAsyncWithHttpInfo($token, $source, $destination)
    {
        $returnType = '';
        $request = $this->usermovedataRequest($token, $source, $destination);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usermovedata'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $source The id of the user that is the source of the data. (required)
     * @param  string $destination The id of the user that is the destination of the data. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function usermovedataRequest($token, $source, $destination)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling usermovedata'
            );
        }
        // verify the required parameter 'source' is set
        if ($source === null || (is_array($source) && count($source) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $source when calling usermovedata'
            );
        }
        // verify the required parameter 'destination' is set
        if ($destination === null || (is_array($destination) && count($destination) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destination when calling usermovedata'
            );
        }

        $resourcePath = '/usermovedata';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($source !== null) {
            if('form' === 'form' && is_array($source)) {
                foreach($source as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['source'] = $source;
            }
        }
        // query params
        if ($destination !== null) {
            if('form' === 'form' && is_array($destination)) {
                foreach($destination as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['destination'] = $destination;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation userrequestpwdchange
     *
     * Requests a password change
     *
     * @param  string $domain The domain of the account where the user exists. (required)
     * @param  string $email The email of the user. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function userrequestpwdchange($domain, $email)
    {
        $this->userrequestpwdchangeWithHttpInfo($domain, $email);
    }

    /**
     * Operation userrequestpwdchangeWithHttpInfo
     *
     * Requests a password change
     *
     * @param  string $domain The domain of the account where the user exists. (required)
     * @param  string $email The email of the user. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function userrequestpwdchangeWithHttpInfo($domain, $email)
    {
        $request = $this->userrequestpwdchangeRequest($domain, $email);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation userrequestpwdchangeAsync
     *
     * Requests a password change
     *
     * @param  string $domain The domain of the account where the user exists. (required)
     * @param  string $email The email of the user. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function userrequestpwdchangeAsync($domain, $email)
    {
        return $this->userrequestpwdchangeAsyncWithHttpInfo($domain, $email)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation userrequestpwdchangeAsyncWithHttpInfo
     *
     * Requests a password change
     *
     * @param  string $domain The domain of the account where the user exists. (required)
     * @param  string $email The email of the user. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function userrequestpwdchangeAsyncWithHttpInfo($domain, $email)
    {
        $returnType = '';
        $request = $this->userrequestpwdchangeRequest($domain, $email);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'userrequestpwdchange'
     *
     * @param  string $domain The domain of the account where the user exists. (required)
     * @param  string $email The email of the user. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function userrequestpwdchangeRequest($domain, $email)
    {
        // verify the required parameter 'domain' is set
        if ($domain === null || (is_array($domain) && count($domain) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $domain when calling userrequestpwdchange'
            );
        }
        // verify the required parameter 'email' is set
        if ($email === null || (is_array($email) && count($email) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $email when calling userrequestpwdchange'
            );
        }

        $resourcePath = '/userrequestpwdchange';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($domain !== null) {
            if('form' === 'form' && is_array($domain)) {
                foreach($domain as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['domain'] = $domain;
            }
        }
        // query params
        if ($email !== null) {
            if('form' === 'form' && is_array($email)) {
                foreach($email as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['email'] = $email;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersave
     *
     * Create or edit a user
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function usersave($unknown_base_type = null)
    {
        $this->usersaveWithHttpInfo($unknown_base_type);
    }

    /**
     * Operation usersaveWithHttpInfo
     *
     * Create or edit a user
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersaveWithHttpInfo($unknown_base_type = null)
    {
        $request = $this->usersaveRequest($unknown_base_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation usersaveAsync
     *
     * Create or edit a user
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersaveAsync($unknown_base_type = null)
    {
        return $this->usersaveAsyncWithHttpInfo($unknown_base_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersaveAsyncWithHttpInfo
     *
     * Create or edit a user
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersaveAsyncWithHttpInfo($unknown_base_type = null)
    {
        $returnType = '';
        $request = $this->usersaveRequest($unknown_base_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersave'
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function usersaveRequest($unknown_base_type = null)
    {

        $resourcePath = '/usersave';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($unknown_base_type)) {
            $_tempBody = $unknown_base_type;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersavepwdchange
     *
     * Send email to the specified user(s) to set/change their passwords
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function usersavepwdchange($unknown_base_type = null)
    {
        $this->usersavepwdchangeWithHttpInfo($unknown_base_type);
    }

    /**
     * Operation usersavepwdchangeWithHttpInfo
     *
     * Send email to the specified user(s) to set/change their passwords
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersavepwdchangeWithHttpInfo($unknown_base_type = null)
    {
        $request = $this->usersavepwdchangeRequest($unknown_base_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation usersavepwdchangeAsync
     *
     * Send email to the specified user(s) to set/change their passwords
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersavepwdchangeAsync($unknown_base_type = null)
    {
        return $this->usersavepwdchangeAsyncWithHttpInfo($unknown_base_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersavepwdchangeAsyncWithHttpInfo
     *
     * Send email to the specified user(s) to set/change their passwords
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersavepwdchangeAsyncWithHttpInfo($unknown_base_type = null)
    {
        $returnType = '';
        $request = $this->usersavepwdchangeRequest($unknown_base_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersavepwdchange'
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function usersavepwdchangeRequest($unknown_base_type = null)
    {

        $resourcePath = '/usersavepwdchange';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($unknown_base_type)) {
            $_tempBody = $unknown_base_type;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersettingsget
     *
     * Lists available user settings
     *
     * @param  string $token The authentication token. (required)
     * @param  string $keys Setting key to get. Can be multiple separated by commas. (required)
     * @param  string $user The user id whose settings have to be returned. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function usersettingsget($token, $keys, $user = null)
    {
        $this->usersettingsgetWithHttpInfo($token, $keys, $user);
    }

    /**
     * Operation usersettingsgetWithHttpInfo
     *
     * Lists available user settings
     *
     * @param  string $token The authentication token. (required)
     * @param  string $keys Setting key to get. Can be multiple separated by commas. (required)
     * @param  string $user The user id whose settings have to be returned. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersettingsgetWithHttpInfo($token, $keys, $user = null)
    {
        $request = $this->usersettingsgetRequest($token, $keys, $user);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation usersettingsgetAsync
     *
     * Lists available user settings
     *
     * @param  string $token The authentication token. (required)
     * @param  string $keys Setting key to get. Can be multiple separated by commas. (required)
     * @param  string $user The user id whose settings have to be returned. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersettingsgetAsync($token, $keys, $user = null)
    {
        return $this->usersettingsgetAsyncWithHttpInfo($token, $keys, $user)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersettingsgetAsyncWithHttpInfo
     *
     * Lists available user settings
     *
     * @param  string $token The authentication token. (required)
     * @param  string $keys Setting key to get. Can be multiple separated by commas. (required)
     * @param  string $user The user id whose settings have to be returned. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersettingsgetAsyncWithHttpInfo($token, $keys, $user = null)
    {
        $returnType = '';
        $request = $this->usersettingsgetRequest($token, $keys, $user);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersettingsget'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $keys Setting key to get. Can be multiple separated by commas. (required)
     * @param  string $user The user id whose settings have to be returned. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function usersettingsgetRequest($token, $keys, $user = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling usersettingsget'
            );
        }
        // verify the required parameter 'keys' is set
        if ($keys === null || (is_array($keys) && count($keys) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $keys when calling usersettingsget'
            );
        }

        $resourcePath = '/usersettingsget';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($keys !== null) {
            if('form' === 'form' && is_array($keys)) {
                foreach($keys as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['keys'] = $keys;
            }
        }
        // query params
        if ($user !== null) {
            if('form' === 'form' && is_array($user)) {
                foreach($user as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['user'] = $user;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersettingsgetmultiple
     *
     * Get multiple user settings
     *
     * @param  string $token The authentication token. (required)
     * @param  string $keys Setting key to get. Can be multiple separated by commas. (required)
     * @param  string $user The user id whose settings have to be returned. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function usersettingsgetmultiple($token, $keys, $user = null)
    {
        $this->usersettingsgetmultipleWithHttpInfo($token, $keys, $user);
    }

    /**
     * Operation usersettingsgetmultipleWithHttpInfo
     *
     * Get multiple user settings
     *
     * @param  string $token The authentication token. (required)
     * @param  string $keys Setting key to get. Can be multiple separated by commas. (required)
     * @param  string $user The user id whose settings have to be returned. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersettingsgetmultipleWithHttpInfo($token, $keys, $user = null)
    {
        $request = $this->usersettingsgetmultipleRequest($token, $keys, $user);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation usersettingsgetmultipleAsync
     *
     * Get multiple user settings
     *
     * @param  string $token The authentication token. (required)
     * @param  string $keys Setting key to get. Can be multiple separated by commas. (required)
     * @param  string $user The user id whose settings have to be returned. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersettingsgetmultipleAsync($token, $keys, $user = null)
    {
        return $this->usersettingsgetmultipleAsyncWithHttpInfo($token, $keys, $user)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersettingsgetmultipleAsyncWithHttpInfo
     *
     * Get multiple user settings
     *
     * @param  string $token The authentication token. (required)
     * @param  string $keys Setting key to get. Can be multiple separated by commas. (required)
     * @param  string $user The user id whose settings have to be returned. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersettingsgetmultipleAsyncWithHttpInfo($token, $keys, $user = null)
    {
        $returnType = '';
        $request = $this->usersettingsgetmultipleRequest($token, $keys, $user);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersettingsgetmultiple'
     *
     * @param  string $token The authentication token. (required)
     * @param  string $keys Setting key to get. Can be multiple separated by commas. (required)
     * @param  string $user The user id whose settings have to be returned. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function usersettingsgetmultipleRequest($token, $keys, $user = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling usersettingsgetmultiple'
            );
        }
        // verify the required parameter 'keys' is set
        if ($keys === null || (is_array($keys) && count($keys) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $keys when calling usersettingsgetmultiple'
            );
        }

        $resourcePath = '/usersettingsgetmultiple';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }
        // query params
        if ($keys !== null) {
            if('form' === 'form' && is_array($keys)) {
                foreach($keys as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['keys'] = $keys;
            }
        }
        // query params
        if ($user !== null) {
            if('form' === 'form' && is_array($user)) {
                foreach($user as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['user'] = $user;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersettingssave
     *
     * Saves a user setting
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function usersettingssave($unknown_base_type = null)
    {
        $this->usersettingssaveWithHttpInfo($unknown_base_type);
    }

    /**
     * Operation usersettingssaveWithHttpInfo
     *
     * Saves a user setting
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersettingssaveWithHttpInfo($unknown_base_type = null)
    {
        $request = $this->usersettingssaveRequest($unknown_base_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation usersettingssaveAsync
     *
     * Saves a user setting
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersettingssaveAsync($unknown_base_type = null)
    {
        return $this->usersettingssaveAsyncWithHttpInfo($unknown_base_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersettingssaveAsyncWithHttpInfo
     *
     * Saves a user setting
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersettingssaveAsyncWithHttpInfo($unknown_base_type = null)
    {
        $returnType = '';
        $request = $this->usersettingssaveRequest($unknown_base_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersettingssave'
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function usersettingssaveRequest($unknown_base_type = null)
    {

        $resourcePath = '/usersettingssave';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($unknown_base_type)) {
            $_tempBody = $unknown_base_type;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersettingssavemultiple
     *
     * Save multiple user settings at once
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function usersettingssavemultiple($unknown_base_type = null)
    {
        $this->usersettingssavemultipleWithHttpInfo($unknown_base_type);
    }

    /**
     * Operation usersettingssavemultipleWithHttpInfo
     *
     * Save multiple user settings at once
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersettingssavemultipleWithHttpInfo($unknown_base_type = null)
    {
        $request = $this->usersettingssavemultipleRequest($unknown_base_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation usersettingssavemultipleAsync
     *
     * Save multiple user settings at once
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersettingssavemultipleAsync($unknown_base_type = null)
    {
        return $this->usersettingssavemultipleAsyncWithHttpInfo($unknown_base_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersettingssavemultipleAsyncWithHttpInfo
     *
     * Save multiple user settings at once
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersettingssavemultipleAsyncWithHttpInfo($unknown_base_type = null)
    {
        $returnType = '';
        $request = $this->usersettingssavemultipleRequest($unknown_base_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersettingssavemultiple'
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function usersettingssavemultipleRequest($unknown_base_type = null)
    {

        $resourcePath = '/usersettingssavemultiple';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($unknown_base_type)) {
            $_tempBody = $unknown_base_type;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation version
     *
     * Get current version information
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function version($token)
    {
        $this->versionWithHttpInfo($token);
    }

    /**
     * Operation versionWithHttpInfo
     *
     * Get current version information
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function versionWithHttpInfo($token)
    {
        $request = $this->versionRequest($token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation versionAsync
     *
     * Get current version information
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function versionAsync($token)
    {
        return $this->versionAsyncWithHttpInfo($token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation versionAsyncWithHttpInfo
     *
     * Get current version information
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function versionAsyncWithHttpInfo($token)
    {
        $returnType = '';
        $request = $this->versionRequest($token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'version'
     *
     * @param  string $token The authentication token. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function versionRequest($token)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling version'
            );
        }

        $resourcePath = '/version';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($token !== null) {
            if('form' === 'form' && is_array($token)) {
                foreach($token as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['token'] = $token;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
