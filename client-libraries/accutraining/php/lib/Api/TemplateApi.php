<?php
/**
 * TemplateApi
 * PHP version 5
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * AccuTraining OpenAPI 3
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 4.3.1
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * TemplateApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class TemplateApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $host_index (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $host_index = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $host_index;
    }

    /**
     * Set the host index
     *
     * @param  int Host index (required)
     */
    public function setHostIndex($host_index)
    {
        $this->hostIndex = $host_index;
    }

    /**
     * Get the host index
     *
     * @return Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation templateAddimage
     *
     * Add an image to a template
     *
     * @param  string $template The id of the template where the image has to be added (required)
     * @param  string $upload Set &#39;file&#39; as value to indicate that a file is being submitted in the body (instead of a JSON object). (required)
     * @param  string $filename The local name of the uploaded file. For later reference. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function templateAddimage($template, $upload, $filename = null)
    {
        $this->templateAddimageWithHttpInfo($template, $upload, $filename);
    }

    /**
     * Operation templateAddimageWithHttpInfo
     *
     * Add an image to a template
     *
     * @param  string $template The id of the template where the image has to be added (required)
     * @param  string $upload Set &#39;file&#39; as value to indicate that a file is being submitted in the body (instead of a JSON object). (required)
     * @param  string $filename The local name of the uploaded file. For later reference. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function templateAddimageWithHttpInfo($template, $upload, $filename = null)
    {
        $request = $this->templateAddimageRequest($template, $upload, $filename);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation templateAddimageAsync
     *
     * Add an image to a template
     *
     * @param  string $template The id of the template where the image has to be added (required)
     * @param  string $upload Set &#39;file&#39; as value to indicate that a file is being submitted in the body (instead of a JSON object). (required)
     * @param  string $filename The local name of the uploaded file. For later reference. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function templateAddimageAsync($template, $upload, $filename = null)
    {
        return $this->templateAddimageAsyncWithHttpInfo($template, $upload, $filename)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation templateAddimageAsyncWithHttpInfo
     *
     * Add an image to a template
     *
     * @param  string $template The id of the template where the image has to be added (required)
     * @param  string $upload Set &#39;file&#39; as value to indicate that a file is being submitted in the body (instead of a JSON object). (required)
     * @param  string $filename The local name of the uploaded file. For later reference. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function templateAddimageAsyncWithHttpInfo($template, $upload, $filename = null)
    {
        $returnType = '';
        $request = $this->templateAddimageRequest($template, $upload, $filename);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'templateAddimage'
     *
     * @param  string $template The id of the template where the image has to be added (required)
     * @param  string $upload Set &#39;file&#39; as value to indicate that a file is being submitted in the body (instead of a JSON object). (required)
     * @param  string $filename The local name of the uploaded file. For later reference. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function templateAddimageRequest($template, $upload, $filename = null)
    {
        // verify the required parameter 'template' is set
        if ($template === null || (is_array($template) && count($template) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template when calling templateAddimage'
            );
        }
        // verify the required parameter 'upload' is set
        if ($upload === null || (is_array($upload) && count($upload) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $upload when calling templateAddimage'
            );
        }

        $resourcePath = '/template/addimage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($template !== null) {
            if('form' === 'form' && is_array($template)) {
                foreach($template as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['template'] = $template;
            }
        }
        // query params
        if ($upload !== null) {
            if('form' === 'form' && is_array($upload)) {
                foreach($upload as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['upload'] = $upload;
            }
        }
        // query params
        if ($filename !== null) {
            if('form' === 'form' && is_array($filename)) {
                foreach($filename as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['filename'] = $filename;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Bearer (string) authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation templateDelete
     *
     * Delete a template
     *
     * @param  string $id The id of the template to delete. (required)
     * @param  AnyType $body body (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function templateDelete($id, $body = null)
    {
        $this->templateDeleteWithHttpInfo($id, $body);
    }

    /**
     * Operation templateDeleteWithHttpInfo
     *
     * Delete a template
     *
     * @param  string $id The id of the template to delete. (required)
     * @param  AnyType $body (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function templateDeleteWithHttpInfo($id, $body = null)
    {
        $request = $this->templateDeleteRequest($id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation templateDeleteAsync
     *
     * Delete a template
     *
     * @param  string $id The id of the template to delete. (required)
     * @param  AnyType $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function templateDeleteAsync($id, $body = null)
    {
        return $this->templateDeleteAsyncWithHttpInfo($id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation templateDeleteAsyncWithHttpInfo
     *
     * Delete a template
     *
     * @param  string $id The id of the template to delete. (required)
     * @param  AnyType $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function templateDeleteAsyncWithHttpInfo($id, $body = null)
    {
        $returnType = '';
        $request = $this->templateDeleteRequest($id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'templateDelete'
     *
     * @param  string $id The id of the template to delete. (required)
     * @param  AnyType $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function templateDeleteRequest($id, $body = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling templateDelete'
            );
        }

        $resourcePath = '/template/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Bearer (string) authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation templateEmail
     *
     * Send generated templates by email
     *
     * @param  string $jobid The id of the job that is creating the templates. (required)
     * @param  string $emailsubject Args depending on the send-to flag. (required)
     * @param  string $emailbody Args depending on the send-to flag. (required)
     * @param  string $templatekind The kind of the template you&#39;re sending. It must be included in (badge, certificate). (optional)
     * @param  string $emailfrom The name of the sender to be displayed in the receipients inbox (optional)
     * @param  string $emailreplyto The reply-to field for the emails. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function templateEmail($jobid, $emailsubject, $emailbody, $templatekind = null, $emailfrom = null, $emailreplyto = null)
    {
        $this->templateEmailWithHttpInfo($jobid, $emailsubject, $emailbody, $templatekind, $emailfrom, $emailreplyto);
    }

    /**
     * Operation templateEmailWithHttpInfo
     *
     * Send generated templates by email
     *
     * @param  string $jobid The id of the job that is creating the templates. (required)
     * @param  string $emailsubject Args depending on the send-to flag. (required)
     * @param  string $emailbody Args depending on the send-to flag. (required)
     * @param  string $templatekind The kind of the template you&#39;re sending. It must be included in (badge, certificate). (optional)
     * @param  string $emailfrom The name of the sender to be displayed in the receipients inbox (optional)
     * @param  string $emailreplyto The reply-to field for the emails. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function templateEmailWithHttpInfo($jobid, $emailsubject, $emailbody, $templatekind = null, $emailfrom = null, $emailreplyto = null)
    {
        $request = $this->templateEmailRequest($jobid, $emailsubject, $emailbody, $templatekind, $emailfrom, $emailreplyto);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation templateEmailAsync
     *
     * Send generated templates by email
     *
     * @param  string $jobid The id of the job that is creating the templates. (required)
     * @param  string $emailsubject Args depending on the send-to flag. (required)
     * @param  string $emailbody Args depending on the send-to flag. (required)
     * @param  string $templatekind The kind of the template you&#39;re sending. It must be included in (badge, certificate). (optional)
     * @param  string $emailfrom The name of the sender to be displayed in the receipients inbox (optional)
     * @param  string $emailreplyto The reply-to field for the emails. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function templateEmailAsync($jobid, $emailsubject, $emailbody, $templatekind = null, $emailfrom = null, $emailreplyto = null)
    {
        return $this->templateEmailAsyncWithHttpInfo($jobid, $emailsubject, $emailbody, $templatekind, $emailfrom, $emailreplyto)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation templateEmailAsyncWithHttpInfo
     *
     * Send generated templates by email
     *
     * @param  string $jobid The id of the job that is creating the templates. (required)
     * @param  string $emailsubject Args depending on the send-to flag. (required)
     * @param  string $emailbody Args depending on the send-to flag. (required)
     * @param  string $templatekind The kind of the template you&#39;re sending. It must be included in (badge, certificate). (optional)
     * @param  string $emailfrom The name of the sender to be displayed in the receipients inbox (optional)
     * @param  string $emailreplyto The reply-to field for the emails. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function templateEmailAsyncWithHttpInfo($jobid, $emailsubject, $emailbody, $templatekind = null, $emailfrom = null, $emailreplyto = null)
    {
        $returnType = '';
        $request = $this->templateEmailRequest($jobid, $emailsubject, $emailbody, $templatekind, $emailfrom, $emailreplyto);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'templateEmail'
     *
     * @param  string $jobid The id of the job that is creating the templates. (required)
     * @param  string $emailsubject Args depending on the send-to flag. (required)
     * @param  string $emailbody Args depending on the send-to flag. (required)
     * @param  string $templatekind The kind of the template you&#39;re sending. It must be included in (badge, certificate). (optional)
     * @param  string $emailfrom The name of the sender to be displayed in the receipients inbox (optional)
     * @param  string $emailreplyto The reply-to field for the emails. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function templateEmailRequest($jobid, $emailsubject, $emailbody, $templatekind = null, $emailfrom = null, $emailreplyto = null)
    {
        // verify the required parameter 'jobid' is set
        if ($jobid === null || (is_array($jobid) && count($jobid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $jobid when calling templateEmail'
            );
        }
        // verify the required parameter 'emailsubject' is set
        if ($emailsubject === null || (is_array($emailsubject) && count($emailsubject) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $emailsubject when calling templateEmail'
            );
        }
        // verify the required parameter 'emailbody' is set
        if ($emailbody === null || (is_array($emailbody) && count($emailbody) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $emailbody when calling templateEmail'
            );
        }

        $resourcePath = '/template/email';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($jobid !== null) {
            if('form' === 'form' && is_array($jobid)) {
                foreach($jobid as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['jobid'] = $jobid;
            }
        }
        // query params
        if ($templatekind !== null) {
            if('form' === 'form' && is_array($templatekind)) {
                foreach($templatekind as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['templatekind'] = $templatekind;
            }
        }
        // query params
        if ($emailfrom !== null) {
            if('form' === 'form' && is_array($emailfrom)) {
                foreach($emailfrom as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['emailfrom'] = $emailfrom;
            }
        }
        // query params
        if ($emailreplyto !== null) {
            if('form' === 'form' && is_array($emailreplyto)) {
                foreach($emailreplyto as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['emailreplyto'] = $emailreplyto;
            }
        }
        // query params
        if ($emailsubject !== null) {
            if('form' === 'form' && is_array($emailsubject)) {
                foreach($emailsubject as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['emailsubject'] = $emailsubject;
            }
        }
        // query params
        if ($emailbody !== null) {
            if('form' === 'form' && is_array($emailbody)) {
                foreach($emailbody as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['emailbody'] = $emailbody;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Bearer (string) authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation templateGenerate
     *
     * Generate specified templates
     *
     * @param  string $template The id of the template to generate. (required)
     * @param  string $source The source key of the selected template data source. (required)
     * @param  bool $singlefile True if all the templates should be placed in the same file, false if each one shoud be in its own file. (required)
     * @param  string $userid Only the template for these users is created (and emailed if &#39;email&#39; is true), enter multiple separated by commas. (optional)
     * @param  bool $forsending It specifies the purpose of the creation of the templates. If true then is for sending via e-mail, otherwise is just for downloading (optional)
     * @param  string $role When printing all badges, filter by person type, can be either: attendee, presenter or exhibitor (optional)
     * @param  string $filters Pipe separated filters for the generation, eg: aaa&#x3D;val|bbb&#x3D;val|... (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function templateGenerate($template, $source, $singlefile, $userid = null, $forsending = null, $role = null, $filters = null)
    {
        $this->templateGenerateWithHttpInfo($template, $source, $singlefile, $userid, $forsending, $role, $filters);
    }

    /**
     * Operation templateGenerateWithHttpInfo
     *
     * Generate specified templates
     *
     * @param  string $template The id of the template to generate. (required)
     * @param  string $source The source key of the selected template data source. (required)
     * @param  bool $singlefile True if all the templates should be placed in the same file, false if each one shoud be in its own file. (required)
     * @param  string $userid Only the template for these users is created (and emailed if &#39;email&#39; is true), enter multiple separated by commas. (optional)
     * @param  bool $forsending It specifies the purpose of the creation of the templates. If true then is for sending via e-mail, otherwise is just for downloading (optional)
     * @param  string $role When printing all badges, filter by person type, can be either: attendee, presenter or exhibitor (optional)
     * @param  string $filters Pipe separated filters for the generation, eg: aaa&#x3D;val|bbb&#x3D;val|... (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function templateGenerateWithHttpInfo($template, $source, $singlefile, $userid = null, $forsending = null, $role = null, $filters = null)
    {
        $request = $this->templateGenerateRequest($template, $source, $singlefile, $userid, $forsending, $role, $filters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation templateGenerateAsync
     *
     * Generate specified templates
     *
     * @param  string $template The id of the template to generate. (required)
     * @param  string $source The source key of the selected template data source. (required)
     * @param  bool $singlefile True if all the templates should be placed in the same file, false if each one shoud be in its own file. (required)
     * @param  string $userid Only the template for these users is created (and emailed if &#39;email&#39; is true), enter multiple separated by commas. (optional)
     * @param  bool $forsending It specifies the purpose of the creation of the templates. If true then is for sending via e-mail, otherwise is just for downloading (optional)
     * @param  string $role When printing all badges, filter by person type, can be either: attendee, presenter or exhibitor (optional)
     * @param  string $filters Pipe separated filters for the generation, eg: aaa&#x3D;val|bbb&#x3D;val|... (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function templateGenerateAsync($template, $source, $singlefile, $userid = null, $forsending = null, $role = null, $filters = null)
    {
        return $this->templateGenerateAsyncWithHttpInfo($template, $source, $singlefile, $userid, $forsending, $role, $filters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation templateGenerateAsyncWithHttpInfo
     *
     * Generate specified templates
     *
     * @param  string $template The id of the template to generate. (required)
     * @param  string $source The source key of the selected template data source. (required)
     * @param  bool $singlefile True if all the templates should be placed in the same file, false if each one shoud be in its own file. (required)
     * @param  string $userid Only the template for these users is created (and emailed if &#39;email&#39; is true), enter multiple separated by commas. (optional)
     * @param  bool $forsending It specifies the purpose of the creation of the templates. If true then is for sending via e-mail, otherwise is just for downloading (optional)
     * @param  string $role When printing all badges, filter by person type, can be either: attendee, presenter or exhibitor (optional)
     * @param  string $filters Pipe separated filters for the generation, eg: aaa&#x3D;val|bbb&#x3D;val|... (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function templateGenerateAsyncWithHttpInfo($template, $source, $singlefile, $userid = null, $forsending = null, $role = null, $filters = null)
    {
        $returnType = '';
        $request = $this->templateGenerateRequest($template, $source, $singlefile, $userid, $forsending, $role, $filters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'templateGenerate'
     *
     * @param  string $template The id of the template to generate. (required)
     * @param  string $source The source key of the selected template data source. (required)
     * @param  bool $singlefile True if all the templates should be placed in the same file, false if each one shoud be in its own file. (required)
     * @param  string $userid Only the template for these users is created (and emailed if &#39;email&#39; is true), enter multiple separated by commas. (optional)
     * @param  bool $forsending It specifies the purpose of the creation of the templates. If true then is for sending via e-mail, otherwise is just for downloading (optional)
     * @param  string $role When printing all badges, filter by person type, can be either: attendee, presenter or exhibitor (optional)
     * @param  string $filters Pipe separated filters for the generation, eg: aaa&#x3D;val|bbb&#x3D;val|... (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function templateGenerateRequest($template, $source, $singlefile, $userid = null, $forsending = null, $role = null, $filters = null)
    {
        // verify the required parameter 'template' is set
        if ($template === null || (is_array($template) && count($template) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template when calling templateGenerate'
            );
        }
        // verify the required parameter 'source' is set
        if ($source === null || (is_array($source) && count($source) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $source when calling templateGenerate'
            );
        }
        // verify the required parameter 'singlefile' is set
        if ($singlefile === null || (is_array($singlefile) && count($singlefile) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $singlefile when calling templateGenerate'
            );
        }

        $resourcePath = '/template/generate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($template !== null) {
            if('form' === 'form' && is_array($template)) {
                foreach($template as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['template'] = $template;
            }
        }
        // query params
        if ($source !== null) {
            if('form' === 'form' && is_array($source)) {
                foreach($source as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['source'] = $source;
            }
        }
        // query params
        if ($singlefile !== null) {
            if('form' === 'form' && is_array($singlefile)) {
                foreach($singlefile as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['singlefile'] = $singlefile;
            }
        }
        // query params
        if ($userid !== null) {
            if('form' === 'form' && is_array($userid)) {
                foreach($userid as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['userid'] = $userid;
            }
        }
        // query params
        if ($forsending !== null) {
            if('form' === 'form' && is_array($forsending)) {
                foreach($forsending as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['forsending'] = $forsending;
            }
        }
        // query params
        if ($role !== null) {
            if('form' === 'form' && is_array($role)) {
                foreach($role as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['role'] = $role;
            }
        }
        // query params
        if ($filters !== null) {
            if('form' === 'form' && is_array($filters)) {
                foreach($filters as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['filters'] = $filters;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Bearer (string) authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation templateGet
     *
     * View details of a template
     *
     * @param  string $id The id of the template to get. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function templateGet($id)
    {
        $this->templateGetWithHttpInfo($id);
    }

    /**
     * Operation templateGetWithHttpInfo
     *
     * View details of a template
     *
     * @param  string $id The id of the template to get. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function templateGetWithHttpInfo($id)
    {
        $request = $this->templateGetRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation templateGetAsync
     *
     * View details of a template
     *
     * @param  string $id The id of the template to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function templateGetAsync($id)
    {
        return $this->templateGetAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation templateGetAsyncWithHttpInfo
     *
     * View details of a template
     *
     * @param  string $id The id of the template to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function templateGetAsyncWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->templateGetRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'templateGet'
     *
     * @param  string $id The id of the template to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function templateGetRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling templateGet'
            );
        }

        $resourcePath = '/template/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Bearer (string) authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation templateGetgenerated
     *
     * View generated templates
     *
     * @param  string $jobid The id of the job that is creating the templates. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function templateGetgenerated($jobid)
    {
        $this->templateGetgeneratedWithHttpInfo($jobid);
    }

    /**
     * Operation templateGetgeneratedWithHttpInfo
     *
     * View generated templates
     *
     * @param  string $jobid The id of the job that is creating the templates. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function templateGetgeneratedWithHttpInfo($jobid)
    {
        $request = $this->templateGetgeneratedRequest($jobid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation templateGetgeneratedAsync
     *
     * View generated templates
     *
     * @param  string $jobid The id of the job that is creating the templates. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function templateGetgeneratedAsync($jobid)
    {
        return $this->templateGetgeneratedAsyncWithHttpInfo($jobid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation templateGetgeneratedAsyncWithHttpInfo
     *
     * View generated templates
     *
     * @param  string $jobid The id of the job that is creating the templates. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function templateGetgeneratedAsyncWithHttpInfo($jobid)
    {
        $returnType = '';
        $request = $this->templateGetgeneratedRequest($jobid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'templateGetgenerated'
     *
     * @param  string $jobid The id of the job that is creating the templates. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function templateGetgeneratedRequest($jobid)
    {
        // verify the required parameter 'jobid' is set
        if ($jobid === null || (is_array($jobid) && count($jobid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $jobid when calling templateGetgenerated'
            );
        }

        $resourcePath = '/template/getgenerated';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($jobid !== null) {
            if('form' === 'form' && is_array($jobid)) {
                foreach($jobid as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['jobid'] = $jobid;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Bearer (string) authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation templateList
     *
     * View a list of defined templates
     *
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $kind The kind of the templates to return. It must be included in (badge, certificate). (required)
     * @param  bool $designedonly If true then it only returns the templates that were designed. Otherwise, it returns all. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function templateList($from, $count, $kind, $designedonly = null)
    {
        $this->templateListWithHttpInfo($from, $count, $kind, $designedonly);
    }

    /**
     * Operation templateListWithHttpInfo
     *
     * View a list of defined templates
     *
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $kind The kind of the templates to return. It must be included in (badge, certificate). (required)
     * @param  bool $designedonly If true then it only returns the templates that were designed. Otherwise, it returns all. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function templateListWithHttpInfo($from, $count, $kind, $designedonly = null)
    {
        $request = $this->templateListRequest($from, $count, $kind, $designedonly);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation templateListAsync
     *
     * View a list of defined templates
     *
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $kind The kind of the templates to return. It must be included in (badge, certificate). (required)
     * @param  bool $designedonly If true then it only returns the templates that were designed. Otherwise, it returns all. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function templateListAsync($from, $count, $kind, $designedonly = null)
    {
        return $this->templateListAsyncWithHttpInfo($from, $count, $kind, $designedonly)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation templateListAsyncWithHttpInfo
     *
     * View a list of defined templates
     *
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $kind The kind of the templates to return. It must be included in (badge, certificate). (required)
     * @param  bool $designedonly If true then it only returns the templates that were designed. Otherwise, it returns all. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function templateListAsyncWithHttpInfo($from, $count, $kind, $designedonly = null)
    {
        $returnType = '';
        $request = $this->templateListRequest($from, $count, $kind, $designedonly);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'templateList'
     *
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $kind The kind of the templates to return. It must be included in (badge, certificate). (required)
     * @param  bool $designedonly If true then it only returns the templates that were designed. Otherwise, it returns all. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function templateListRequest($from, $count, $kind, $designedonly = null)
    {
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling templateList'
            );
        }
        // verify the required parameter 'count' is set
        if ($count === null || (is_array($count) && count($count) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $count when calling templateList'
            );
        }
        // verify the required parameter 'kind' is set
        if ($kind === null || (is_array($kind) && count($kind) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $kind when calling templateList'
            );
        }

        $resourcePath = '/template/list';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }
        // query params
        if ($count !== null) {
            if('form' === 'form' && is_array($count)) {
                foreach($count as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['count'] = $count;
            }
        }
        // query params
        if ($kind !== null) {
            if('form' === 'form' && is_array($kind)) {
                foreach($kind as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['kind'] = $kind;
            }
        }
        // query params
        if ($designedonly !== null) {
            if('form' === 'form' && is_array($designedonly)) {
                foreach($designedonly as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['designedonly'] = $designedonly;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Bearer (string) authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation templateListsources
     *
     * View a list of templates' data sources
     *
     * @param  string $kind The kind of the templates to return. It must be included in (badge, certificate). (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function templateListsources($kind)
    {
        $this->templateListsourcesWithHttpInfo($kind);
    }

    /**
     * Operation templateListsourcesWithHttpInfo
     *
     * View a list of templates' data sources
     *
     * @param  string $kind The kind of the templates to return. It must be included in (badge, certificate). (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function templateListsourcesWithHttpInfo($kind)
    {
        $request = $this->templateListsourcesRequest($kind);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation templateListsourcesAsync
     *
     * View a list of templates' data sources
     *
     * @param  string $kind The kind of the templates to return. It must be included in (badge, certificate). (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function templateListsourcesAsync($kind)
    {
        return $this->templateListsourcesAsyncWithHttpInfo($kind)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation templateListsourcesAsyncWithHttpInfo
     *
     * View a list of templates' data sources
     *
     * @param  string $kind The kind of the templates to return. It must be included in (badge, certificate). (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function templateListsourcesAsyncWithHttpInfo($kind)
    {
        $returnType = '';
        $request = $this->templateListsourcesRequest($kind);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'templateListsources'
     *
     * @param  string $kind The kind of the templates to return. It must be included in (badge, certificate). (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function templateListsourcesRequest($kind)
    {
        // verify the required parameter 'kind' is set
        if ($kind === null || (is_array($kind) && count($kind) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $kind when calling templateListsources'
            );
        }

        $resourcePath = '/template/listsources';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($kind !== null) {
            if('form' === 'form' && is_array($kind)) {
                foreach($kind as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['kind'] = $kind;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Bearer (string) authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation templateSave
     *
     * Create or edit a template
     *
     * @param  string $id The id of the template to save (leave empty to create a new one). (required)
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function templateSave($id, $unknown_base_type = null)
    {
        $this->templateSaveWithHttpInfo($id, $unknown_base_type);
    }

    /**
     * Operation templateSaveWithHttpInfo
     *
     * Create or edit a template
     *
     * @param  string $id The id of the template to save (leave empty to create a new one). (required)
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function templateSaveWithHttpInfo($id, $unknown_base_type = null)
    {
        $request = $this->templateSaveRequest($id, $unknown_base_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation templateSaveAsync
     *
     * Create or edit a template
     *
     * @param  string $id The id of the template to save (leave empty to create a new one). (required)
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function templateSaveAsync($id, $unknown_base_type = null)
    {
        return $this->templateSaveAsyncWithHttpInfo($id, $unknown_base_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation templateSaveAsyncWithHttpInfo
     *
     * Create or edit a template
     *
     * @param  string $id The id of the template to save (leave empty to create a new one). (required)
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function templateSaveAsyncWithHttpInfo($id, $unknown_base_type = null)
    {
        $returnType = '';
        $request = $this->templateSaveRequest($id, $unknown_base_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'templateSave'
     *
     * @param  string $id The id of the template to save (leave empty to create a new one). (required)
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function templateSaveRequest($id, $unknown_base_type = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling templateSave'
            );
        }

        $resourcePath = '/template/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($unknown_base_type)) {
            $_tempBody = $unknown_base_type;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Bearer (string) authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation templateSavelayout
     *
     * Save the layout of a template
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function templateSavelayout($unknown_base_type = null)
    {
        $this->templateSavelayoutWithHttpInfo($unknown_base_type);
    }

    /**
     * Operation templateSavelayoutWithHttpInfo
     *
     * Save the layout of a template
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function templateSavelayoutWithHttpInfo($unknown_base_type = null)
    {
        $request = $this->templateSavelayoutRequest($unknown_base_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation templateSavelayoutAsync
     *
     * Save the layout of a template
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function templateSavelayoutAsync($unknown_base_type = null)
    {
        return $this->templateSavelayoutAsyncWithHttpInfo($unknown_base_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation templateSavelayoutAsyncWithHttpInfo
     *
     * Save the layout of a template
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function templateSavelayoutAsyncWithHttpInfo($unknown_base_type = null)
    {
        $returnType = '';
        $request = $this->templateSavelayoutRequest($unknown_base_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'templateSavelayout'
     *
     * @param  \OpenAPI\Client\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function templateSavelayoutRequest($unknown_base_type = null)
    {

        $resourcePath = '/template/savelayout';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($unknown_base_type)) {
            $_tempBody = $unknown_base_type;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Bearer (string) authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
