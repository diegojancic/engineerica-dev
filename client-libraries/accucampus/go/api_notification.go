/*
 * AccuCampus OpenAPI 3
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ _context.Context
)

// NotificationApiService NotificationApi service
type NotificationApiService service

// NotificationDeleteOpts Optional parameters for the method 'NotificationDelete'
type NotificationDeleteOpts struct {
    Body optional.Interface{}
}

/*
NotificationDelete Delete a notification
Allows the user to delete an existing notification.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of the notification to delete.
 * @param optional nil or *NotificationDeleteOpts - Optional Parameters:
 * @param "Body" (optional.Interface{}) - 
*/
func (a *NotificationApiService) NotificationDelete(ctx _context.Context, id string, localVarOptionals *NotificationDeleteOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/notification/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.QueryEscape(parameterToString(id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		localVarPostBody = localVarOptionals.Body.Value()
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

/*
NotificationGet View a notification
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The id of the notification to get.
*/
func (a *NotificationApiService) NotificationGet(ctx _context.Context, id string) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/notification/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.QueryEscape(parameterToString(id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

/*
NotificationGetforstation Gets all public (in station) notifications for the specific user
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param station The id of the sign-in station to get.
 * @param user The card of the user.
*/
func (a *NotificationApiService) NotificationGetforstation(ctx _context.Context, station string, user string) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/notification/getforstation"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("station", parameterToString(station, ""))
	localVarQueryParams.Add("user", parameterToString(user, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

/*
NotificationGetunreadcount Get the number of unread notifications
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
*/
func (a *NotificationApiService) NotificationGetunreadcount(ctx _context.Context) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/notification/getunreadcount"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// NotificationListOpts Optional parameters for the method 'NotificationList'
type NotificationListOpts struct {
    Recipient optional.Interface
    Status optional.Int32
    Startdate optional.Time
    Enddate optional.Time
    Sentonscreen optional.Bool
    Sentemail optional.Bool
    Sentsms optional.Bool
}

/*
NotificationList View a list of all sent notifications
Allows the user to view the list of all sent notifications.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param from The first record to return.
 * @param count The max number of records to return.
 * @param optional nil or *NotificationListOpts - Optional Parameters:
 * @param "Recipient" (optional.Interface of string) -  The recipient whose notifications have to be listed.
 * @param "Status" (optional.Int32) -  The status of the notifications to list. Read, Unread or All.
 * @param "Startdate" (optional.Time) -  The start date of the period to filter the notifications.
 * @param "Enddate" (optional.Time) -  The end date of the period to filter the notifications.
 * @param "Sentonscreen" (optional.Bool) -  Specifies whether to list the notifications that were sent on-screen or not.
 * @param "Sentemail" (optional.Bool) -  Specifies whether to list the notifications that were sent via e-mail or not.
 * @param "Sentsms" (optional.Bool) -  Specifies whether to list the notifications that were sent via sms or not.
*/
func (a *NotificationApiService) NotificationList(ctx _context.Context, from int32, count int32, localVarOptionals *NotificationListOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/notification/list"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("from", parameterToString(from, ""))
	localVarQueryParams.Add("count", parameterToString(count, ""))
	if localVarOptionals != nil && localVarOptionals.Recipient.IsSet() {
		localVarQueryParams.Add("recipient", parameterToString(localVarOptionals.Recipient.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Status.IsSet() {
		localVarQueryParams.Add("status", parameterToString(localVarOptionals.Status.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Startdate.IsSet() {
		localVarQueryParams.Add("startdate", parameterToString(localVarOptionals.Startdate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Enddate.IsSet() {
		localVarQueryParams.Add("enddate", parameterToString(localVarOptionals.Enddate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sentonscreen.IsSet() {
		localVarQueryParams.Add("sentonscreen", parameterToString(localVarOptionals.Sentonscreen.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sentemail.IsSet() {
		localVarQueryParams.Add("sentemail", parameterToString(localVarOptionals.Sentemail.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sentsms.IsSet() {
		localVarQueryParams.Add("sentsms", parameterToString(localVarOptionals.Sentsms.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// NotificationListmineOpts Optional parameters for the method 'NotificationListmine'
type NotificationListmineOpts struct {
    Status optional.Int32
    Startdate optional.Time
    Enddate optional.Time
}

/*
NotificationListmine View all the notifications sent to the current user
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param from The first record to return.
 * @param count The max number of records to return.
 * @param optional nil or *NotificationListmineOpts - Optional Parameters:
 * @param "Status" (optional.Int32) -  Specifies the status of the notifications to list. Read, Unread or All.
 * @param "Startdate" (optional.Time) -  The start date of the period to filter the notifications.
 * @param "Enddate" (optional.Time) -  The end date of the period to filter the notifications.
*/
func (a *NotificationApiService) NotificationListmine(ctx _context.Context, from int32, count int32, localVarOptionals *NotificationListmineOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/notification/listmine"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("from", parameterToString(from, ""))
	localVarQueryParams.Add("count", parameterToString(count, ""))
	if localVarOptionals != nil && localVarOptionals.Status.IsSet() {
		localVarQueryParams.Add("status", parameterToString(localVarOptionals.Status.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Startdate.IsSet() {
		localVarQueryParams.Add("startdate", parameterToString(localVarOptionals.Startdate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Enddate.IsSet() {
		localVarQueryParams.Add("enddate", parameterToString(localVarOptionals.Enddate.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// NotificationMarkasreadOpts Optional parameters for the method 'NotificationMarkasread'
type NotificationMarkasreadOpts struct {
    Id optional.Interface
    Status optional.Int32
    Startdate optional.Time
    Enddate optional.Time
}

/*
NotificationMarkasread Mark a notification as read
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *NotificationMarkasreadOpts - Optional Parameters:
 * @param "Id" (optional.Interface of string) -  The id of the notification to mark as read. If not specified all notifications of the logged user will be marked as read.
 * @param "Status" (optional.Int32) -  Specifies the status to filter the notifications. Read, Unread or All.
 * @param "Startdate" (optional.Time) -  The start date of the period to filter the notifications.
 * @param "Enddate" (optional.Time) -  The end date of the period to filter the notifications.
*/
func (a *NotificationApiService) NotificationMarkasread(ctx _context.Context, localVarOptionals *NotificationMarkasreadOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/notification/markasread"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Status.IsSet() {
		localVarQueryParams.Add("status", parameterToString(localVarOptionals.Status.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Startdate.IsSet() {
		localVarQueryParams.Add("startdate", parameterToString(localVarOptionals.Startdate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Enddate.IsSet() {
		localVarQueryParams.Add("enddate", parameterToString(localVarOptionals.Enddate.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// NotificationMarkasunreadOpts Optional parameters for the method 'NotificationMarkasunread'
type NotificationMarkasunreadOpts struct {
    Id optional.Interface
    Status optional.Int32
    Startdate optional.Time
    Enddate optional.Time
}

/*
NotificationMarkasunread Mark a notification as unread
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *NotificationMarkasunreadOpts - Optional Parameters:
 * @param "Id" (optional.Interface of string) -  The id of the notification to mark as unread. If not specified all notifications of the logged user will be marked as unread.
 * @param "Status" (optional.Int32) -  Specifies the status to filter the notifications. Read, Unread or All.
 * @param "Startdate" (optional.Time) -  The start date of the period to filter the notifications.
 * @param "Enddate" (optional.Time) -  The end date of the period to filter the notifications.
*/
func (a *NotificationApiService) NotificationMarkasunread(ctx _context.Context, localVarOptionals *NotificationMarkasunreadOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/notification/markasunread"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Status.IsSet() {
		localVarQueryParams.Add("status", parameterToString(localVarOptionals.Status.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Startdate.IsSet() {
		localVarQueryParams.Add("startdate", parameterToString(localVarOptionals.Startdate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Enddate.IsSet() {
		localVarQueryParams.Add("enddate", parameterToString(localVarOptionals.Enddate.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// NotificationSendOpts Optional parameters for the method 'NotificationSend'
type NotificationSendOpts struct {
    Tousers optional.String
    Togroups optional.String
    Onscreenbody optional.String
    Onscreenclick optional.String
    Onscreenurl optional.String
    Onscreenclass optional.String
    Onscreenduration optional.Int32
    Showonstation optional.Int32
    Emailfromname optional.String
    Emailfrom optional.String
    Emailsubject optional.String
    Emailbody optional.String
    Textmessagebody optional.String
}

/*
NotificationSend Send notifications on screen, via email or text to users
Allows the user to send notifications to other users through the Send Message link.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param emailenabled Whether send the notification via email.
 * @param onscreenenabled Whether to display the notification on screen.
 * @param smsenabled Whether to send the notification via text message.
 * @param title Notification title.
 * @param optional nil or *NotificationSendOpts - Optional Parameters:
 * @param "Tousers" (optional.String) -  Comma-separated Ids of users to send the notification.
 * @param "Togroups" (optional.String) -  Comma-separated Ids of user groups to send the notification.
 * @param "Onscreenbody" (optional.String) -  Body of the message for on-screen display.
 * @param "Onscreenclick" (optional.String) -  What to do when the notification is clicked. Valid values: hide, view, url.
 * @param "Onscreenurl" (optional.String) -  Url to redirect the user, if onscreenclick=url.
 * @param "Onscreenclass" (optional.String) -  How to display the notification. Valid values: info, success, warning, error
 * @param "Onscreenduration" (optional.Int32) -  Time in seconds to display the notification.
 * @param "Showonstation" (optional.Int32) -  Whether to show the notification in the sign-in station.
 * @param "Emailfromname" (optional.String) -  Name of the email sender.
 * @param "Emailfrom" (optional.String) -  Reply-to email.
 * @param "Emailsubject" (optional.String) -  Subject of the email.
 * @param "Emailbody" (optional.String) -  Body of the email.
 * @param "Textmessagebody" (optional.String) -  Message for SMS. Max 160 characters.
*/
func (a *NotificationApiService) NotificationSend(ctx _context.Context, emailenabled bool, onscreenenabled bool, smsenabled bool, title string, localVarOptionals *NotificationSendOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/notification/send"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Tousers.IsSet() {
		localVarQueryParams.Add("tousers", parameterToString(localVarOptionals.Tousers.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Togroups.IsSet() {
		localVarQueryParams.Add("togroups", parameterToString(localVarOptionals.Togroups.Value(), ""))
	}
	localVarQueryParams.Add("emailenabled", parameterToString(emailenabled, ""))
	localVarQueryParams.Add("onscreenenabled", parameterToString(onscreenenabled, ""))
	localVarQueryParams.Add("smsenabled", parameterToString(smsenabled, ""))
	localVarQueryParams.Add("title", parameterToString(title, ""))
	if localVarOptionals != nil && localVarOptionals.Onscreenbody.IsSet() {
		localVarQueryParams.Add("onscreenbody", parameterToString(localVarOptionals.Onscreenbody.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Onscreenclick.IsSet() {
		localVarQueryParams.Add("onscreenclick", parameterToString(localVarOptionals.Onscreenclick.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Onscreenurl.IsSet() {
		localVarQueryParams.Add("onscreenurl", parameterToString(localVarOptionals.Onscreenurl.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Onscreenclass.IsSet() {
		localVarQueryParams.Add("onscreenclass", parameterToString(localVarOptionals.Onscreenclass.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Onscreenduration.IsSet() {
		localVarQueryParams.Add("onscreenduration", parameterToString(localVarOptionals.Onscreenduration.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Showonstation.IsSet() {
		localVarQueryParams.Add("showonstation", parameterToString(localVarOptionals.Showonstation.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Emailfromname.IsSet() {
		localVarQueryParams.Add("emailfromname", parameterToString(localVarOptionals.Emailfromname.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Emailfrom.IsSet() {
		localVarQueryParams.Add("emailfrom", parameterToString(localVarOptionals.Emailfrom.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Emailsubject.IsSet() {
		localVarQueryParams.Add("emailsubject", parameterToString(localVarOptionals.Emailsubject.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Emailbody.IsSet() {
		localVarQueryParams.Add("emailbody", parameterToString(localVarOptionals.Emailbody.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Textmessagebody.IsSet() {
		localVarQueryParams.Add("textmessagebody", parameterToString(localVarOptionals.Textmessagebody.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

/*
NotificationSendonscreen Send on-screen notifications
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param notification The ID of the notification to send.
*/
func (a *NotificationApiService) NotificationSendonscreen(ctx _context.Context, notification string) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/notification/sendonscreen"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("notification", parameterToString(notification, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
