<?php
/**
 * RatingApi
 * PHP version 5
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * AccuCampus OpenAPI 3
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 4.3.1
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * RatingApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class RatingApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $host_index (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $host_index = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $host_index;
    }

    /**
     * Set the host index
     *
     * @param  int Host index (required)
     */
    public function setHostIndex($host_index)
    {
        $this->hostIndex = $host_index;
    }

    /**
     * Get the host index
     *
     * @return Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation ratingFlag
     *
     * Flags one rating for moderation
     *
     * @param  string $id The rating to flag. (required)
     * @param  string $comment Comment why should this should be removed. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function ratingFlag($id, $comment = null)
    {
        $this->ratingFlagWithHttpInfo($id, $comment);
    }

    /**
     * Operation ratingFlagWithHttpInfo
     *
     * Flags one rating for moderation
     *
     * @param  string $id The rating to flag. (required)
     * @param  string $comment Comment why should this should be removed. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function ratingFlagWithHttpInfo($id, $comment = null)
    {
        $request = $this->ratingFlagRequest($id, $comment);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation ratingFlagAsync
     *
     * Flags one rating for moderation
     *
     * @param  string $id The rating to flag. (required)
     * @param  string $comment Comment why should this should be removed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ratingFlagAsync($id, $comment = null)
    {
        return $this->ratingFlagAsyncWithHttpInfo($id, $comment)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ratingFlagAsyncWithHttpInfo
     *
     * Flags one rating for moderation
     *
     * @param  string $id The rating to flag. (required)
     * @param  string $comment Comment why should this should be removed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ratingFlagAsyncWithHttpInfo($id, $comment = null)
    {
        $returnType = '';
        $request = $this->ratingFlagRequest($id, $comment);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ratingFlag'
     *
     * @param  string $id The rating to flag. (required)
     * @param  string $comment Comment why should this should be removed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function ratingFlagRequest($id, $comment = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ratingFlag'
            );
        }

        $resourcePath = '/rating/flag';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($id !== null) {
            if('form' === 'form' && is_array($id)) {
                foreach($id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['id'] = $id;
            }
        }
        // query params
        if ($comment !== null) {
            if('form' === 'form' && is_array($comment)) {
                foreach($comment as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['comment'] = $comment;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Bearer (string) authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ratingFlagcomment
     *
     * Flags one comment for moderation
     *
     * @param  string $id The comment to flag. (required)
     * @param  string $comment Comment why should this should be removed. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function ratingFlagcomment($id, $comment = null)
    {
        $this->ratingFlagcommentWithHttpInfo($id, $comment);
    }

    /**
     * Operation ratingFlagcommentWithHttpInfo
     *
     * Flags one comment for moderation
     *
     * @param  string $id The comment to flag. (required)
     * @param  string $comment Comment why should this should be removed. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function ratingFlagcommentWithHttpInfo($id, $comment = null)
    {
        $request = $this->ratingFlagcommentRequest($id, $comment);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation ratingFlagcommentAsync
     *
     * Flags one comment for moderation
     *
     * @param  string $id The comment to flag. (required)
     * @param  string $comment Comment why should this should be removed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ratingFlagcommentAsync($id, $comment = null)
    {
        return $this->ratingFlagcommentAsyncWithHttpInfo($id, $comment)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ratingFlagcommentAsyncWithHttpInfo
     *
     * Flags one comment for moderation
     *
     * @param  string $id The comment to flag. (required)
     * @param  string $comment Comment why should this should be removed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ratingFlagcommentAsyncWithHttpInfo($id, $comment = null)
    {
        $returnType = '';
        $request = $this->ratingFlagcommentRequest($id, $comment);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ratingFlagcomment'
     *
     * @param  string $id The comment to flag. (required)
     * @param  string $comment Comment why should this should be removed. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function ratingFlagcommentRequest($id, $comment = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ratingFlagcomment'
            );
        }

        $resourcePath = '/rating/flagcomment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($id !== null) {
            if('form' === 'form' && is_array($id)) {
                foreach($id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['id'] = $id;
            }
        }
        // query params
        if ($comment !== null) {
            if('form' === 'form' && is_array($comment)) {
                foreach($comment as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['comment'] = $comment;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Bearer (string) authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ratingGet
     *
     * Get rating for one or more entities
     *
     * @param  string $type The entity type to get the rating. (required)
     * @param  string $entityids List of ids to get the ratings. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function ratingGet($type, $entityids)
    {
        $this->ratingGetWithHttpInfo($type, $entityids);
    }

    /**
     * Operation ratingGetWithHttpInfo
     *
     * Get rating for one or more entities
     *
     * @param  string $type The entity type to get the rating. (required)
     * @param  string $entityids List of ids to get the ratings. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function ratingGetWithHttpInfo($type, $entityids)
    {
        $request = $this->ratingGetRequest($type, $entityids);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation ratingGetAsync
     *
     * Get rating for one or more entities
     *
     * @param  string $type The entity type to get the rating. (required)
     * @param  string $entityids List of ids to get the ratings. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ratingGetAsync($type, $entityids)
    {
        return $this->ratingGetAsyncWithHttpInfo($type, $entityids)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ratingGetAsyncWithHttpInfo
     *
     * Get rating for one or more entities
     *
     * @param  string $type The entity type to get the rating. (required)
     * @param  string $entityids List of ids to get the ratings. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ratingGetAsyncWithHttpInfo($type, $entityids)
    {
        $returnType = '';
        $request = $this->ratingGetRequest($type, $entityids);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ratingGet'
     *
     * @param  string $type The entity type to get the rating. (required)
     * @param  string $entityids List of ids to get the ratings. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function ratingGetRequest($type, $entityids)
    {
        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling ratingGet'
            );
        }
        // verify the required parameter 'entityids' is set
        if ($entityids === null || (is_array($entityids) && count($entityids) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $entityids when calling ratingGet'
            );
        }

        $resourcePath = '/rating/get';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($type !== null) {
            if('form' === 'form' && is_array($type)) {
                foreach($type as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['type'] = $type;
            }
        }
        // query params
        if ($entityids !== null) {
            if('form' === 'form' && is_array($entityids)) {
                foreach($entityids as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['entityids'] = $entityids;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Bearer (string) authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ratingGetall
     *
     * Gets the full ratings and comments for a specific entity
     *
     * @param  string $type The entity type to get the rating. (required)
     * @param  string $entityid Id of the entity to get the ratings. (required)
     * @param  bool $mostrecentfirst True to show most recent first, otherwise most helpful first. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function ratingGetall($type, $entityid, $mostrecentfirst = null)
    {
        $this->ratingGetallWithHttpInfo($type, $entityid, $mostrecentfirst);
    }

    /**
     * Operation ratingGetallWithHttpInfo
     *
     * Gets the full ratings and comments for a specific entity
     *
     * @param  string $type The entity type to get the rating. (required)
     * @param  string $entityid Id of the entity to get the ratings. (required)
     * @param  bool $mostrecentfirst True to show most recent first, otherwise most helpful first. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function ratingGetallWithHttpInfo($type, $entityid, $mostrecentfirst = null)
    {
        $request = $this->ratingGetallRequest($type, $entityid, $mostrecentfirst);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation ratingGetallAsync
     *
     * Gets the full ratings and comments for a specific entity
     *
     * @param  string $type The entity type to get the rating. (required)
     * @param  string $entityid Id of the entity to get the ratings. (required)
     * @param  bool $mostrecentfirst True to show most recent first, otherwise most helpful first. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ratingGetallAsync($type, $entityid, $mostrecentfirst = null)
    {
        return $this->ratingGetallAsyncWithHttpInfo($type, $entityid, $mostrecentfirst)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ratingGetallAsyncWithHttpInfo
     *
     * Gets the full ratings and comments for a specific entity
     *
     * @param  string $type The entity type to get the rating. (required)
     * @param  string $entityid Id of the entity to get the ratings. (required)
     * @param  bool $mostrecentfirst True to show most recent first, otherwise most helpful first. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ratingGetallAsyncWithHttpInfo($type, $entityid, $mostrecentfirst = null)
    {
        $returnType = '';
        $request = $this->ratingGetallRequest($type, $entityid, $mostrecentfirst);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ratingGetall'
     *
     * @param  string $type The entity type to get the rating. (required)
     * @param  string $entityid Id of the entity to get the ratings. (required)
     * @param  bool $mostrecentfirst True to show most recent first, otherwise most helpful first. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function ratingGetallRequest($type, $entityid, $mostrecentfirst = null)
    {
        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling ratingGetall'
            );
        }
        // verify the required parameter 'entityid' is set
        if ($entityid === null || (is_array($entityid) && count($entityid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $entityid when calling ratingGetall'
            );
        }

        $resourcePath = '/rating/getall';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($type !== null) {
            if('form' === 'form' && is_array($type)) {
                foreach($type as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['type'] = $type;
            }
        }
        // query params
        if ($entityid !== null) {
            if('form' === 'form' && is_array($entityid)) {
                foreach($entityid as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['entityid'] = $entityid;
            }
        }
        // query params
        if ($mostrecentfirst !== null) {
            if('form' === 'form' && is_array($mostrecentfirst)) {
                foreach($mostrecentfirst as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['mostrecentfirst'] = $mostrecentfirst;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Bearer (string) authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ratingGetcomments
     *
     * Gets all the comments for a rating
     *
     * @param  string $ratingid The ID of the rating to get all comments. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function ratingGetcomments($ratingid)
    {
        $this->ratingGetcommentsWithHttpInfo($ratingid);
    }

    /**
     * Operation ratingGetcommentsWithHttpInfo
     *
     * Gets all the comments for a rating
     *
     * @param  string $ratingid The ID of the rating to get all comments. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function ratingGetcommentsWithHttpInfo($ratingid)
    {
        $request = $this->ratingGetcommentsRequest($ratingid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation ratingGetcommentsAsync
     *
     * Gets all the comments for a rating
     *
     * @param  string $ratingid The ID of the rating to get all comments. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ratingGetcommentsAsync($ratingid)
    {
        return $this->ratingGetcommentsAsyncWithHttpInfo($ratingid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ratingGetcommentsAsyncWithHttpInfo
     *
     * Gets all the comments for a rating
     *
     * @param  string $ratingid The ID of the rating to get all comments. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ratingGetcommentsAsyncWithHttpInfo($ratingid)
    {
        $returnType = '';
        $request = $this->ratingGetcommentsRequest($ratingid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ratingGetcomments'
     *
     * @param  string $ratingid The ID of the rating to get all comments. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function ratingGetcommentsRequest($ratingid)
    {
        // verify the required parameter 'ratingid' is set
        if ($ratingid === null || (is_array($ratingid) && count($ratingid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ratingid when calling ratingGetcomments'
            );
        }

        $resourcePath = '/rating/getcomments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($ratingid !== null) {
            if('form' === 'form' && is_array($ratingid)) {
                foreach($ratingid as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['ratingid'] = $ratingid;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Bearer (string) authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ratingGetpending
     *
     * Gets info of pre-saved and pre-approved ratings
     *
     * @param  string $getgroup The ID of the group of pending ratings to get. (required)
     * @param  string $rateid Rate this before returning. (optional)
     * @param  int $rateval The value used to rate the item specified in rateid. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function ratingGetpending($getgroup, $rateid = null, $rateval = null)
    {
        $this->ratingGetpendingWithHttpInfo($getgroup, $rateid, $rateval);
    }

    /**
     * Operation ratingGetpendingWithHttpInfo
     *
     * Gets info of pre-saved and pre-approved ratings
     *
     * @param  string $getgroup The ID of the group of pending ratings to get. (required)
     * @param  string $rateid Rate this before returning. (optional)
     * @param  int $rateval The value used to rate the item specified in rateid. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function ratingGetpendingWithHttpInfo($getgroup, $rateid = null, $rateval = null)
    {
        $request = $this->ratingGetpendingRequest($getgroup, $rateid, $rateval);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation ratingGetpendingAsync
     *
     * Gets info of pre-saved and pre-approved ratings
     *
     * @param  string $getgroup The ID of the group of pending ratings to get. (required)
     * @param  string $rateid Rate this before returning. (optional)
     * @param  int $rateval The value used to rate the item specified in rateid. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ratingGetpendingAsync($getgroup, $rateid = null, $rateval = null)
    {
        return $this->ratingGetpendingAsyncWithHttpInfo($getgroup, $rateid, $rateval)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ratingGetpendingAsyncWithHttpInfo
     *
     * Gets info of pre-saved and pre-approved ratings
     *
     * @param  string $getgroup The ID of the group of pending ratings to get. (required)
     * @param  string $rateid Rate this before returning. (optional)
     * @param  int $rateval The value used to rate the item specified in rateid. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ratingGetpendingAsyncWithHttpInfo($getgroup, $rateid = null, $rateval = null)
    {
        $returnType = '';
        $request = $this->ratingGetpendingRequest($getgroup, $rateid, $rateval);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ratingGetpending'
     *
     * @param  string $getgroup The ID of the group of pending ratings to get. (required)
     * @param  string $rateid Rate this before returning. (optional)
     * @param  int $rateval The value used to rate the item specified in rateid. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function ratingGetpendingRequest($getgroup, $rateid = null, $rateval = null)
    {
        // verify the required parameter 'getgroup' is set
        if ($getgroup === null || (is_array($getgroup) && count($getgroup) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $getgroup when calling ratingGetpending'
            );
        }

        $resourcePath = '/rating/getpending';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($getgroup !== null) {
            if('form' === 'form' && is_array($getgroup)) {
                foreach($getgroup as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['getgroup'] = $getgroup;
            }
        }
        // query params
        if ($rateid !== null) {
            if('form' === 'form' && is_array($rateid)) {
                foreach($rateid as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['rateid'] = $rateid;
            }
        }
        // query params
        if ($rateval !== null) {
            if('form' === 'form' && is_array($rateval)) {
                foreach($rateval as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['rateval'] = $rateval;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ratingGetpendingmoderation
     *
     * Shows a list of the ratings and comments that are pending for moderation
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function ratingGetpendingmoderation()
    {
        $this->ratingGetpendingmoderationWithHttpInfo();
    }

    /**
     * Operation ratingGetpendingmoderationWithHttpInfo
     *
     * Shows a list of the ratings and comments that are pending for moderation
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function ratingGetpendingmoderationWithHttpInfo()
    {
        $request = $this->ratingGetpendingmoderationRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation ratingGetpendingmoderationAsync
     *
     * Shows a list of the ratings and comments that are pending for moderation
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ratingGetpendingmoderationAsync()
    {
        return $this->ratingGetpendingmoderationAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ratingGetpendingmoderationAsyncWithHttpInfo
     *
     * Shows a list of the ratings and comments that are pending for moderation
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ratingGetpendingmoderationAsyncWithHttpInfo()
    {
        $returnType = '';
        $request = $this->ratingGetpendingmoderationRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ratingGetpendingmoderation'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function ratingGetpendingmoderationRequest()
    {

        $resourcePath = '/rating/getpendingmoderation';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Bearer (string) authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ratingModerate
     *
     * Allows the user to accept or reject a comment
     *
     * @param  string $type Either &#39;rating&#39; or &#39;comment&#39; depending on what you want to moderate. (required)
     * @param  string $id Id of the rating or comment, as specified in type. (required)
     * @param  bool $approve True to approve, false to reject. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function ratingModerate($type, $id, $approve)
    {
        $this->ratingModerateWithHttpInfo($type, $id, $approve);
    }

    /**
     * Operation ratingModerateWithHttpInfo
     *
     * Allows the user to accept or reject a comment
     *
     * @param  string $type Either &#39;rating&#39; or &#39;comment&#39; depending on what you want to moderate. (required)
     * @param  string $id Id of the rating or comment, as specified in type. (required)
     * @param  bool $approve True to approve, false to reject. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function ratingModerateWithHttpInfo($type, $id, $approve)
    {
        $request = $this->ratingModerateRequest($type, $id, $approve);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation ratingModerateAsync
     *
     * Allows the user to accept or reject a comment
     *
     * @param  string $type Either &#39;rating&#39; or &#39;comment&#39; depending on what you want to moderate. (required)
     * @param  string $id Id of the rating or comment, as specified in type. (required)
     * @param  bool $approve True to approve, false to reject. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ratingModerateAsync($type, $id, $approve)
    {
        return $this->ratingModerateAsyncWithHttpInfo($type, $id, $approve)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ratingModerateAsyncWithHttpInfo
     *
     * Allows the user to accept or reject a comment
     *
     * @param  string $type Either &#39;rating&#39; or &#39;comment&#39; depending on what you want to moderate. (required)
     * @param  string $id Id of the rating or comment, as specified in type. (required)
     * @param  bool $approve True to approve, false to reject. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ratingModerateAsyncWithHttpInfo($type, $id, $approve)
    {
        $returnType = '';
        $request = $this->ratingModerateRequest($type, $id, $approve);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ratingModerate'
     *
     * @param  string $type Either &#39;rating&#39; or &#39;comment&#39; depending on what you want to moderate. (required)
     * @param  string $id Id of the rating or comment, as specified in type. (required)
     * @param  bool $approve True to approve, false to reject. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function ratingModerateRequest($type, $id, $approve)
    {
        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling ratingModerate'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ratingModerate'
            );
        }
        // verify the required parameter 'approve' is set
        if ($approve === null || (is_array($approve) && count($approve) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $approve when calling ratingModerate'
            );
        }

        $resourcePath = '/rating/moderate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($type !== null) {
            if('form' === 'form' && is_array($type)) {
                foreach($type as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['type'] = $type;
            }
        }
        // query params
        if ($id !== null) {
            if('form' === 'form' && is_array($id)) {
                foreach($id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['id'] = $id;
            }
        }
        // query params
        if ($approve !== null) {
            if('form' === 'form' && is_array($approve)) {
                foreach($approve as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['approve'] = $approve;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Bearer (string) authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ratingPostcomment
     *
     * Posts a comments for in a rating
     *
     * @param  string $ratingid The ID of the rating to post the comment. (required)
     * @param  string $comment Text of the comment to post. (required)
     * @param  bool $annonymous True to post the comment annonymously. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function ratingPostcomment($ratingid, $comment, $annonymous)
    {
        $this->ratingPostcommentWithHttpInfo($ratingid, $comment, $annonymous);
    }

    /**
     * Operation ratingPostcommentWithHttpInfo
     *
     * Posts a comments for in a rating
     *
     * @param  string $ratingid The ID of the rating to post the comment. (required)
     * @param  string $comment Text of the comment to post. (required)
     * @param  bool $annonymous True to post the comment annonymously. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function ratingPostcommentWithHttpInfo($ratingid, $comment, $annonymous)
    {
        $request = $this->ratingPostcommentRequest($ratingid, $comment, $annonymous);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation ratingPostcommentAsync
     *
     * Posts a comments for in a rating
     *
     * @param  string $ratingid The ID of the rating to post the comment. (required)
     * @param  string $comment Text of the comment to post. (required)
     * @param  bool $annonymous True to post the comment annonymously. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ratingPostcommentAsync($ratingid, $comment, $annonymous)
    {
        return $this->ratingPostcommentAsyncWithHttpInfo($ratingid, $comment, $annonymous)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ratingPostcommentAsyncWithHttpInfo
     *
     * Posts a comments for in a rating
     *
     * @param  string $ratingid The ID of the rating to post the comment. (required)
     * @param  string $comment Text of the comment to post. (required)
     * @param  bool $annonymous True to post the comment annonymously. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ratingPostcommentAsyncWithHttpInfo($ratingid, $comment, $annonymous)
    {
        $returnType = '';
        $request = $this->ratingPostcommentRequest($ratingid, $comment, $annonymous);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ratingPostcomment'
     *
     * @param  string $ratingid The ID of the rating to post the comment. (required)
     * @param  string $comment Text of the comment to post. (required)
     * @param  bool $annonymous True to post the comment annonymously. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function ratingPostcommentRequest($ratingid, $comment, $annonymous)
    {
        // verify the required parameter 'ratingid' is set
        if ($ratingid === null || (is_array($ratingid) && count($ratingid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ratingid when calling ratingPostcomment'
            );
        }
        // verify the required parameter 'comment' is set
        if ($comment === null || (is_array($comment) && count($comment) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $comment when calling ratingPostcomment'
            );
        }
        // verify the required parameter 'annonymous' is set
        if ($annonymous === null || (is_array($annonymous) && count($annonymous) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annonymous when calling ratingPostcomment'
            );
        }

        $resourcePath = '/rating/postcomment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($ratingid !== null) {
            if('form' === 'form' && is_array($ratingid)) {
                foreach($ratingid as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['ratingid'] = $ratingid;
            }
        }
        // query params
        if ($comment !== null) {
            if('form' === 'form' && is_array($comment)) {
                foreach($comment as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['comment'] = $comment;
            }
        }
        // query params
        if ($annonymous !== null) {
            if('form' === 'form' && is_array($annonymous)) {
                foreach($annonymous as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['annonymous'] = $annonymous;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Bearer (string) authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ratingRate
     *
     * Rates one entity
     *
     * @param  string $type The entity type to rate. (required)
     * @param  string $entityid Id of the entity to rate. (required)
     * @param  bool $annonymous Whether to post as annonymous. (required)
     * @param  int $value Value from 0 to 100 with the rating. (optional)
     * @param  string $comment Comment associated with this review. Comment can be updated later on another request too. (optional)
     * @param  bool $updatecomment Whether to update the comments. Defaults to true. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function ratingRate($type, $entityid, $annonymous, $value = null, $comment = null, $updatecomment = null)
    {
        $this->ratingRateWithHttpInfo($type, $entityid, $annonymous, $value, $comment, $updatecomment);
    }

    /**
     * Operation ratingRateWithHttpInfo
     *
     * Rates one entity
     *
     * @param  string $type The entity type to rate. (required)
     * @param  string $entityid Id of the entity to rate. (required)
     * @param  bool $annonymous Whether to post as annonymous. (required)
     * @param  int $value Value from 0 to 100 with the rating. (optional)
     * @param  string $comment Comment associated with this review. Comment can be updated later on another request too. (optional)
     * @param  bool $updatecomment Whether to update the comments. Defaults to true. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function ratingRateWithHttpInfo($type, $entityid, $annonymous, $value = null, $comment = null, $updatecomment = null)
    {
        $request = $this->ratingRateRequest($type, $entityid, $annonymous, $value, $comment, $updatecomment);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation ratingRateAsync
     *
     * Rates one entity
     *
     * @param  string $type The entity type to rate. (required)
     * @param  string $entityid Id of the entity to rate. (required)
     * @param  bool $annonymous Whether to post as annonymous. (required)
     * @param  int $value Value from 0 to 100 with the rating. (optional)
     * @param  string $comment Comment associated with this review. Comment can be updated later on another request too. (optional)
     * @param  bool $updatecomment Whether to update the comments. Defaults to true. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ratingRateAsync($type, $entityid, $annonymous, $value = null, $comment = null, $updatecomment = null)
    {
        return $this->ratingRateAsyncWithHttpInfo($type, $entityid, $annonymous, $value, $comment, $updatecomment)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ratingRateAsyncWithHttpInfo
     *
     * Rates one entity
     *
     * @param  string $type The entity type to rate. (required)
     * @param  string $entityid Id of the entity to rate. (required)
     * @param  bool $annonymous Whether to post as annonymous. (required)
     * @param  int $value Value from 0 to 100 with the rating. (optional)
     * @param  string $comment Comment associated with this review. Comment can be updated later on another request too. (optional)
     * @param  bool $updatecomment Whether to update the comments. Defaults to true. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ratingRateAsyncWithHttpInfo($type, $entityid, $annonymous, $value = null, $comment = null, $updatecomment = null)
    {
        $returnType = '';
        $request = $this->ratingRateRequest($type, $entityid, $annonymous, $value, $comment, $updatecomment);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ratingRate'
     *
     * @param  string $type The entity type to rate. (required)
     * @param  string $entityid Id of the entity to rate. (required)
     * @param  bool $annonymous Whether to post as annonymous. (required)
     * @param  int $value Value from 0 to 100 with the rating. (optional)
     * @param  string $comment Comment associated with this review. Comment can be updated later on another request too. (optional)
     * @param  bool $updatecomment Whether to update the comments. Defaults to true. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function ratingRateRequest($type, $entityid, $annonymous, $value = null, $comment = null, $updatecomment = null)
    {
        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling ratingRate'
            );
        }
        // verify the required parameter 'entityid' is set
        if ($entityid === null || (is_array($entityid) && count($entityid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $entityid when calling ratingRate'
            );
        }
        // verify the required parameter 'annonymous' is set
        if ($annonymous === null || (is_array($annonymous) && count($annonymous) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annonymous when calling ratingRate'
            );
        }

        $resourcePath = '/rating/rate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($type !== null) {
            if('form' === 'form' && is_array($type)) {
                foreach($type as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['type'] = $type;
            }
        }
        // query params
        if ($entityid !== null) {
            if('form' === 'form' && is_array($entityid)) {
                foreach($entityid as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['entityid'] = $entityid;
            }
        }
        // query params
        if ($value !== null) {
            if('form' === 'form' && is_array($value)) {
                foreach($value as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['value'] = $value;
            }
        }
        // query params
        if ($annonymous !== null) {
            if('form' === 'form' && is_array($annonymous)) {
                foreach($annonymous as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['annonymous'] = $annonymous;
            }
        }
        // query params
        if ($comment !== null) {
            if('form' === 'form' && is_array($comment)) {
                foreach($comment as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['comment'] = $comment;
            }
        }
        // query params
        if ($updatecomment !== null) {
            if('form' === 'form' && is_array($updatecomment)) {
                foreach($updatecomment as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['updatecomment'] = $updatecomment;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Bearer (string) authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ratingRatepending
     *
     * Rates a pre-saved and pre-approved entity
     *
     * @param  string $group The ID of the group of with pre-approved ratings. (required)
     * @param  bool $annonymous Whether to post as annonymous. (required)
     * @param  string $rateid Rate this before returning. (optional)
     * @param  int $value Value from 0 to 100 with the rating. (optional)
     * @param  string $comment Comment associated with this review. Comment can be updated later on another request too. (optional)
     * @param  bool $updatecomment Whether to update the comments. Defaults to true. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function ratingRatepending($group, $annonymous, $rateid = null, $value = null, $comment = null, $updatecomment = null)
    {
        $this->ratingRatependingWithHttpInfo($group, $annonymous, $rateid, $value, $comment, $updatecomment);
    }

    /**
     * Operation ratingRatependingWithHttpInfo
     *
     * Rates a pre-saved and pre-approved entity
     *
     * @param  string $group The ID of the group of with pre-approved ratings. (required)
     * @param  bool $annonymous Whether to post as annonymous. (required)
     * @param  string $rateid Rate this before returning. (optional)
     * @param  int $value Value from 0 to 100 with the rating. (optional)
     * @param  string $comment Comment associated with this review. Comment can be updated later on another request too. (optional)
     * @param  bool $updatecomment Whether to update the comments. Defaults to true. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function ratingRatependingWithHttpInfo($group, $annonymous, $rateid = null, $value = null, $comment = null, $updatecomment = null)
    {
        $request = $this->ratingRatependingRequest($group, $annonymous, $rateid, $value, $comment, $updatecomment);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation ratingRatependingAsync
     *
     * Rates a pre-saved and pre-approved entity
     *
     * @param  string $group The ID of the group of with pre-approved ratings. (required)
     * @param  bool $annonymous Whether to post as annonymous. (required)
     * @param  string $rateid Rate this before returning. (optional)
     * @param  int $value Value from 0 to 100 with the rating. (optional)
     * @param  string $comment Comment associated with this review. Comment can be updated later on another request too. (optional)
     * @param  bool $updatecomment Whether to update the comments. Defaults to true. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ratingRatependingAsync($group, $annonymous, $rateid = null, $value = null, $comment = null, $updatecomment = null)
    {
        return $this->ratingRatependingAsyncWithHttpInfo($group, $annonymous, $rateid, $value, $comment, $updatecomment)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ratingRatependingAsyncWithHttpInfo
     *
     * Rates a pre-saved and pre-approved entity
     *
     * @param  string $group The ID of the group of with pre-approved ratings. (required)
     * @param  bool $annonymous Whether to post as annonymous. (required)
     * @param  string $rateid Rate this before returning. (optional)
     * @param  int $value Value from 0 to 100 with the rating. (optional)
     * @param  string $comment Comment associated with this review. Comment can be updated later on another request too. (optional)
     * @param  bool $updatecomment Whether to update the comments. Defaults to true. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ratingRatependingAsyncWithHttpInfo($group, $annonymous, $rateid = null, $value = null, $comment = null, $updatecomment = null)
    {
        $returnType = '';
        $request = $this->ratingRatependingRequest($group, $annonymous, $rateid, $value, $comment, $updatecomment);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ratingRatepending'
     *
     * @param  string $group The ID of the group of with pre-approved ratings. (required)
     * @param  bool $annonymous Whether to post as annonymous. (required)
     * @param  string $rateid Rate this before returning. (optional)
     * @param  int $value Value from 0 to 100 with the rating. (optional)
     * @param  string $comment Comment associated with this review. Comment can be updated later on another request too. (optional)
     * @param  bool $updatecomment Whether to update the comments. Defaults to true. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function ratingRatependingRequest($group, $annonymous, $rateid = null, $value = null, $comment = null, $updatecomment = null)
    {
        // verify the required parameter 'group' is set
        if ($group === null || (is_array($group) && count($group) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group when calling ratingRatepending'
            );
        }
        // verify the required parameter 'annonymous' is set
        if ($annonymous === null || (is_array($annonymous) && count($annonymous) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $annonymous when calling ratingRatepending'
            );
        }

        $resourcePath = '/rating/ratepending';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($group !== null) {
            if('form' === 'form' && is_array($group)) {
                foreach($group as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['group'] = $group;
            }
        }
        // query params
        if ($rateid !== null) {
            if('form' === 'form' && is_array($rateid)) {
                foreach($rateid as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['rateid'] = $rateid;
            }
        }
        // query params
        if ($value !== null) {
            if('form' === 'form' && is_array($value)) {
                foreach($value as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['value'] = $value;
            }
        }
        // query params
        if ($annonymous !== null) {
            if('form' === 'form' && is_array($annonymous)) {
                foreach($annonymous as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['annonymous'] = $annonymous;
            }
        }
        // query params
        if ($comment !== null) {
            if('form' === 'form' && is_array($comment)) {
                foreach($comment as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['comment'] = $comment;
            }
        }
        // query params
        if ($updatecomment !== null) {
            if('form' === 'form' && is_array($updatecomment)) {
                foreach($updatecomment as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['updatecomment'] = $updatecomment;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ratingVote
     *
     * Votes up or down a rating
     *
     * @param  string $ratingid The ID of the rating to vote on. (required)
     * @param  int $vote 1 to vote up, -1 to vote down. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function ratingVote($ratingid, $vote)
    {
        $this->ratingVoteWithHttpInfo($ratingid, $vote);
    }

    /**
     * Operation ratingVoteWithHttpInfo
     *
     * Votes up or down a rating
     *
     * @param  string $ratingid The ID of the rating to vote on. (required)
     * @param  int $vote 1 to vote up, -1 to vote down. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function ratingVoteWithHttpInfo($ratingid, $vote)
    {
        $request = $this->ratingVoteRequest($ratingid, $vote);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation ratingVoteAsync
     *
     * Votes up or down a rating
     *
     * @param  string $ratingid The ID of the rating to vote on. (required)
     * @param  int $vote 1 to vote up, -1 to vote down. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ratingVoteAsync($ratingid, $vote)
    {
        return $this->ratingVoteAsyncWithHttpInfo($ratingid, $vote)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ratingVoteAsyncWithHttpInfo
     *
     * Votes up or down a rating
     *
     * @param  string $ratingid The ID of the rating to vote on. (required)
     * @param  int $vote 1 to vote up, -1 to vote down. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ratingVoteAsyncWithHttpInfo($ratingid, $vote)
    {
        $returnType = '';
        $request = $this->ratingVoteRequest($ratingid, $vote);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ratingVote'
     *
     * @param  string $ratingid The ID of the rating to vote on. (required)
     * @param  int $vote 1 to vote up, -1 to vote down. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function ratingVoteRequest($ratingid, $vote)
    {
        // verify the required parameter 'ratingid' is set
        if ($ratingid === null || (is_array($ratingid) && count($ratingid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ratingid when calling ratingVote'
            );
        }
        // verify the required parameter 'vote' is set
        if ($vote === null || (is_array($vote) && count($vote) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vote when calling ratingVote'
            );
        }

        $resourcePath = '/rating/vote';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($ratingid !== null) {
            if('form' === 'form' && is_array($ratingid)) {
                foreach($ratingid as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['ratingid'] = $ratingid;
            }
        }
        // query params
        if ($vote !== null) {
            if('form' === 'form' && is_array($vote)) {
                foreach($vote as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['vote'] = $vote;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Bearer (string) authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
