<?php
/**
 * NotificationApi
 * PHP version 5
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * AccuCampus OpenAPI 3
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 4.3.1
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * NotificationApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class NotificationApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $host_index (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $host_index = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $host_index;
    }

    /**
     * Set the host index
     *
     * @param  int Host index (required)
     */
    public function setHostIndex($host_index)
    {
        $this->hostIndex = $host_index;
    }

    /**
     * Get the host index
     *
     * @return Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation notificationDelete
     *
     * Delete a notification
     *
     * @param  string $id The id of the notification to delete. (required)
     * @param  AnyType $body body (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function notificationDelete($id, $body = null)
    {
        $this->notificationDeleteWithHttpInfo($id, $body);
    }

    /**
     * Operation notificationDeleteWithHttpInfo
     *
     * Delete a notification
     *
     * @param  string $id The id of the notification to delete. (required)
     * @param  AnyType $body (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function notificationDeleteWithHttpInfo($id, $body = null)
    {
        $request = $this->notificationDeleteRequest($id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation notificationDeleteAsync
     *
     * Delete a notification
     *
     * @param  string $id The id of the notification to delete. (required)
     * @param  AnyType $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function notificationDeleteAsync($id, $body = null)
    {
        return $this->notificationDeleteAsyncWithHttpInfo($id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation notificationDeleteAsyncWithHttpInfo
     *
     * Delete a notification
     *
     * @param  string $id The id of the notification to delete. (required)
     * @param  AnyType $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function notificationDeleteAsyncWithHttpInfo($id, $body = null)
    {
        $returnType = '';
        $request = $this->notificationDeleteRequest($id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'notificationDelete'
     *
     * @param  string $id The id of the notification to delete. (required)
     * @param  AnyType $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function notificationDeleteRequest($id, $body = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling notificationDelete'
            );
        }

        $resourcePath = '/notification/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Bearer (string) authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation notificationGet
     *
     * View a notification
     *
     * @param  string $id The id of the notification to get. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function notificationGet($id)
    {
        $this->notificationGetWithHttpInfo($id);
    }

    /**
     * Operation notificationGetWithHttpInfo
     *
     * View a notification
     *
     * @param  string $id The id of the notification to get. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function notificationGetWithHttpInfo($id)
    {
        $request = $this->notificationGetRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation notificationGetAsync
     *
     * View a notification
     *
     * @param  string $id The id of the notification to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function notificationGetAsync($id)
    {
        return $this->notificationGetAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation notificationGetAsyncWithHttpInfo
     *
     * View a notification
     *
     * @param  string $id The id of the notification to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function notificationGetAsyncWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->notificationGetRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'notificationGet'
     *
     * @param  string $id The id of the notification to get. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function notificationGetRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling notificationGet'
            );
        }

        $resourcePath = '/notification/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Bearer (string) authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation notificationGetforstation
     *
     * Gets all public (in station) notifications for the specific user
     *
     * @param  string $station The id of the sign-in station to get. (required)
     * @param  string $user The card of the user. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function notificationGetforstation($station, $user)
    {
        $this->notificationGetforstationWithHttpInfo($station, $user);
    }

    /**
     * Operation notificationGetforstationWithHttpInfo
     *
     * Gets all public (in station) notifications for the specific user
     *
     * @param  string $station The id of the sign-in station to get. (required)
     * @param  string $user The card of the user. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function notificationGetforstationWithHttpInfo($station, $user)
    {
        $request = $this->notificationGetforstationRequest($station, $user);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation notificationGetforstationAsync
     *
     * Gets all public (in station) notifications for the specific user
     *
     * @param  string $station The id of the sign-in station to get. (required)
     * @param  string $user The card of the user. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function notificationGetforstationAsync($station, $user)
    {
        return $this->notificationGetforstationAsyncWithHttpInfo($station, $user)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation notificationGetforstationAsyncWithHttpInfo
     *
     * Gets all public (in station) notifications for the specific user
     *
     * @param  string $station The id of the sign-in station to get. (required)
     * @param  string $user The card of the user. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function notificationGetforstationAsyncWithHttpInfo($station, $user)
    {
        $returnType = '';
        $request = $this->notificationGetforstationRequest($station, $user);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'notificationGetforstation'
     *
     * @param  string $station The id of the sign-in station to get. (required)
     * @param  string $user The card of the user. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function notificationGetforstationRequest($station, $user)
    {
        // verify the required parameter 'station' is set
        if ($station === null || (is_array($station) && count($station) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $station when calling notificationGetforstation'
            );
        }
        // verify the required parameter 'user' is set
        if ($user === null || (is_array($user) && count($user) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user when calling notificationGetforstation'
            );
        }

        $resourcePath = '/notification/getforstation';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($station !== null) {
            if('form' === 'form' && is_array($station)) {
                foreach($station as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['station'] = $station;
            }
        }
        // query params
        if ($user !== null) {
            if('form' === 'form' && is_array($user)) {
                foreach($user as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['user'] = $user;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation notificationGetunreadcount
     *
     * Get the number of unread notifications
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function notificationGetunreadcount()
    {
        $this->notificationGetunreadcountWithHttpInfo();
    }

    /**
     * Operation notificationGetunreadcountWithHttpInfo
     *
     * Get the number of unread notifications
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function notificationGetunreadcountWithHttpInfo()
    {
        $request = $this->notificationGetunreadcountRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation notificationGetunreadcountAsync
     *
     * Get the number of unread notifications
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function notificationGetunreadcountAsync()
    {
        return $this->notificationGetunreadcountAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation notificationGetunreadcountAsyncWithHttpInfo
     *
     * Get the number of unread notifications
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function notificationGetunreadcountAsyncWithHttpInfo()
    {
        $returnType = '';
        $request = $this->notificationGetunreadcountRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'notificationGetunreadcount'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function notificationGetunreadcountRequest()
    {

        $resourcePath = '/notification/getunreadcount';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Bearer (string) authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation notificationList
     *
     * View a list of all sent notifications
     *
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $recipient The recipient whose notifications have to be listed. (optional)
     * @param  int $status The status of the notifications to list. Read, Unread or All. (optional)
     * @param  \DateTime $startdate The start date of the period to filter the notifications. (optional)
     * @param  \DateTime $enddate The end date of the period to filter the notifications. (optional)
     * @param  bool $sentonscreen Specifies whether to list the notifications that were sent on-screen or not. (optional)
     * @param  bool $sentemail Specifies whether to list the notifications that were sent via e-mail or not. (optional)
     * @param  bool $sentsms Specifies whether to list the notifications that were sent via sms or not. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function notificationList($from, $count, $recipient = null, $status = null, $startdate = null, $enddate = null, $sentonscreen = null, $sentemail = null, $sentsms = null)
    {
        $this->notificationListWithHttpInfo($from, $count, $recipient, $status, $startdate, $enddate, $sentonscreen, $sentemail, $sentsms);
    }

    /**
     * Operation notificationListWithHttpInfo
     *
     * View a list of all sent notifications
     *
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $recipient The recipient whose notifications have to be listed. (optional)
     * @param  int $status The status of the notifications to list. Read, Unread or All. (optional)
     * @param  \DateTime $startdate The start date of the period to filter the notifications. (optional)
     * @param  \DateTime $enddate The end date of the period to filter the notifications. (optional)
     * @param  bool $sentonscreen Specifies whether to list the notifications that were sent on-screen or not. (optional)
     * @param  bool $sentemail Specifies whether to list the notifications that were sent via e-mail or not. (optional)
     * @param  bool $sentsms Specifies whether to list the notifications that were sent via sms or not. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function notificationListWithHttpInfo($from, $count, $recipient = null, $status = null, $startdate = null, $enddate = null, $sentonscreen = null, $sentemail = null, $sentsms = null)
    {
        $request = $this->notificationListRequest($from, $count, $recipient, $status, $startdate, $enddate, $sentonscreen, $sentemail, $sentsms);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation notificationListAsync
     *
     * View a list of all sent notifications
     *
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $recipient The recipient whose notifications have to be listed. (optional)
     * @param  int $status The status of the notifications to list. Read, Unread or All. (optional)
     * @param  \DateTime $startdate The start date of the period to filter the notifications. (optional)
     * @param  \DateTime $enddate The end date of the period to filter the notifications. (optional)
     * @param  bool $sentonscreen Specifies whether to list the notifications that were sent on-screen or not. (optional)
     * @param  bool $sentemail Specifies whether to list the notifications that were sent via e-mail or not. (optional)
     * @param  bool $sentsms Specifies whether to list the notifications that were sent via sms or not. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function notificationListAsync($from, $count, $recipient = null, $status = null, $startdate = null, $enddate = null, $sentonscreen = null, $sentemail = null, $sentsms = null)
    {
        return $this->notificationListAsyncWithHttpInfo($from, $count, $recipient, $status, $startdate, $enddate, $sentonscreen, $sentemail, $sentsms)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation notificationListAsyncWithHttpInfo
     *
     * View a list of all sent notifications
     *
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $recipient The recipient whose notifications have to be listed. (optional)
     * @param  int $status The status of the notifications to list. Read, Unread or All. (optional)
     * @param  \DateTime $startdate The start date of the period to filter the notifications. (optional)
     * @param  \DateTime $enddate The end date of the period to filter the notifications. (optional)
     * @param  bool $sentonscreen Specifies whether to list the notifications that were sent on-screen or not. (optional)
     * @param  bool $sentemail Specifies whether to list the notifications that were sent via e-mail or not. (optional)
     * @param  bool $sentsms Specifies whether to list the notifications that were sent via sms or not. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function notificationListAsyncWithHttpInfo($from, $count, $recipient = null, $status = null, $startdate = null, $enddate = null, $sentonscreen = null, $sentemail = null, $sentsms = null)
    {
        $returnType = '';
        $request = $this->notificationListRequest($from, $count, $recipient, $status, $startdate, $enddate, $sentonscreen, $sentemail, $sentsms);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'notificationList'
     *
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  string $recipient The recipient whose notifications have to be listed. (optional)
     * @param  int $status The status of the notifications to list. Read, Unread or All. (optional)
     * @param  \DateTime $startdate The start date of the period to filter the notifications. (optional)
     * @param  \DateTime $enddate The end date of the period to filter the notifications. (optional)
     * @param  bool $sentonscreen Specifies whether to list the notifications that were sent on-screen or not. (optional)
     * @param  bool $sentemail Specifies whether to list the notifications that were sent via e-mail or not. (optional)
     * @param  bool $sentsms Specifies whether to list the notifications that were sent via sms or not. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function notificationListRequest($from, $count, $recipient = null, $status = null, $startdate = null, $enddate = null, $sentonscreen = null, $sentemail = null, $sentsms = null)
    {
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling notificationList'
            );
        }
        // verify the required parameter 'count' is set
        if ($count === null || (is_array($count) && count($count) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $count when calling notificationList'
            );
        }

        $resourcePath = '/notification/list';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }
        // query params
        if ($count !== null) {
            if('form' === 'form' && is_array($count)) {
                foreach($count as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['count'] = $count;
            }
        }
        // query params
        if ($recipient !== null) {
            if('form' === 'form' && is_array($recipient)) {
                foreach($recipient as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['recipient'] = $recipient;
            }
        }
        // query params
        if ($status !== null) {
            if('form' === 'form' && is_array($status)) {
                foreach($status as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['status'] = $status;
            }
        }
        // query params
        if ($startdate !== null) {
            if('form' === 'form' && is_array($startdate)) {
                foreach($startdate as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['startdate'] = $startdate;
            }
        }
        // query params
        if ($enddate !== null) {
            if('form' === 'form' && is_array($enddate)) {
                foreach($enddate as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['enddate'] = $enddate;
            }
        }
        // query params
        if ($sentonscreen !== null) {
            if('form' === 'form' && is_array($sentonscreen)) {
                foreach($sentonscreen as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['sentonscreen'] = $sentonscreen;
            }
        }
        // query params
        if ($sentemail !== null) {
            if('form' === 'form' && is_array($sentemail)) {
                foreach($sentemail as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['sentemail'] = $sentemail;
            }
        }
        // query params
        if ($sentsms !== null) {
            if('form' === 'form' && is_array($sentsms)) {
                foreach($sentsms as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['sentsms'] = $sentsms;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Bearer (string) authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation notificationListmine
     *
     * View all the notifications sent to the current user
     *
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  int $status Specifies the status of the notifications to list. Read, Unread or All. (optional)
     * @param  \DateTime $startdate The start date of the period to filter the notifications. (optional)
     * @param  \DateTime $enddate The end date of the period to filter the notifications. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function notificationListmine($from, $count, $status = null, $startdate = null, $enddate = null)
    {
        $this->notificationListmineWithHttpInfo($from, $count, $status, $startdate, $enddate);
    }

    /**
     * Operation notificationListmineWithHttpInfo
     *
     * View all the notifications sent to the current user
     *
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  int $status Specifies the status of the notifications to list. Read, Unread or All. (optional)
     * @param  \DateTime $startdate The start date of the period to filter the notifications. (optional)
     * @param  \DateTime $enddate The end date of the period to filter the notifications. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function notificationListmineWithHttpInfo($from, $count, $status = null, $startdate = null, $enddate = null)
    {
        $request = $this->notificationListmineRequest($from, $count, $status, $startdate, $enddate);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation notificationListmineAsync
     *
     * View all the notifications sent to the current user
     *
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  int $status Specifies the status of the notifications to list. Read, Unread or All. (optional)
     * @param  \DateTime $startdate The start date of the period to filter the notifications. (optional)
     * @param  \DateTime $enddate The end date of the period to filter the notifications. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function notificationListmineAsync($from, $count, $status = null, $startdate = null, $enddate = null)
    {
        return $this->notificationListmineAsyncWithHttpInfo($from, $count, $status, $startdate, $enddate)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation notificationListmineAsyncWithHttpInfo
     *
     * View all the notifications sent to the current user
     *
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  int $status Specifies the status of the notifications to list. Read, Unread or All. (optional)
     * @param  \DateTime $startdate The start date of the period to filter the notifications. (optional)
     * @param  \DateTime $enddate The end date of the period to filter the notifications. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function notificationListmineAsyncWithHttpInfo($from, $count, $status = null, $startdate = null, $enddate = null)
    {
        $returnType = '';
        $request = $this->notificationListmineRequest($from, $count, $status, $startdate, $enddate);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'notificationListmine'
     *
     * @param  int $from The first record to return. (required)
     * @param  int $count The max number of records to return. (required)
     * @param  int $status Specifies the status of the notifications to list. Read, Unread or All. (optional)
     * @param  \DateTime $startdate The start date of the period to filter the notifications. (optional)
     * @param  \DateTime $enddate The end date of the period to filter the notifications. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function notificationListmineRequest($from, $count, $status = null, $startdate = null, $enddate = null)
    {
        // verify the required parameter 'from' is set
        if ($from === null || (is_array($from) && count($from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from when calling notificationListmine'
            );
        }
        // verify the required parameter 'count' is set
        if ($count === null || (is_array($count) && count($count) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $count when calling notificationListmine'
            );
        }

        $resourcePath = '/notification/listmine';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }
        // query params
        if ($count !== null) {
            if('form' === 'form' && is_array($count)) {
                foreach($count as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['count'] = $count;
            }
        }
        // query params
        if ($status !== null) {
            if('form' === 'form' && is_array($status)) {
                foreach($status as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['status'] = $status;
            }
        }
        // query params
        if ($startdate !== null) {
            if('form' === 'form' && is_array($startdate)) {
                foreach($startdate as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['startdate'] = $startdate;
            }
        }
        // query params
        if ($enddate !== null) {
            if('form' === 'form' && is_array($enddate)) {
                foreach($enddate as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['enddate'] = $enddate;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Bearer (string) authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation notificationMarkasread
     *
     * Mark a notification as read
     *
     * @param  string $id The id of the notification to mark as read. If not specified all notifications of the logged user will be marked as read. (optional)
     * @param  int $status Specifies the status to filter the notifications. Read, Unread or All. (optional)
     * @param  \DateTime $startdate The start date of the period to filter the notifications. (optional)
     * @param  \DateTime $enddate The end date of the period to filter the notifications. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function notificationMarkasread($id = null, $status = null, $startdate = null, $enddate = null)
    {
        $this->notificationMarkasreadWithHttpInfo($id, $status, $startdate, $enddate);
    }

    /**
     * Operation notificationMarkasreadWithHttpInfo
     *
     * Mark a notification as read
     *
     * @param  string $id The id of the notification to mark as read. If not specified all notifications of the logged user will be marked as read. (optional)
     * @param  int $status Specifies the status to filter the notifications. Read, Unread or All. (optional)
     * @param  \DateTime $startdate The start date of the period to filter the notifications. (optional)
     * @param  \DateTime $enddate The end date of the period to filter the notifications. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function notificationMarkasreadWithHttpInfo($id = null, $status = null, $startdate = null, $enddate = null)
    {
        $request = $this->notificationMarkasreadRequest($id, $status, $startdate, $enddate);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation notificationMarkasreadAsync
     *
     * Mark a notification as read
     *
     * @param  string $id The id of the notification to mark as read. If not specified all notifications of the logged user will be marked as read. (optional)
     * @param  int $status Specifies the status to filter the notifications. Read, Unread or All. (optional)
     * @param  \DateTime $startdate The start date of the period to filter the notifications. (optional)
     * @param  \DateTime $enddate The end date of the period to filter the notifications. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function notificationMarkasreadAsync($id = null, $status = null, $startdate = null, $enddate = null)
    {
        return $this->notificationMarkasreadAsyncWithHttpInfo($id, $status, $startdate, $enddate)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation notificationMarkasreadAsyncWithHttpInfo
     *
     * Mark a notification as read
     *
     * @param  string $id The id of the notification to mark as read. If not specified all notifications of the logged user will be marked as read. (optional)
     * @param  int $status Specifies the status to filter the notifications. Read, Unread or All. (optional)
     * @param  \DateTime $startdate The start date of the period to filter the notifications. (optional)
     * @param  \DateTime $enddate The end date of the period to filter the notifications. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function notificationMarkasreadAsyncWithHttpInfo($id = null, $status = null, $startdate = null, $enddate = null)
    {
        $returnType = '';
        $request = $this->notificationMarkasreadRequest($id, $status, $startdate, $enddate);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'notificationMarkasread'
     *
     * @param  string $id The id of the notification to mark as read. If not specified all notifications of the logged user will be marked as read. (optional)
     * @param  int $status Specifies the status to filter the notifications. Read, Unread or All. (optional)
     * @param  \DateTime $startdate The start date of the period to filter the notifications. (optional)
     * @param  \DateTime $enddate The end date of the period to filter the notifications. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function notificationMarkasreadRequest($id = null, $status = null, $startdate = null, $enddate = null)
    {

        $resourcePath = '/notification/markasread';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($id !== null) {
            if('form' === 'form' && is_array($id)) {
                foreach($id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['id'] = $id;
            }
        }
        // query params
        if ($status !== null) {
            if('form' === 'form' && is_array($status)) {
                foreach($status as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['status'] = $status;
            }
        }
        // query params
        if ($startdate !== null) {
            if('form' === 'form' && is_array($startdate)) {
                foreach($startdate as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['startdate'] = $startdate;
            }
        }
        // query params
        if ($enddate !== null) {
            if('form' === 'form' && is_array($enddate)) {
                foreach($enddate as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['enddate'] = $enddate;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Bearer (string) authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation notificationMarkasunread
     *
     * Mark a notification as unread
     *
     * @param  string $id The id of the notification to mark as unread. If not specified all notifications of the logged user will be marked as unread. (optional)
     * @param  int $status Specifies the status to filter the notifications. Read, Unread or All. (optional)
     * @param  \DateTime $startdate The start date of the period to filter the notifications. (optional)
     * @param  \DateTime $enddate The end date of the period to filter the notifications. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function notificationMarkasunread($id = null, $status = null, $startdate = null, $enddate = null)
    {
        $this->notificationMarkasunreadWithHttpInfo($id, $status, $startdate, $enddate);
    }

    /**
     * Operation notificationMarkasunreadWithHttpInfo
     *
     * Mark a notification as unread
     *
     * @param  string $id The id of the notification to mark as unread. If not specified all notifications of the logged user will be marked as unread. (optional)
     * @param  int $status Specifies the status to filter the notifications. Read, Unread or All. (optional)
     * @param  \DateTime $startdate The start date of the period to filter the notifications. (optional)
     * @param  \DateTime $enddate The end date of the period to filter the notifications. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function notificationMarkasunreadWithHttpInfo($id = null, $status = null, $startdate = null, $enddate = null)
    {
        $request = $this->notificationMarkasunreadRequest($id, $status, $startdate, $enddate);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation notificationMarkasunreadAsync
     *
     * Mark a notification as unread
     *
     * @param  string $id The id of the notification to mark as unread. If not specified all notifications of the logged user will be marked as unread. (optional)
     * @param  int $status Specifies the status to filter the notifications. Read, Unread or All. (optional)
     * @param  \DateTime $startdate The start date of the period to filter the notifications. (optional)
     * @param  \DateTime $enddate The end date of the period to filter the notifications. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function notificationMarkasunreadAsync($id = null, $status = null, $startdate = null, $enddate = null)
    {
        return $this->notificationMarkasunreadAsyncWithHttpInfo($id, $status, $startdate, $enddate)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation notificationMarkasunreadAsyncWithHttpInfo
     *
     * Mark a notification as unread
     *
     * @param  string $id The id of the notification to mark as unread. If not specified all notifications of the logged user will be marked as unread. (optional)
     * @param  int $status Specifies the status to filter the notifications. Read, Unread or All. (optional)
     * @param  \DateTime $startdate The start date of the period to filter the notifications. (optional)
     * @param  \DateTime $enddate The end date of the period to filter the notifications. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function notificationMarkasunreadAsyncWithHttpInfo($id = null, $status = null, $startdate = null, $enddate = null)
    {
        $returnType = '';
        $request = $this->notificationMarkasunreadRequest($id, $status, $startdate, $enddate);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'notificationMarkasunread'
     *
     * @param  string $id The id of the notification to mark as unread. If not specified all notifications of the logged user will be marked as unread. (optional)
     * @param  int $status Specifies the status to filter the notifications. Read, Unread or All. (optional)
     * @param  \DateTime $startdate The start date of the period to filter the notifications. (optional)
     * @param  \DateTime $enddate The end date of the period to filter the notifications. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function notificationMarkasunreadRequest($id = null, $status = null, $startdate = null, $enddate = null)
    {

        $resourcePath = '/notification/markasunread';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($id !== null) {
            if('form' === 'form' && is_array($id)) {
                foreach($id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['id'] = $id;
            }
        }
        // query params
        if ($status !== null) {
            if('form' === 'form' && is_array($status)) {
                foreach($status as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['status'] = $status;
            }
        }
        // query params
        if ($startdate !== null) {
            if('form' === 'form' && is_array($startdate)) {
                foreach($startdate as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['startdate'] = $startdate;
            }
        }
        // query params
        if ($enddate !== null) {
            if('form' === 'form' && is_array($enddate)) {
                foreach($enddate as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['enddate'] = $enddate;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Bearer (string) authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation notificationSend
     *
     * Send notifications on screen, via email or text to users
     *
     * @param  bool $emailenabled Whether send the notification via email. (required)
     * @param  bool $onscreenenabled Whether to display the notification on screen. (required)
     * @param  bool $smsenabled Whether to send the notification via text message. (required)
     * @param  string $title Notification title. (required)
     * @param  string $tousers Comma-separated Ids of users to send the notification. (optional)
     * @param  string $togroups Comma-separated Ids of user groups to send the notification. (optional)
     * @param  string $onscreenbody Body of the message for on-screen display. (optional)
     * @param  string $onscreenclick What to do when the notification is clicked. Valid values: hide, view, url. (optional)
     * @param  string $onscreenurl Url to redirect the user, if onscreenclick&#x3D;url. (optional)
     * @param  string $onscreenclass How to display the notification. Valid values: info, success, warning, error (optional)
     * @param  int $onscreenduration Time in seconds to display the notification. (optional)
     * @param  int $showonstation Whether to show the notification in the sign-in station. (optional)
     * @param  string $emailfromname Name of the email sender. (optional)
     * @param  string $emailfrom Reply-to email. (optional)
     * @param  string $emailsubject Subject of the email. (optional)
     * @param  string $emailbody Body of the email. (optional)
     * @param  string $textmessagebody Message for SMS. Max 160 characters. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function notificationSend($emailenabled, $onscreenenabled, $smsenabled, $title, $tousers = null, $togroups = null, $onscreenbody = null, $onscreenclick = null, $onscreenurl = null, $onscreenclass = null, $onscreenduration = null, $showonstation = null, $emailfromname = null, $emailfrom = null, $emailsubject = null, $emailbody = null, $textmessagebody = null)
    {
        $this->notificationSendWithHttpInfo($emailenabled, $onscreenenabled, $smsenabled, $title, $tousers, $togroups, $onscreenbody, $onscreenclick, $onscreenurl, $onscreenclass, $onscreenduration, $showonstation, $emailfromname, $emailfrom, $emailsubject, $emailbody, $textmessagebody);
    }

    /**
     * Operation notificationSendWithHttpInfo
     *
     * Send notifications on screen, via email or text to users
     *
     * @param  bool $emailenabled Whether send the notification via email. (required)
     * @param  bool $onscreenenabled Whether to display the notification on screen. (required)
     * @param  bool $smsenabled Whether to send the notification via text message. (required)
     * @param  string $title Notification title. (required)
     * @param  string $tousers Comma-separated Ids of users to send the notification. (optional)
     * @param  string $togroups Comma-separated Ids of user groups to send the notification. (optional)
     * @param  string $onscreenbody Body of the message for on-screen display. (optional)
     * @param  string $onscreenclick What to do when the notification is clicked. Valid values: hide, view, url. (optional)
     * @param  string $onscreenurl Url to redirect the user, if onscreenclick&#x3D;url. (optional)
     * @param  string $onscreenclass How to display the notification. Valid values: info, success, warning, error (optional)
     * @param  int $onscreenduration Time in seconds to display the notification. (optional)
     * @param  int $showonstation Whether to show the notification in the sign-in station. (optional)
     * @param  string $emailfromname Name of the email sender. (optional)
     * @param  string $emailfrom Reply-to email. (optional)
     * @param  string $emailsubject Subject of the email. (optional)
     * @param  string $emailbody Body of the email. (optional)
     * @param  string $textmessagebody Message for SMS. Max 160 characters. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function notificationSendWithHttpInfo($emailenabled, $onscreenenabled, $smsenabled, $title, $tousers = null, $togroups = null, $onscreenbody = null, $onscreenclick = null, $onscreenurl = null, $onscreenclass = null, $onscreenduration = null, $showonstation = null, $emailfromname = null, $emailfrom = null, $emailsubject = null, $emailbody = null, $textmessagebody = null)
    {
        $request = $this->notificationSendRequest($emailenabled, $onscreenenabled, $smsenabled, $title, $tousers, $togroups, $onscreenbody, $onscreenclick, $onscreenurl, $onscreenclass, $onscreenduration, $showonstation, $emailfromname, $emailfrom, $emailsubject, $emailbody, $textmessagebody);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation notificationSendAsync
     *
     * Send notifications on screen, via email or text to users
     *
     * @param  bool $emailenabled Whether send the notification via email. (required)
     * @param  bool $onscreenenabled Whether to display the notification on screen. (required)
     * @param  bool $smsenabled Whether to send the notification via text message. (required)
     * @param  string $title Notification title. (required)
     * @param  string $tousers Comma-separated Ids of users to send the notification. (optional)
     * @param  string $togroups Comma-separated Ids of user groups to send the notification. (optional)
     * @param  string $onscreenbody Body of the message for on-screen display. (optional)
     * @param  string $onscreenclick What to do when the notification is clicked. Valid values: hide, view, url. (optional)
     * @param  string $onscreenurl Url to redirect the user, if onscreenclick&#x3D;url. (optional)
     * @param  string $onscreenclass How to display the notification. Valid values: info, success, warning, error (optional)
     * @param  int $onscreenduration Time in seconds to display the notification. (optional)
     * @param  int $showonstation Whether to show the notification in the sign-in station. (optional)
     * @param  string $emailfromname Name of the email sender. (optional)
     * @param  string $emailfrom Reply-to email. (optional)
     * @param  string $emailsubject Subject of the email. (optional)
     * @param  string $emailbody Body of the email. (optional)
     * @param  string $textmessagebody Message for SMS. Max 160 characters. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function notificationSendAsync($emailenabled, $onscreenenabled, $smsenabled, $title, $tousers = null, $togroups = null, $onscreenbody = null, $onscreenclick = null, $onscreenurl = null, $onscreenclass = null, $onscreenduration = null, $showonstation = null, $emailfromname = null, $emailfrom = null, $emailsubject = null, $emailbody = null, $textmessagebody = null)
    {
        return $this->notificationSendAsyncWithHttpInfo($emailenabled, $onscreenenabled, $smsenabled, $title, $tousers, $togroups, $onscreenbody, $onscreenclick, $onscreenurl, $onscreenclass, $onscreenduration, $showonstation, $emailfromname, $emailfrom, $emailsubject, $emailbody, $textmessagebody)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation notificationSendAsyncWithHttpInfo
     *
     * Send notifications on screen, via email or text to users
     *
     * @param  bool $emailenabled Whether send the notification via email. (required)
     * @param  bool $onscreenenabled Whether to display the notification on screen. (required)
     * @param  bool $smsenabled Whether to send the notification via text message. (required)
     * @param  string $title Notification title. (required)
     * @param  string $tousers Comma-separated Ids of users to send the notification. (optional)
     * @param  string $togroups Comma-separated Ids of user groups to send the notification. (optional)
     * @param  string $onscreenbody Body of the message for on-screen display. (optional)
     * @param  string $onscreenclick What to do when the notification is clicked. Valid values: hide, view, url. (optional)
     * @param  string $onscreenurl Url to redirect the user, if onscreenclick&#x3D;url. (optional)
     * @param  string $onscreenclass How to display the notification. Valid values: info, success, warning, error (optional)
     * @param  int $onscreenduration Time in seconds to display the notification. (optional)
     * @param  int $showonstation Whether to show the notification in the sign-in station. (optional)
     * @param  string $emailfromname Name of the email sender. (optional)
     * @param  string $emailfrom Reply-to email. (optional)
     * @param  string $emailsubject Subject of the email. (optional)
     * @param  string $emailbody Body of the email. (optional)
     * @param  string $textmessagebody Message for SMS. Max 160 characters. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function notificationSendAsyncWithHttpInfo($emailenabled, $onscreenenabled, $smsenabled, $title, $tousers = null, $togroups = null, $onscreenbody = null, $onscreenclick = null, $onscreenurl = null, $onscreenclass = null, $onscreenduration = null, $showonstation = null, $emailfromname = null, $emailfrom = null, $emailsubject = null, $emailbody = null, $textmessagebody = null)
    {
        $returnType = '';
        $request = $this->notificationSendRequest($emailenabled, $onscreenenabled, $smsenabled, $title, $tousers, $togroups, $onscreenbody, $onscreenclick, $onscreenurl, $onscreenclass, $onscreenduration, $showonstation, $emailfromname, $emailfrom, $emailsubject, $emailbody, $textmessagebody);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'notificationSend'
     *
     * @param  bool $emailenabled Whether send the notification via email. (required)
     * @param  bool $onscreenenabled Whether to display the notification on screen. (required)
     * @param  bool $smsenabled Whether to send the notification via text message. (required)
     * @param  string $title Notification title. (required)
     * @param  string $tousers Comma-separated Ids of users to send the notification. (optional)
     * @param  string $togroups Comma-separated Ids of user groups to send the notification. (optional)
     * @param  string $onscreenbody Body of the message for on-screen display. (optional)
     * @param  string $onscreenclick What to do when the notification is clicked. Valid values: hide, view, url. (optional)
     * @param  string $onscreenurl Url to redirect the user, if onscreenclick&#x3D;url. (optional)
     * @param  string $onscreenclass How to display the notification. Valid values: info, success, warning, error (optional)
     * @param  int $onscreenduration Time in seconds to display the notification. (optional)
     * @param  int $showonstation Whether to show the notification in the sign-in station. (optional)
     * @param  string $emailfromname Name of the email sender. (optional)
     * @param  string $emailfrom Reply-to email. (optional)
     * @param  string $emailsubject Subject of the email. (optional)
     * @param  string $emailbody Body of the email. (optional)
     * @param  string $textmessagebody Message for SMS. Max 160 characters. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function notificationSendRequest($emailenabled, $onscreenenabled, $smsenabled, $title, $tousers = null, $togroups = null, $onscreenbody = null, $onscreenclick = null, $onscreenurl = null, $onscreenclass = null, $onscreenduration = null, $showonstation = null, $emailfromname = null, $emailfrom = null, $emailsubject = null, $emailbody = null, $textmessagebody = null)
    {
        // verify the required parameter 'emailenabled' is set
        if ($emailenabled === null || (is_array($emailenabled) && count($emailenabled) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $emailenabled when calling notificationSend'
            );
        }
        // verify the required parameter 'onscreenenabled' is set
        if ($onscreenenabled === null || (is_array($onscreenenabled) && count($onscreenenabled) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $onscreenenabled when calling notificationSend'
            );
        }
        // verify the required parameter 'smsenabled' is set
        if ($smsenabled === null || (is_array($smsenabled) && count($smsenabled) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $smsenabled when calling notificationSend'
            );
        }
        // verify the required parameter 'title' is set
        if ($title === null || (is_array($title) && count($title) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $title when calling notificationSend'
            );
        }

        $resourcePath = '/notification/send';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($tousers !== null) {
            if('form' === 'form' && is_array($tousers)) {
                foreach($tousers as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['tousers'] = $tousers;
            }
        }
        // query params
        if ($togroups !== null) {
            if('form' === 'form' && is_array($togroups)) {
                foreach($togroups as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['togroups'] = $togroups;
            }
        }
        // query params
        if ($emailenabled !== null) {
            if('form' === 'form' && is_array($emailenabled)) {
                foreach($emailenabled as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['emailenabled'] = $emailenabled;
            }
        }
        // query params
        if ($onscreenenabled !== null) {
            if('form' === 'form' && is_array($onscreenenabled)) {
                foreach($onscreenenabled as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['onscreenenabled'] = $onscreenenabled;
            }
        }
        // query params
        if ($smsenabled !== null) {
            if('form' === 'form' && is_array($smsenabled)) {
                foreach($smsenabled as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['smsenabled'] = $smsenabled;
            }
        }
        // query params
        if ($title !== null) {
            if('form' === 'form' && is_array($title)) {
                foreach($title as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['title'] = $title;
            }
        }
        // query params
        if ($onscreenbody !== null) {
            if('form' === 'form' && is_array($onscreenbody)) {
                foreach($onscreenbody as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['onscreenbody'] = $onscreenbody;
            }
        }
        // query params
        if ($onscreenclick !== null) {
            if('form' === 'form' && is_array($onscreenclick)) {
                foreach($onscreenclick as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['onscreenclick'] = $onscreenclick;
            }
        }
        // query params
        if ($onscreenurl !== null) {
            if('form' === 'form' && is_array($onscreenurl)) {
                foreach($onscreenurl as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['onscreenurl'] = $onscreenurl;
            }
        }
        // query params
        if ($onscreenclass !== null) {
            if('form' === 'form' && is_array($onscreenclass)) {
                foreach($onscreenclass as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['onscreenclass'] = $onscreenclass;
            }
        }
        // query params
        if ($onscreenduration !== null) {
            if('form' === 'form' && is_array($onscreenduration)) {
                foreach($onscreenduration as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['onscreenduration'] = $onscreenduration;
            }
        }
        // query params
        if ($showonstation !== null) {
            if('form' === 'form' && is_array($showonstation)) {
                foreach($showonstation as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['showonstation'] = $showonstation;
            }
        }
        // query params
        if ($emailfromname !== null) {
            if('form' === 'form' && is_array($emailfromname)) {
                foreach($emailfromname as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['emailfromname'] = $emailfromname;
            }
        }
        // query params
        if ($emailfrom !== null) {
            if('form' === 'form' && is_array($emailfrom)) {
                foreach($emailfrom as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['emailfrom'] = $emailfrom;
            }
        }
        // query params
        if ($emailsubject !== null) {
            if('form' === 'form' && is_array($emailsubject)) {
                foreach($emailsubject as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['emailsubject'] = $emailsubject;
            }
        }
        // query params
        if ($emailbody !== null) {
            if('form' === 'form' && is_array($emailbody)) {
                foreach($emailbody as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['emailbody'] = $emailbody;
            }
        }
        // query params
        if ($textmessagebody !== null) {
            if('form' === 'form' && is_array($textmessagebody)) {
                foreach($textmessagebody as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['textmessagebody'] = $textmessagebody;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Bearer (string) authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation notificationSendonscreen
     *
     * Send on-screen notifications
     *
     * @param  string $notification The ID of the notification to send. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function notificationSendonscreen($notification)
    {
        $this->notificationSendonscreenWithHttpInfo($notification);
    }

    /**
     * Operation notificationSendonscreenWithHttpInfo
     *
     * Send on-screen notifications
     *
     * @param  string $notification The ID of the notification to send. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function notificationSendonscreenWithHttpInfo($notification)
    {
        $request = $this->notificationSendonscreenRequest($notification);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation notificationSendonscreenAsync
     *
     * Send on-screen notifications
     *
     * @param  string $notification The ID of the notification to send. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function notificationSendonscreenAsync($notification)
    {
        return $this->notificationSendonscreenAsyncWithHttpInfo($notification)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation notificationSendonscreenAsyncWithHttpInfo
     *
     * Send on-screen notifications
     *
     * @param  string $notification The ID of the notification to send. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function notificationSendonscreenAsyncWithHttpInfo($notification)
    {
        $returnType = '';
        $request = $this->notificationSendonscreenRequest($notification);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'notificationSendonscreen'
     *
     * @param  string $notification The ID of the notification to send. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function notificationSendonscreenRequest($notification)
    {
        // verify the required parameter 'notification' is set
        if ($notification === null || (is_array($notification) && count($notification) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $notification when calling notificationSendonscreen'
            );
        }

        $resourcePath = '/notification/sendonscreen';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($notification !== null) {
            if('form' === 'form' && is_array($notification)) {
                foreach($notification as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['notification'] = $notification;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Bearer (string) authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
